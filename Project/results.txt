abstract type A
abstract type A12814{N, T}
abstract type A20086{T, N}
abstract type A20992{T, D, d}
abstract type A21613{S <: Tuple}
abstract type A28593{S <: Real, V <: AbstractVector{S}}
abstract type AArray_17003{T, N}
abstract type AT
abstract type Abstract22734
abstract type AbstractArrayStyle{N} <: BroadcastStyle
abstract type AbstractBroadcasted
abstract type AbstractChannel{T}
abstract type AbstractChar
abstract type AbstractCmd
abstract type AbstractConfig
abstract type AbstractCredential
abstract type AbstractDateTime <: TimeType
abstract type AbstractDateToken
abstract type AbstractDict{K, V}
abstract type AbstractDisplay
abstract type AbstractFile <: IO
abstract type AbstractFloat <: Real
abstract type AbstractGitHash
abstract type AbstractGitObject
abstract type AbstractInterpreter
abstract type AbstractInterval{T} <: Domain{T}
abstract type AbstractIrrational <: Real
abstract type AbstractLattice
abstract type AbstractLock
abstract type AbstractMatch
abstract type AbstractMenu
abstract type AbstractMyType12580{T}
abstract type AbstractMyType18457{T, F, G}
abstract type AbstractNode
abstract type AbstractPattern
abstract type AbstractPipe <: IO
abstract type AbstractPoint{T}
abstract type AbstractQ{T}
abstract type AbstractREPL
abstract type AbstractRGB22592{T} <: Color22592{T, DependentType@2c7b84de}
abstract type AbstractRNG
abstract type AbstractRange{T} <: AbstractArray{T, DependentType@3fee733d}
abstract type AbstractRotation{T}
abstract type AbstractSchedule
abstract type AbstractSerializer
abstract type AbstractSet{T}
abstract type AbstractSlices{T, N} <: AbstractArray{T, N}
abstract type AbstractT27351
abstract type AbstractTerminal <: Base.AbstractPipe
abstract type AbstractTest29307
abstract type AbstractTestSet
abstract type AbstractThing{T, N}
abstract type AbstractTime
abstract type AbstractTriangular{T, S <: AbstractMatrix} <: AbstractMatrix{T}
abstract type AbstractTriangular{T} <: AbstractMatrix{T}
abstract type AbstractTypeNoConstructors
abstract type AbstractUnitRange{T} <: OrdinalRange{T, T}
abstract type Algorithm
abstract type ArithmeticStyle
abstract type ArrayData{T, N} <: AbstractArray{T, N}
abstract type AxisConversionStyle
abstract type B <: A
abstract type B11327 <: A11327
abstract type B20992{SV, T, D, d} <: A20992{T, D, d}
abstract type B33370
abstract type Bar4129
abstract type BroadcastStyle
abstract type C11597{T <: Union{Nothing, Int}}
abstract type C38497{e, g <: Tuple, i}
abstract type C74685{T, N} <: AbstractArray{T, N}
abstract type Calendar <: AbstractTime
abstract type CallInfo
abstract type CategoricalPool{T, R <: Integer, V}
abstract type CategoricalValue{T, R <: Integer}
abstract type Cell
abstract type Change
abstract type Color22592{T, N} <: Colorant22592{T, N}
abstract type Colorant22592{T, N}
abstract type Colorant35855
abstract type Completion
abstract type CompletionProvider
abstract type Component
abstract type ConstResult
abstract type Container{T}
abstract type DA_19281{T, N} <: AbstractArray{T, N}
abstract type DatePeriod <: Period
abstract type Domain{T}
abstract type Enum{T <: Integer}
abstract type Exception
abstract type ExecutionResult
abstract type Factorization{T}
abstract type FixedPoint35855{T <: Integer} <: Real
abstract type FloatInterval{T <: AbstractFloat}
abstract type Foo11367
abstract type Foo24748{T1, T2, T3}
abstract type Foo9378{T, S}
abstract type Foo____{K}
abstract type ForwardableArgtypes
abstract type GitObject <: AbstractGitObject
abstract type HistoryProvider
abstract type IO
abstract type IOServer
abstract type IPAddr
abstract type IT4805_2{N, T}
abstract type IT4805{N, T}
abstract type IndexStyle
abstract type Instant <: AbstractTime
abstract type Integer <: Real
abstract type Interface41024
abstract type Interface41024Extended <: Interface41024
abstract type InvokeType11007
abstract type InvokeX
abstract type InvokeXs
abstract type Issue49050Abs1{T, N} <: Issue49050AbsTop{T, N}
abstract type Issue49050Abs2{T} <: Issue49050Abs1{T, DependentType@5acf9800}
abstract type Issue49050AbsTop{T, N}
abstract type IteratorEltype
abstract type IteratorSize
abstract type LibuvServer <: IOServer
abstract type LibuvStream <: IO
abstract type MethodTableView
abstract type MethodType11007 <: InvokeType11007
abstract type Number
abstract type OrderStyle
abstract type Ordering
abstract type OrdinalRange{T, S} <: AbstractRange{T}
abstract type Outer5906{T}
abstract type P47654{A}
abstract type Paint{T}
abstract type Period <: AbstractTime
abstract type PivotingStrategy
abstract type Qux_{T} <: Sup_{Qux_{Int}, T}
abstract type RangeStepStyle
abstract type Real <: Number
abstract type Result
abstract type RoundingIncrementHelper
abstract type Sampler{E}
abstract type Signed <: Integer
abstract type Sup2a_
abstract type Sup2b_{A <: Sup2a_, B} <: Sup2a_
abstract type Sup_{A, B}
abstract type TextTerminal <: AbstractTerminal
abstract type TimePeriod <: Period
abstract type TimeType <: AbstractTime
abstract type TimeZone
abstract type U
abstract type UniformBits{T <: BitInteger}
abstract type UnixTerminal <: TextTerminal
abstract type Unsigned <: Integer
abstract type WrappedException <: Exception
abstract type X38497{T <: Number}
abstract type Y38497{Integer <: T} <: X38497{T}
abstract type _ConfiguredMenu{C} <: AbstractMenu
abstract type abstest_14825
abstract type at0{T <: Number, N}
abstract type at1{Integer <: T, N} <: at0{T, N}
abstract type b43296{a, j, c, d} <: e43296{a, j}
abstract type e43296{a, j} <: AbstractArray{a, j}
abstract type MultiplicativeInverse{T} <: Number
mutable struct A
mutable struct A1090
mutable struct A11136
mutable struct A4413
mutable struct Alpha
mutable struct B
mutable struct B11136
mutable struct B4413
mutable struct B6980 <: A6980
mutable struct Bar____{K, V} <: Foo____{K}
mutable struct C <: A
mutable struct C4413
mutable struct DoAllocNoEscapeInter
mutable struct Empty12394
mutable struct Foo4115
mutable struct Foo7648
mutable struct GenericIterator{N}
mutable struct IO13433 <: IO
mutable struct LineBreak
mutable struct MSingle
mutable struct REPLBack
mutable struct ShellCompletionProvider <: CompletionProvider
mutable struct TestAbstractArray
mutable struct TestThrowNoGetindex{T} <: AbstractVector{T}
mutable struct Test_type
mutable struct Type11167{T, N}
mutable struct UnimplementedArray{T, N} <: AbstractArray{T, N}
mutable struct UnimplementedFastArray{T, N} <: AbstractArray{T, N}
mutable struct UnimplementedSlowArray{T, N} <: AbstractArray{T, N}
mutable struct Wow____{K, V} <: Foo____{K}
mutable struct X1474{a, b}
struct A12238{T}
struct A23764_2{T, N, S} <: AbstractArray{Union{Ref{T}, S}, N}
struct A23764{T, N, S} <: AbstractArray{Union{T, S}, N}
struct A39218
struct A41010
struct A46327 <: Real
struct A46871{T, N, M} <: AbstractArray{T, N}
struct ANumber <: Number
struct AStruct{N}
struct AUnionParam{T <: Union{Nothing, Float32, Float64}}
struct A_20087
struct AnInteger{S <: Integer}
struct AndAnd
struct Applied{Style, Args <: Tuple}
struct ApplyQuasiArray{T, N, App <: Applied}
struct ArithmeticUnknown <: ArithmeticStyle
struct ArrayConflict <: AbstractArrayStyle{Any}
struct ArrayStyle{A <: AbstractArray} <: AbstractArrayStyle{Any}
struct A{T}
struct B14919 <: A14919
struct B20086{T, N} <: A20086{T, N}
struct B28593{S <: Real, V <: AbstractVector{S}}
struct B46327 <: Real
struct B46871{T, N} <: Ref{A46871{T, N, N}}
struct B9378{T}
struct BStruct{T, S}
struct B_20087
struct BadError <: Exception
struct BandedMatrix{T, CONTAINER, RAXIS}
struct Bar37126{T <: Real, P <: Real}
struct BufferType
struct BuildBotConfig <: Documenter.DeployConfig
struct C43296{t, I}
struct CFoo9378 <: FooB9378{Float64}
struct ColumnNorm <: PivotingStrategy
struct Constructor{F} <: Function
struct CoreSTDERR <: IO
struct CoreSTDOUT <: IO
struct CorruptType
struct CountingSort <: Algorithm
struct CustomNumber <: Number
struct C{T, O}
struct Decimal3
struct DefaultArrayStyle{N} <: AbstractArrayStyle{N}
struct DevNull <: IO
struct DispatchLoopTestAlg <: Base.Sort.Algorithm
struct DivideAndConquer <: Algorithm
struct DivideError <: Exception
struct EOFError <: Exception
struct EltypeUnknown <: IteratorEltype
struct EmptyCompletionProvider <: CompletionProvider
struct EmptyHistoryProvider <: HistoryProvider
struct EmptyImmutable13175
struct EmptyType
struct EmptyType{T}
struct ExtDepStruct
struct F21178{A, B}
struct F49127{m, n} <: Function
struct F49231{a, b, c, d, e, f, g}
struct FailFastError <: Exception
struct FairSchedule <: AbstractSchedule
struct FakeZeroDimArray <: AbstractArray{Int, DependentType@4617c264}
struct FallbackTestSet <: AbstractTestSet
struct FinalBit <: RoundingIncrementHelper
struct Foo
struct Foo27710{T}
struct Foo28079
struct Foo42097{F}
struct ForwardOrdering <: Ordering
struct F{T}
struct GhostStruct
struct HFPotential{kind, T, B, RO <: HFPotentialOperator{T, B}, P <: Integer}
struct HasEltype <: IteratorEltype
struct HasExtensionsStruct
struct HasLength <: IteratorSize
struct HasNoOne
struct HasShape{N} <: IteratorSize
struct HashEnum4 <: Enum{Int}
struct ISOCalendar <: Calendar
struct IndexCartesian <: IndexStyle
struct IndexLinear <: IndexStyle
struct Infinity <: Integer
struct InlineStringIssue57 <: AbstractString
struct InsertionSortAlg <: Algorithm
struct InternalCodeCache
struct InterruptException <: Exception
struct Irrational{sym} <: AbstractIrrational
struct IsInfinite <: IteratorSize
struct Issue29451String <: AbstractString
struct Issue47089{A <: Number, B <: Number}
struct Issue49785{S, T <: S}
struct Iter27594
struct Itr41839_3
struct KWGetindex
struct LatexCompletions <: CompletionProvider
struct MIME{mime}
struct MergeSortAlg <: Algorithm
struct Missing
struct MyArrayStyle <: Broadcast.AbstractArrayStyle{Any}
struct MyArrayStyleDim{N} <: Broadcast.AbstractArrayStyle{N}
struct MyContainerStyle <: BroadcastStyle
struct MyErrorTypeTest <: Exception
struct MyFirstAlg <: Base.Sort.Algorithm
struct MyIdentity{T} <: LinearAlgebra.AbstractQ{T}
struct MyParametricFunc{T}
struct MySecondAlg <: Base.Sort.Algorithm
struct MyType12580{T} <: AbstractMyType12580{T}
struct MyType18457{T, F, G} <: AbstractMyType18457{T, F, G}
struct MyType47877{A, B} <: MyAbstract47877{A}
struct MyType{T}
struct NoCallInfo <: CallInfo
struct NoMethodHasThisType
struct NoPivot <: PivotingStrategy
struct NoValue
struct NonFunctionCallable
struct NonFunctionIsZero
struct NonScalarIndexingOfWithoutMissingVectorAlg <: Base.Sort.Algorithm
struct NotFound
struct Obj43486
struct OneToInf{T <: Integer} <: AbstractUnitRange{T}
struct OneToThree <: AbstractUnitRange{Int}
struct Ones{T, N, Axes}
struct OrOr
struct Ordered <: OrderStyle
struct OutOfMemoryError <: Exception
struct PNG
struct Pick{N} <: Function
struct PrecompilableError <: Exception
struct Q38497{o, e <: NTuple{o}, g} <: C38497{e, g, Array{o}}
struct QRIteration <: Algorithm
struct QuasiAdjoint{T, S}
struct QuickSortAlg <: Algorithm
struct REPLBackendRef
struct RadixSort <: Algorithm
struct RandomStruct23964
struct ReadOnlyMemoryError <: Exception
struct RoundBit <: RoundingIncrementHelper
struct RoundingMode{T}
struct RowMaximum <: PivotingStrategy
struct RowNonZero <: PivotingStrategy
struct S45879{P}
struct S48695{T, N, H <: AbstractArray{T, N}} <: AbstractArray{T, N}
struct SamplerType{T} <: Sampler{T}
struct ScaleMinMax{To, From}
struct SegmentationFault <: Exception
struct SillyArray <: AbstractArray{Float64, DependentType@36baf30c}
struct SingleRange <: AxisConversionStyle
struct SizeUnknown <: IteratorSize
struct SomeFunctor
struct SomeOtherOrder <: Base.Order.Ordering
struct SparseMatrixStyle <: Broadcast.AbstractArrayStyle{DependentType@7a81197d}
struct StackOverflowError <: Exception
struct StaticSchedule <: AbstractSchedule
struct StickyBit <: RoundingIncrementHelper
struct StrangeType18623
struct Struct49454
struct StructWithNoFields
struct StructuredMatrixStyle{T} <: Broadcast.AbstractArrayStyle{DependentType@5ca881b5}
struct Style{T} <: BroadcastStyle
struct SurrealFinite <: Real
struct T
struct T19714 <: Integer
struct T27351 <: AbstractT27351
struct T35888
struct T48006{A1, A2, A3}
struct T48695{T, N, H <: AbstractArray} <: AbstractArray{Union{Missing, T}, N}
struct TT20103{X, Y}
struct TaskLocalRNG <: AbstractRNG
struct TestTVUpper{A <: Integer}
struct TupleOfRanges <: AxisConversionStyle
struct Type4Union
struct TypeA
struct TypeCompareError{A, B} <: Exception
struct TypeWithIntParam{T <: Integer, AbstractArray{T} <: Vector{T} <: A}
struct TypeWithZero
struct TypeWithoutZero
struct UInt104Raw{T} <: UniformBits{T}
struct UInt104{T} <: UniformBits{T}
struct UInt10Raw{T} <: UniformBits{T}
struct UInt10{T} <: UniformBits{T}
struct UInt23Raw{T} <: UniformBits{T}
struct UInt23{T} <: UniformBits{T}
struct UInt2x52Raw{T} <: UniformBits{T}
struct UInt2x52{T} <: UniformBits{T}
struct UInt52Raw{T} <: UniformBits{T}
struct UInt52{T} <: UniformBits{T}
struct UTC <: TimeZone
struct UndefInitializer
struct UndefRefError <: Exception
struct UniformT{T} <: Sampler{T}
struct UnitUpperTriangular{T, S <: AbstractMatrix} <: AbstractTriangular{T, S}
struct Unknown <: BroadcastStyle
struct UnknownType
struct Unordered <: OrderStyle
struct UpperTriangular{T, S <: AbstractMatrix} <: AbstractTriangular{T, S}
struct WeirdNames
struct X
struct X2
struct Y
struct Z
struct Z38497{Int <: T} <: Y38497{T}
struct Zero36193
struct _InitialValue
struct __FIELDS__
struct a32325
struct a34752{T}
struct f_with_params{t} <: Function
struct fmpz
struct h43296{a, j, f, d, i} <: b43296{a, j, f, d}
struct t_docs_abc
struct totally_not_five26034
struct typeA
mutable struct A12089{K, N}
mutable struct A16767{T}
mutable struct A265{T}
mutable struct A3890{T1}
mutable struct A42645{T}
mutable struct ARefxy{T}
mutable struct ARef{T}
mutable struct AliasableConstField{S, T}
mutable struct Atomic{T <: AtomicTypes}
mutable struct Atomic{T}
mutable struct B12238{T, S}
mutable struct B15163{T}
mutable struct B16767{T}
mutable struct B2365{T}
mutable struct B265{T}
mutable struct B3890{T2}
mutable struct B42645{T}
mutable struct Bar22256{AParameter}
mutable struct BitArray{N} <: AbstractArray{Bool, N}
mutable struct BitSet <: AbstractSet{Int}
mutable struct BitSetBoundedMinPrioritySet <: AbstractSet{Int}
mutable struct C16767{T}
mutable struct CFunction <: Ref{Cvoid}
mutable struct CallThisFunc27178{FCN_TYPE}
mutable struct Channel{T} <: AbstractChannel{T}
mutable struct ConcreteThing{T <: AbstractFloat, N} <: AbstractThing{T, N}
mutable struct CustomDict{K, V} <: AbstractDict{K, V}
mutable struct DateRange6387{C} <: AbstractRange{Date6387{C}}
mutable struct Dict{K, V} <: AbstractDict{K, V}
mutable struct DoAllocNoEscapeSparam{T}
mutable struct DynamicMenu <: TerminalMenus._ConfiguredMenu{TerminalMenus.Config}
mutable struct Foo16530a{dim}
mutable struct Foo16530b{dim}
mutable struct Foo4376{T}
mutable struct Foo7810{T <: AbstractVector}
mutable struct FooNTuple{N}
mutable struct FooTupleT{T}
mutable struct Foo{T}
mutable struct GenericIOBuffer{T <: AbstractVector{UInt8}} <: IO
mutable struct HAMT{K, V}
mutable struct HTML{T}
mutable struct Header{level}
mutable struct I1628{X}
mutable struct I2619{T}
mutable struct IdDict{K, V} <: AbstractDict{K, V}
mutable struct IdSet{T} <: AbstractSet{T}
mutable struct IdentityTestKV{K, V}
mutable struct IntDisjointSet{T <: Integer}
mutable struct IntrusiveLinkedListSynchronized{T}
mutable struct IntrusiveLinkedList{T}
mutable struct LazyGenericDomtree{IsPostDom}
mutable struct Leaf{K, V}
mutable struct LinkedListItem{T}
mutable struct MPoint{T} <: AbstractPoint{T}
mutable struct MethodList <: AbstractArray{Method, DependentType@24d46ca6}
mutable struct MultiSelectMenu{C} <: _ConfiguredMenu{C}
mutable struct MultiSelectWithSkipMenu <: TerminalMenus._ConfiguredMenu{TerminalMenus.Config}
mutable struct MyArray{N} <: AbstractArray{Int, N}
mutable struct MyType4154{T}
mutable struct Node2562{T}
mutable struct Node2{T}
mutable struct Node42297{T, V}
mutable struct Node{T}
mutable struct OptimizationState{Interp <: AbstractInterpreter}
mutable struct Pager{C} <: _ConfiguredMenu{C}
mutable struct PartialMutable{S, T}
mutable struct Polygon5884{T <: Real}
mutable struct RadioMenu{C} <: _ConfiguredMenu{C}
mutable struct RefValue{T} <: Ref{T}
mutable struct Refxy{T}
mutable struct S1442{T}
mutable struct SIQ{A, B} <: Number
mutable struct SI{m, s, kg}
mutable struct SafeRefs{S, T}
mutable struct SafeRef{T}
mutable struct Sampler11587{N}
mutable struct ScopedValue{T}
mutable struct Serializer{I <: IO} <: AbstractSerializer
mutable struct SharedArray{T, N} <: DenseArray{T, N}
mutable struct Stable{T, N}
mutable struct Stateful{T, VS, N <: Integer}
mutable struct T10207{A, B}
mutable struct T20267{T}
mutable struct T21719{V}
mutable struct T24Linear{T, N, dims} <: AbstractArray{T, N}
mutable struct T4801{X}
mutable struct TSlow18399{T}
mutable struct TSlowNIndexes{T, N} <: AbstractArray{T, N}
mutable struct Term41096{I, M <: Modulate41096}
mutable struct TestDict{K, V} <: AbstractDict{K, V}
mutable struct TestPushArray{T, N} <: AbstractArray{T, N}
mutable struct TestSet{T} <: AbstractSet{T}
mutable struct Text{T}
mutable struct TupleParam{P}
mutable struct TwoPhaseDefUseMap <: AbstractVector{TwoPhaseVectorView}
mutable struct TwoPhaseVectorView <: AbstractVector{Int}
mutable struct Type11243{A, B}
mutable struct Unstable{T}
mutable struct WeakKeyDict{K, V} <: AbstractDict{K, V}
mutable struct XY{X, Y}
mutable struct callinfos_19805{FUNC_FT <: Function}
mutable struct mt6{T <: Integer, N} <: at1{T, N}
mutable struct t1_14825{A <: abstest_14825, B}
mutable struct t2_14825{C, B} <: abstest_14825
mutable struct type_1{T <: Number} <: Number
struct A11888{T}
struct A28256{names, T <: NamedTuple{names, ??? <: Tuple}}
struct A29955{T, TV <: AbstractVector{T}, TModel <: M29955{T, TV}}
struct A37044{T1, T2}
struct A37890{A, B}
struct A41438{T}
struct A41503{d}
struct A43303{T}
struct A43411{S, T}
struct A44921{T}
struct AD1B{T, N} <: ArrayData{T, N}
struct AD1C{T, N} <: ArrayData{T, N}
struct AD1P{T, N} <: ArrayData{T, N}
struct AD1{T, N} <: ArrayData{T, N}
struct AD2B{T, N} <: ArrayData{T, N}
struct AD2C{T, N} <: ArrayData{T, N}
struct AD2Dim{T} <: ArrayData{T, DependentType@4517d9a3}
struct AD2P{T, N} <: ArrayData{T, N}
struct AD2{T, N} <: ArrayData{T, N}
struct AVL35416{K, V}
struct A_15703{N}
struct Accumulate{F, I, T}
struct AdjointFactorization{T, S <: Factorization} <: Factorization{T}
struct AdjointQ{T, S <: AbstractQ{T}} <: AbstractQ{T}
struct AdjointRotation{T, S <: AbstractRotation{T}} <: AbstractRotation{T}
struct Adjoint{T, S} <: AbstractMatrix{T}
struct AliasableFields{S, T}
struct AliasableField{T}
struct AlmostLU{T, S <: AbstractMatrix{T}}
struct AlwaysHasLayout{T}
struct AnalysisState{T}
struct AnnotatedChar{C <: AbstractChar} <: AbstractChar
struct AnnotatedString{S <: AbstractString} <: AbstractString
struct Array19745{T, N} <: ArrayData{T, N}
struct ArrayWrapper{T, N, A <: AbstractArray} <: AbstractArray{T, N}
struct A{T, N, O} <: AbstractArray{C{T, A{T, N, O}}, N}
struct B12814{N, T} <: A12814{N, T}
struct B16424{T}
struct B21613{S <: Tuple, L} <: A21613{S}
struct B37890{A, B}
struct B40050 <: Ref{Tuple{B40050}}
struct B41438{T}
struct B41503{j, k} <: AbstractArray{A41503{B41503{Any, k}}, Any}
struct BadVector20469{T} <: AbstractVector{Int}
struct Bar29983{S}
struct BestguessInfo{Interp <: AbstractInterpreter}
struct Bidiagonal{T, V <: AbstractVector{T}} <: AbstractMatrix{T}
struct BitMaskedBitArray{N, M}
struct BoolOptimization{T <: Algorithm} <: Algorithm
struct BottomRF{T}
struct BroadcastFunction{F} <: Function
struct Broadcasted{Style <: Union{Nothing, BroadcastStyle}, Axes, F, Args <: Tuple} <: Base.AbstractBroadcasted
struct BunchKaufman{T, S <: AbstractMatrix, P <: AbstractVector{??? <: Integer}} <: Factorization{T}
struct Bunch{N, T}
struct By{T, O} <: Ordering
struct By{T, O}
struct C16424{T, S}
struct C20992{S, n, T, D, d} <: B20992{NTuple{n, S}, T, D, d}
struct CSE{X}
struct CachedMethodTable{T <: MethodTableView} <: MethodTableView
struct CartesianIndex{N} <: AbstractCartesianIndex{N}
struct CartesianIndices{N, R <: NTuple{N, OrdinalRangeInt}} <: AbstractArray{CartesianIndex{N}, N}
struct CassetteLikeWrapper{F}
struct CheckSorted{T <: Algorithm} <: Algorithm
struct CholeskyPivoted{T, S <: AbstractMatrix, P <: AbstractVector{??? <: Integer}} <: Factorization{T}
struct Cholesky{T, S <: AbstractMatrix} <: Factorization{T}
struct CodePointError{T <: Integer} <: Exception
struct CodeUnits{T, S <: AbstractString} <: DenseVector{T}
struct Complex{T <: Real} <: Number
struct ComposedFunction{O, I} <: Function
struct ComputeExtrema{T <: Algorithm} <: Algorithm
struct ConditionalsLattice{L <: AbstractLattice} <: AbstractLattice
struct ConsiderCountingSort{T <: Algorithm, U <: Algorithm} <: Algorithm
struct ConsiderRadixSort{T <: Algorithm, U <: Algorithm} <: Algorithm
struct ConstantRange{T} <: AbstractRange{T}
struct Const{T, N} <: DenseArray{T, N}
struct ContainsPointerNopadding{T}
struct Count{T, S}
struct CyclePadding{P}
struct Cycle{I}
struct D16424{T <: Real, S <: T}
struct D8915{T <: Union{Float32, Float64}}
struct DateFormat{S, T <: Tuple}
struct DatePart{letter} <: AbstractDateToken
struct Delim{T, length} <: AbstractDateToken
struct Diagonal{T, V <: AbstractVector{T}} <: AbstractMatrix{T}
struct DimSelector{dims, T}
struct DropWhile{I, P <: Function}
struct Drop{I}
struct Dual{T <: Real} <: Number
struct DummyRange{T} <: AbstractRange{T}
struct D{NT, DT}
struct EachLine{IOT <: IO}
struct EachStringIndex{T <: AbstractString}
struct Eigen{T, V, S <: AbstractMatrix, U <: AbstractVector} <: Factorization{T}
struct Empty5906{T} <: Outer5906{T}
struct Enumerate{I}
struct Exception31219{T}
struct ExceptionStack <: AbstractArray{Any, DependentType@372f7a8d}
struct ExtremaMap{F} <: Function
struct Extruded{T, K, D}
struct F21666{T <: Base.ArithmeticStyle}
struct F36869{T, V} <: AbstractArray{Union{T, V}, DependentType@2f92e0f4}
struct FieldConvert{FieldTypeA, S}
struct FieldDescStorage{T}
struct FieldTypeRefinement{S, T}
struct Fill44087 <: AbstractArray{Int, DependentType@28a418fc}
struct Fill{T, N, S <: NTuple{N, Integer}} <: AbstractArray{T, N}
struct FilteringRF{F, T}
struct Filter{F, I}
struct Fix1{F, T} <: Function
struct Fix2{F, T} <: Function
struct FlatteningRF{T}
struct Flatten{I}
struct FlipArgs{F}
struct Float22716{T <: AbstractFloat} <: AbstractFloat
struct Foo26601{T}
struct Foo26826{A, B}
struct Foo27204{T}
struct Foo29983{T}
struct FooDictHash{T}
struct Format{S, T}
struct FunctionSum{Tf}
struct Furlong{p, T <: Number} <: Number
struct GeneralizedEigen{T, V, S <: AbstractMatrix, U <: AbstractVector} <: Factorization{T}
struct GeneralizedSVD{T, S <: AbstractMatrix, Tr, C <: AbstractVector{Tr}} <: Factorization{T}
struct GeneralizedSchur{Ty, M <: AbstractMatrix, A <: AbstractVector, B <: AbstractVector{Ty}} <: Factorization{Ty}
struct Generator{I, F}
struct GenericArray{T, N} <: AbstractArray{T, N}
struct GenericCondition{L <: AbstractLock}
struct GenericDict{K, V} <: AbstractDict{K, V}
struct GenericDomTree{IsPostDom}
struct GenericOrder{T}
struct GenericSet{T} <: AbstractSet{T}
struct Givens{T} <: AbstractRotation{T}
struct GraphemeIterator{S <: AbstractString}
struct Gr{N, T}
struct Hanoi5906{T} <: Outer5906{T}
struct HashState{K}
struct Herd{N, T}
struct Hermitian{T, S <: AbstractMatrix{??? <: T}} <: AbstractMatrix{T}
struct HessenbergQ{T, S <: AbstractMatrix, W <: AbstractVector, sym} <: AbstractQ{T}
struct Hessenberg{T, SH <: AbstractMatrix, S <: AbstractMatrix, W <: AbstractVector, V <: Number} <: Factorization{T}
struct IEEEFloatOptimization{T <: Algorithm} <: Algorithm
struct IOContext{IO_t <: IO} <: AbstractPipe
struct IdOffsetRange{T <: Integer, I <: AbstractUnitRange{T}} <: AbstractUnitRange{T}
struct IdentityUnitRange{T <: AbstractUnitRange} <: AbstractUnitRange{Int}
struct ImmutableArray{T, N, A <: AbstractArray} <: AbstractArray{T, N}
struct ImmutableDict{K, V} <: AbstractDict{K, V}
struct ImmutableRef{T}
struct ImmutableTestArray{T, N} <: Base.DenseArray{T, N}
struct InetAddr{T <: IPAddr}
struct InferenceLattice{L <: AbstractLattice} <: AbstractLattice
struct InliningState{Interp <: AbstractInterpreter}
struct Inner5906{T}
struct InnerCtorRT{T}
struct InsertBefore{T <: Union{IRCode, IncrementalCompact}} <: Inserter
struct InterConditionalsLattice{L <: AbstractLattice} <: AbstractLattice
struct InterMustAliasesLattice{L <: AbstractLattice}
struct InterMustAliasesLattice{L <: AbstractLattice} <: AbstractLattice
struct InterTaintLattice{PL <: AbstractLattice} <: CC.AbstractLattice
struct Interval{L, R, T} <: AbstractInterval{T}
struct InvalidCharError{T <: AbstractChar} <: Exception
struct IsUIntMappable{T <: Algorithm, U <: Algorithm} <: Algorithm
struct Issue36437{T}
struct Issue49027{Ty <: Number}
struct Issue49050Concrete{T} <: Issue49050Abs2{T}
struct Issue50544{T <: Tuple}
struct KeySet{K, T <: AbstractDict{K}} <: AbstractSet{K}
struct KronTestArray{T, N, AT} <: AbstractArray{T, N}
struct LDLt{T, S <: AbstractMatrix{T}} <: Factorization{T}
struct LL31783{T}
struct LQPackedQ{T, S <: AbstractMatrix{T}, C <: AbstractVector{T}} <: AbstractQ{T}
struct LQ{T, S <: AbstractMatrix{T}, C <: AbstractVector{T}} <: Factorization{T}
struct LReplace{S <: AbstractString}
struct LU{T, S <: AbstractMatrix{T}, P <: AbstractVector{??? <: Integer}} <: Factorization{T}
struct LessThan{T <: Integer, S} <: Sampler{T}
struct Less{O}
struct LinRange{T, L <: Integer} <: AbstractRange{T}
struct LinSlowMatrix{T} <: DenseArray{T, DependentType@5305068a}
struct LinearIndices{N, R <: NTuple{N, AbstractUnitRange{Int}}} <: AbstractArray{Int, N}
struct Logged{F}
struct LogicalIndex{T, A <: AbstractArray{Bool}} <: AbstractVector{T}
struct Lt{T} <: Ordering
struct M29955{T, TV <: AbstractVector{T}}
struct MappingRF{F, T}
struct Masked{T <: Integer, S} <: Sampler{T}
struct MaybeSome{T}
struct Maybe{T}
struct MeterUnits{T, P} <: Number
struct MissingOptimization{T <: Algorithm} <: Algorithm
struct MockUnitful{T <: TNumber} <: Number
struct ModInt{n}
struct Modulate41096{M <: Union{Function, Val{true}, Val{false}}, id}
struct MulAddMul{ais1, bis0, TA, TB}
struct MustAliasesLattice{L <: AbstractLattice}
struct MustAliasesLattice{L <: AbstractLattice} <: AbstractLattice
struct My8156{A, B}
struct MyArray49392{T, N} <: AbstractArray{T, N}
struct MyArrayWrapper{T, N, A <: AbstractArray{T, N}} <: AbstractArray{T, N}
struct MyArray{T, N} <: AbstractArray{T, N}
struct MyIdentity <: AbstractMatrix{Bool}
struct MyNullable{T}
struct MyQ{T, S <: AbstractQ{T}} <: AbstractQ{T}
struct MyURange <: AbstractUnitRange{Int}
struct NArray_17003{T, N} <: AArray_17003{Nable_17003{T}, N}
struct Nable_17003{T}
struct NewSlotPhi{Phi}
struct Node23685{T}
struct Node35416{T, K, X}
struct Node{N1 <: AbstractNode, N2 <: AbstractNode} <: AbstractNode
struct Node{T}
struct NominalPool{T, R <: Integer, V} <: CategoricalPool{T, R, V}
struct NominalValue{T, R <: Integer} <: CategoricalValue{T, R}
struct Normed35855 <: FixedPoint35855{UInt8}
struct Nullable11904{T}
struct OffsetArray{T, N, AA <: AbstractArray} <: AbstractArray{T, N}
struct OneElVec <: AbstractVector{Bool}
struct OneHotVecOrMat{N} <: AbstractArray{Bool, N}
struct OneTo{T <: Integer} <: AbstractUnitRange{T}
struct OpenInterval{T}
struct OrdinalValue{T, R <: Integer} <: CategoricalValue{T, R}
struct Origin{T <: Union{Tuple{Vararg{Int}}, Int}}
struct P33954{T}
struct Pair{A, B}
struct PartialQuickSort{T <: Union{Integer, OrdinalRange}} <: Algorithm
struct PartialsLattice{L <: AbstractLattice} <: AbstractLattice
struct PartitionIterator{T}
struct PermutedDimsArray{T, N, perm, iperm, AA <: AbstractArray} <: AbstractArray{T, N}
struct Perm{O <: Ordering, V <: AbstractVector} <: Ordering
struct PersistentDict{K, V} <: AbstractDict{K, V}
struct PointerNopadding{T}
struct Point{X}
struct Pool18343{R, V}
struct PrintAll{T} <: Function
struct ProductIterator{T <: Tuple}
struct Q33954{T}
struct QRCompactWYQ{S, M <: AbstractMatrix{S}, C <: AbstractMatrix{S}} <: AbstractQ{S}
struct QRCompactWY{S, M <: AbstractMatrix{S}, C <: AbstractMatrix{S}} <: Factorization{S}
struct QRPackedQ{T, S <: AbstractMatrix{T}, C <: AbstractVector{T}} <: AbstractQ{T}
struct QRPivoted{T, S <: AbstractMatrix{T}, C <: AbstractVector{T}, P <: AbstractVector{??? <: Integer}} <: Factorization{T}
struct QR{T, S <: AbstractMatrix{T}, C <: AbstractVector{T}} <: Factorization{T}
struct Quaternion{T <: Real} <: Number
struct Q{T}
struct REPLDisplay{Repl <: AbstractREPL} <: AbstractDisplay
struct RGB{T <: AbstractFloat} <: Paint{T}
struct RSplitIterator{S <: AbstractString, F}
struct Rational{T <: Integer} <: Real
struct RawBigIntRoundingIncrementHelper{T <: Unsigned}
struct RawBigInt{T <: Unsigned}
struct ReadEachIterator{T, IOT <: IO}
struct RealWrapper{T <: Real} <: Real
struct RefArray{T, A <: AbstractArray{T}, R} <: Ref{T}
struct ReflectionExample{T <: AbstractFloat, N}
struct RegexMatchIterator{S <: AbstractString}
struct RegexMatch{S <: AbstractString} <: AbstractMatch
struct ReinterpretArray{T, N, S, A <: AbstractArray{S}, IsReshaped} <: AbstractArray{T, N}
struct Repeated{O}
struct ReshapedArrayIterator{I, M}
struct ReshapedArray{T, N, P <: AbstractArray, MI <: Tuple{Vararg{SignedMultiplicativeInverse{Int}}}} <: AbstractArray{T, N}
struct ReshapedIndex{T}
struct Rest{I, S}
struct Returns{V} <: Function
struct ReverseOrdering{Fwd <: Ordering} <: Ordering
struct Reverse{O}
struct Reverse{T}
struct Rotation{T} <: AbstractRotation{T}
struct S28356{T <: Union{Float64, Float32}}
struct S32488{S <: Tuple, T, N, L}
struct S36104{K, V}
struct S38888{T}
struct S40{_A, _B, _C, _D, _E, _F, _G, _H, _I, _J, _K, _L, _M, _N, _O, _P, _Q, _R, _S, _T, _U, _V, _W, _X, _Y, _Z, _Z1, _Z2, _Z3, _Z4, _Z5, _Z6, _Z7, _Z8, _Z9, _Z10, _Z11, _Z12, _Z13, _Z14}
struct SA{N, L}
struct SCartesianIndices2{K, R <: AbstractUnitRange{Int}} <: AbstractMatrix{SCartesianIndex2{K}}
struct SIQ20671{T <: Number, m, kg, s, A, K, mol, cd, rad, sr} <: Number
struct SMatrix1{T} <: AbstractArray{T, DependentType@1f32e575}
struct SROAUnswitchUnion1{T}
struct SROAUnswitchUnion2{S, T}
struct SVD{T, Tr, M <: AbstractArray{T}, C <: AbstractVector{Tr}} <: Factorization{T}
struct SamplerBigFloat{I <: FloatInterval{BigFloat}} <: Sampler{BigFloat}
struct SamplerBigInt{SP <: Sampler{Limb}} <: Sampler{BigInt}
struct SamplerRangeFast{U <: BitUnsigned, T <: BitInteger} <: Sampler{T}
struct SamplerRangeInt{T <: Integer, U <: Unsigned} <: Sampler{T}
struct SamplerRangeNDL{U <: Unsigned, T} <: Sampler{T}
struct SamplerSimple{T, S, E} <: Sampler{E}
struct SamplerTag{T, S, E} <: Sampler{E}
struct SamplerTrivial{T, E} <: Sampler{E}
struct Schur{Ty, S <: AbstractMatrix, C <: AbstractVector} <: Factorization{Ty}
struct ScratchQuickSort{L <: Union{Integer, Missing}, H <: Union{Integer, Missing}, T <: Algorithm} <: Algorithm
struct SelfTyA{V}
struct SelfTyB{T}
struct Set{T} <: AbstractSet{T}
struct SignedMultiplicativeInverse{T <: Signed} <: MultiplicativeInverse{T}
struct SimpleVector{T} <: AbstractVector{T}
struct SizedArray{SZ, T, N, A <: AbstractArray} <: AbstractArray{T, N}
struct SkipMissing{T}
struct Slices{P, SM, AX, S, N} <: AbstractSlices{S, N}
struct Slice{T <: AbstractUnitRange} <: AbstractUnitRange{Int}
struct Small{N, T <: Algorithm, U <: Algorithm} <: Algorithm
struct Some{T}
struct SparamUnused{T}
struct SplatNew{T}
struct Splat{F} <: Function
struct SplitIterator{S <: AbstractString, F}
struct SquaresVector <: AbstractArray{Int, DependentType@279f2327}
struct StableCheckSorted{T <: Algorithm} <: Algorithm
struct StepRangeLen{T, R, S, L <: Integer} <: AbstractRange{T}
struct StepRange{T, S} <: OrdinalRange{T, S}
struct StmtRange <: AbstractUnitRange{Int}
struct Strider{T, N} <: AbstractArray{T, N}
struct StructWithUnionAllMethodDefs{T}
struct Struct{T}
struct Str{C} <: AbstractString
struct SubArray{T, N, P, I, L} <: AbstractArray{T, N}
struct SubString{T <: AbstractString} <: AbstractString
struct SubstitutionString{T <: AbstractString} <: AbstractString
struct SymTridiagonal{T, V <: AbstractVector{T}} <: AbstractMatrix{T}
struct Symmetric{T, S <: AbstractMatrix{??? <: T}} <: AbstractMatrix{T}
struct Symmetric{T, S <: AbstractMatrix{T}} <: AbstractMatrix{T}
struct SyntacticallyDefined{T}
struct T11675{T}
struct T20324{T}
struct T20332{T}
struct T20804{T}
struct T26321{N, S <: NTuple{N}}
struct T27269{X, Y <: Vector{X}}
struct T29145{A, B}
struct T44614_1{T}
struct T44614_2{L}
struct T44614_3{L, N}
struct TParamTypeofTest1{T}
struct TParamTypeofTest2{S, T}
struct TSlow{T, N} <: AbstractArray{T, N}
struct T_30763{T}
struct TaintLattice{PL <: AbstractLattice} <: CC.AbstractLattice
struct TakeWhile{I, P <: Function}
struct Take{I}
struct TestNumber{Inner} <: Number
struct TestQuaternion{T} <: Number
struct TransposeFactorization{T, S <: Factorization} <: Factorization{T}
struct Transpose{T, S} <: AbstractMatrix{T}
struct Tridiagonal{T, V <: AbstractVector{T}} <: AbstractMatrix{T}
struct TwicePrecision{T}
struct TypeWith4Params{a, b, c, d}
struct TypeWithIrrelevantParameter{T}
struct TypesView{T}
struct UTInstant{P <: Period} <: Instant
struct UndefComplex{T}
struct UniformScaling{T <: Number}
struct UnitRange{T <: Real} <: AbstractUnitRange{T}
struct UnsafeView{T} <: DenseArray{T, DependentType@2ff4acd0}
struct UnsignedMultiplicativeInverse{T <: Unsigned} <: MultiplicativeInverse{T}
struct UpperHessenberg{T, S <: AbstractMatrix{T}} <: AbstractMatrix{T}
struct Value18343{T, R}
struct ValueIterator{T <: AbstractDict}
struct Val{x}
struct Vec8010{T}
struct VecElement{T}
struct VoxelIndices{T <: Integer}
struct WithoutMissingVector{T, U} <: AbstractVector{T}
struct WorldView{Cache}
struct Wrap1{T}
struct WrappedArray{T, N} <: AbstractArray{T, N}
struct WrappedVector{T} <: AbstractVector{T}
struct Wrapper47654{T, V <: Vec47654{T}}
struct WrapperArray{T, N, A <: AbstractArray{T, N}} <: AbstractArray{T, N}
struct WrapperOneField{T}
struct X41654 <: Ref{X41654}
struct Z14477C{T}
struct ZeroBasedUnitRange{T, A <: AbstractUnitRange{T}} <: AbstractUnitRange{T}
struct Zip{Is <: Tuple}
struct iter31113{T}
struct st3{T <: Integer, N} <: at0{T, N}
struct st4{T, N} <: at0{T, N}
struct st5{Int64 <: T, N} <: at1{T, N}
- @assume_effects :consistent :effect_free @inline function length(s::String, i::Int, j::Int)
+ @@assume_effects:consistent:effect_free@inlinefunction length(s :: String, i :: Int, j :: Int)
- @assume_effects :consistent @inline function two_mul(x::Float64, y::Float64)
+ @@assume_effects:consistent@inlinefunction two_mul(x :: Float64, y :: Float64)
- @assume_effects :consistent @inline function two_mul(x::T, y::T) where T<: Union{Float16, Float32}
+ @@assume_effects:consistent@inlinefunction two_mul(x :: T, y :: T) where T <: Union{Float16, Float32}
- @assume_effects :foldable @inline function codeunit(s::String, i::Int)
+ @@assume_effects:foldable@inlinefunction codeunit(s :: String, i :: Int)
- @assume_effects :foldable function diff_fallback(@nospecialize(a::NamedTuple), @nospecialize(an::Tuple{Vararg{Symbol}}), @nospecialize(bn::Tuple{Vararg{Symbol}}))
+ @@assume_effects:foldablefunction diff_fallback(a :: NamedTuple, an :: Tuple{Vararg{Symbol}}, bn :: Tuple{Vararg{Symbol}})
- @assume_effects :foldable function diff_types(@nospecialize(a::NamedTuple), @nospecialize(names::Tuple{Vararg{Symbol}}))
+ @@assume_effects:foldablefunction diff_types(a :: NamedTuple, names :: Tuple{Vararg{Symbol}})
- @assume_effects :foldable function packedsize(::Type{T}) where T
+ @@assume_effects:foldablefunction packedsize(??? :: Type{T}) where T
- @assume_effects :foldable function padding(T::DataType, baseoffset::Int = 0)
+ @@assume_effects:foldablefunction padding(T :: DataType, baseoffset :: Int = 0)
- @assume_effects :foldable function struct_subpadding(::Type{Out}, ::Type{In}) where {Out, In}
+ @@assume_effects:foldablefunction struct_subpadding(??? :: Type{Out}, ??? :: Type{In}) where Out, In
- @assume_effects :nothrow @inline function __unsafe_string!(out, s::String, offs::Integer)
+ @@assume_effects:nothrow@inlinefunction __unsafe_string!(out, s :: String, offs :: Integer)
- @assume_effects :nothrow @inline function __unsafe_string!(out, s::Symbol, offs::Integer)
+ @@assume_effects:nothrow@inlinefunction __unsafe_string!(out, s :: Symbol, offs :: Integer)
- @assume_effects :terminates_locally :nothrow function rem_internal(x::T, y::T) where {T<:IEEEFloat}
+ @@assume_effects:terminates_locally:nothrowfunction rem_internal(x :: T, y :: T) where T <: IEEEFloat
- @assume_effects :terminates_locally @inline @propagate_inbounds function length_continued(s::String, i::Int, n::Int, c::Int)
+ @@assume_effects:terminates_locally@inline@propagate_inboundsfunction length_continued(s :: String, i :: Int, n :: Int, c :: Int)
- @assume_effects :terminates_locally function _gcd(ain::T, bin::T) where T<:BitInteger
+ @@assume_effects:terminates_locallyfunction _gcd(ain :: T, bin :: T) where T <: BitInteger
- @assume_effects :terminates_locally function ht_keyindex(h::Dict{K,V}, key) where V where K
+ @@assume_effects:terminates_locallyfunction ht_keyindex(h :: Dict{K, V}, key) where V where K
- @assume_effects :terminates_locally function pow_body(x::Float64, n::Integer)
+ @@assume_effects:terminates_locallyfunction pow_body(x :: Float64, n :: Integer)
- @assume_effects :terminates_locally function power_by_squaring(x_, p::Integer)
+ @@assume_effects:terminates_locallyfunction power_by_squaring(x_, p :: Integer)
- @assume_effects :total function (t::Type{T})(x::AbstractIrrational, r::RoundingMode) where T<:Union{Float32,Float64}
+ @@assume_effects:totalfunction t::Type{T}(x :: AbstractIrrational, r :: RoundingMode) where T <: Union{Float32, Float64}
- @assume_effects :total function Rational{T}(x::AbstractIrrational) where T<:Integer
+ @@assume_effects:totalfunction Rational{T}(x :: AbstractIrrational) where T <: Integer
- @assume_effects :total function array_subpadding(S, T)
+ @@assume_effects:totalfunction array_subpadding(S, T)
- @assume_effects :total function cmp(a::Symbol, b::Symbol)
+ @@assume_effects:totalfunction cmp(a :: Symbol, b :: Symbol)
- @assume_effects :total function diff_names(an::Tuple{Vararg{Symbol}}, bn::Tuple{Vararg{Symbol}})
+ @@assume_effects:totalfunction diff_names(an :: Tuple{Vararg{Symbol}}, bn :: Tuple{Vararg{Symbol}})
- @assume_effects :total function hash(s::String, h::UInt)
+ @@assume_effects:totalfunction hash(s :: String, h :: UInt)
- @assume_effects :total function lessrational(rx::Rational{<:Integer}, x::AbstractIrrational)
+ @@assume_effects:totalfunction lessrational(rx :: Rational{??? <: Integer}, x :: AbstractIrrational)
- @assume_effects :total function merge_names(an::Tuple{Vararg{Symbol}}, bn::Tuple{Vararg{Symbol}})
+ @@assume_effects:totalfunction merge_names(an :: Tuple{Vararg{Symbol}}, bn :: Tuple{Vararg{Symbol}})
- @assume_effects :total function merge_types(names::Tuple{Vararg{Symbol}}, a::Type{<:NamedTuple}, b::Type{<:NamedTuple})
+ @@assume_effects:totalfunction merge_types(names :: Tuple{Vararg{Symbol}}, a :: Type{??? <: NamedTuple}, b :: Type{??? <: NamedTuple})
- @assume_effects :total function rationalize(::Type{T}, x::AbstractIrrational; tol::Real=0) where T
+ @@assume_effects:totalfunction rationalize(??? :: Type{T}, x :: AbstractIrrational, tol :: Real = 0) where T
- @commutative function (+)(A::Bidiagonal, B::Diagonal)
+ @@commutativefunction +(A :: Bidiagonal, B :: Diagonal)
- @commutative function (+)(A::Bidiagonal, B::SymTridiagonal)
+ @@commutativefunction +(A :: Bidiagonal, B :: SymTridiagonal)
- @commutative function (+)(A::Bidiagonal, B::Tridiagonal)
+ @@commutativefunction +(A :: Bidiagonal, B :: Tridiagonal)
- @commutative function (+)(A::Bidiagonal, B::UniformScaling)
+ @@commutativefunction +(A :: Bidiagonal, B :: UniformScaling)
- @commutative function (+)(A::Diagonal, B::SymTridiagonal)
+ @@commutativefunction +(A :: Diagonal, B :: SymTridiagonal)
- @commutative function (+)(A::Diagonal, B::Tridiagonal)
+ @@commutativefunction +(A :: Diagonal, B :: Tridiagonal)
- @commutative function (+)(A::Diagonal, B::UniformScaling)
+ @@commutativefunction +(A :: Diagonal, B :: UniformScaling)
- @commutative function (+)(A::SymTridiagonal, B::UniformScaling)
+ @@commutativefunction +(A :: SymTridiagonal, B :: UniformScaling)
- @commutative function (+)(A::Tridiagonal, B::UniformScaling)
+ @@commutativefunction +(A :: Tridiagonal, B :: UniformScaling)
- @constprop :aggressive @inline function ^(x::Float64, n::Integer)
+ @@constprop:aggressive@inlinefunction ^(x :: Float64, n :: Integer)
- @constprop :aggressive function (T::Union{Type{Int8},Type{UInt8}})(c::Char)
+ @@constprop:aggressivefunction T::Union{Type{Int8},Type{UInt8}}(c :: Char)
- @constprop :aggressive function Char(b::Union{Int8,UInt8})
+ @@constprop:aggressivefunction Char(b :: Union{Int8, UInt8})
- @constprop :aggressive function Char(u::UInt32)
+ @@constprop:aggressivefunction Char(u :: UInt32)
- @constprop :aggressive function UInt32(c::Char)
+ @@constprop:aggressivefunction UInt32(c :: Char)
- @constprop :aggressive function ^(x::Float64, y::Float64)
+ @@constprop:aggressivefunction ^(x :: Float64, y :: Float64)
- @constprop :aggressive function ^(x::T, y::T) where T <: Union{Float16, Float32}
+ @@constprop:aggressivefunction ^(x :: T, y :: T) where T <: Union{Float16, Float32}
- @constprop :aggressive function _dim_stack(dims::Integer, ::Type{T}, ::Type{S}, A) where {T,S}
+ @@constprop:aggressivefunction _dim_stack(dims :: Integer, ??? :: Type{T}, ??? :: Type{S}, A) where T, S
- @constprop :aggressive function _eachslice(A::AbstractArray{T,N}, dims::NTuple{M,Integer}, drop::Bool) where {T,N,M}
+ @@constprop:aggressivefunction _eachslice(A :: AbstractArray{T, N}, dims :: NTuple{M, Integer}, drop :: Bool) where T, N, M
- @constprop :aggressive function decode_overlong(c::Char)
+ @@constprop:aggressivefunction decode_overlong(c :: Char)
- @constprop :aggressive function split_rest(t::NamedTuple{names}, n::Int, st...) where {names}
+ @@constprop:aggressivefunction split_rest(t :: NamedTuple{names}, n :: Int, st...) where names
- @constprop :none function _require_search_from_serialized(pkg::PkgId, sourcepath::String, build_id::UInt128)
+ @@constprop:nonefunction _require_search_from_serialized(pkg :: PkgId, sourcepath :: String, build_id :: UInt128)
- @constprop :none function register_root_module(m::Module)
+ @@constprop:nonefunction register_root_module(m :: Module)
- @constprop :none function rehash!(h::Dict{K,V}, newsz = length(h.keys)) where V where K
+ @@constprop:nonefunction rehash!(h :: Dict{K, V}, newsz = length(h.keys)) where V where K
- @constprop :none function stale_cachefile(modkey::PkgId, build_id::UInt128, modpath::String, cachefile::String; ignore_loaded::Bool = false)
+ @@constprop:nonefunction stale_cachefile(modkey :: PkgId, build_id :: UInt128, modpath :: String, cachefile :: String, ignore_loaded :: Bool = false)
- @constprop :none function stale_cachefile(modpath::String, cachefile::String; ignore_loaded::Bool = false)
+ @@constprop:nonefunction stale_cachefile(modpath :: String, cachefile :: String, ignore_loaded :: Bool = false)
- @generated function ModTparamTestStruct{M}() where {M}
+ @@generatedfunction ModTparamTestStruct{M} where M
- @generated function Sampler(RNG::Type{<:AbstractRNG}, t::Tuple, n::Repetition)
+ @@generatedfunction Sampler(RNG :: Type{??? <: AbstractRNG}, t :: Tuple, n :: Repetition)
- @generated function _g_f_with_inner(x)
+ @@generatedfunction _g_f_with_inner(x)
- @generated function _g_f_with_inner2(x)
+ @@generatedfunction _g_f_with_inner2(x)
- @generated function _unique_dims(A::AbstractArray{T,N}, dim::Integer) where {T,N}
+ @@generatedfunction _unique_dims(A :: AbstractArray{T, N}, dim :: Integer) where T, N
- @generated function _unsafe_getindex!(X::BitArray, B::BitArray, I::Union{Int,AbstractArray{Int}}...)
+ @@generatedfunction _unsafe_getindex!(X :: BitArray, B :: BitArray, I :: Union{Int, AbstractArray{Int}}...)
- @generated function _unsafe_getindex!(dest::AbstractArray, src::AbstractArray, I::Vararg{Union{Real, AbstractArray}, N}) where N
+ @@generatedfunction _unsafe_getindex!(dest :: AbstractArray, src :: AbstractArray, I :: Vararg{Union{Real, AbstractArray}, N}) where N
- @generated function _unsafe_setindex!(::IndexStyle, A::AbstractArray, x, I::Vararg{Union{Real,AbstractArray}, N}) where N
+ @@generatedfunction _unsafe_setindex!(??? :: IndexStyle, A :: AbstractArray, x, I :: Vararg{Union{Real, AbstractArray}, N}) where N
- @generated function bar(x)
+ @@generatedfunction bar(x)
- @generated function decorate(t)
+ @@generatedfunction decorate(t)
- @generated function f10178(x::X) where X
+ @@generatedfunction f10178(x :: X) where X
- @generated function f10502(x...)
+ @@generatedfunction f10502(x...)
- @generated function f11982(T)
+ @@generatedfunction f11982(T)
- @generated function f12474(::Any)
+ @@generatedfunction f12474(??? :: Any)
- @generated function f2(a)
+ @@generatedfunction f2(a)
- @generated function f3()
+ @@generatedfunction f3
- @generated function f30284(x)
+ @@generatedfunction f30284(x)
- @generated function f33243()
+ @@generatedfunction f33243
- @generated function f9088(x, a=5)
+ @@generatedfunction f9088(x, a = 5)
- @generated function f_vararg_generated(args...)
+ @@generatedfunction f_vararg_generated(args...)
- @generated function foo1(a::Array{T,N}) where {N,T}
+ @@generatedfunction foo1(a :: Array{T, N}) where N, T
- @generated function foo2(a::Array{T,N}) where {T,N}
+ @@generatedfunction foo2(a :: Array{T, N}) where T, N
- @generated function foo9677(x::AbstractArray{T,N}) where {T,N}
+ @@generatedfunction foo9677(x :: AbstractArray{T, N}) where T, N
- @generated function format(io::IO, dt::TimeType, fmt::DateFormat{<:Any,T}) where T
+ @@generatedfunction format(io :: IO, dt :: TimeType, fmt :: DateFormat{??? <: Any, T}) where T
- @generated function generated_only_simple(x)
+ @@generatedfunction generated_only_simple(x)
- @generated function gf_err()
+ @@generatedfunction gf_err
- @generated function gf_err2(::f) where {f}
+ @@generatedfunction gf_err2(??? :: f) where f
- @generated function h(x)
+ @@generatedfunction h(x)
- @generated function isassigned(B::BitArray, I_0::Int, I::Int...)
+ @@generatedfunction isassigned(B :: BitArray, I_0 :: Int, I :: Int...)
- @generated function mygetindex(S::SubArray, indices::Real...)
+ @@generatedfunction mygetindex(S :: SubArray, indices :: Real...)
- @generated function parse_components(str::AbstractString, df::DateFormat)
+ @@generatedfunction parse_components(str :: AbstractString, df :: DateFormat)
- @generated function rand(rng::AbstractRNG, sp::SamplerSimple{T}) where T<:Tuple
+ @@generatedfunction rand(rng :: AbstractRNG, sp :: SamplerSimple{T}) where T <: Tuple
- @generated function reindex(idxs::Tuple{AbstractArray{T,N}, Vararg{Any}}, subidxs::Tuple{Vararg{Any}}) where {T,N}
+ @@generatedfunction reindex(idxs :: Tuple{AbstractArray{T, N}, Vararg{Any}}, subidxs :: Tuple{Vararg{Any}}) where T, N
- @generated function s(x)
+ @@generatedfunction s(x)
- @generated function splat(a,b...)
+ @@generatedfunction splat(a, b...)
- @generated function splat2(a...)
+ @@generatedfunction splat2(a...)
- @generated function splat3(A::AbstractArray{T,N}, indx::Base.RangeIndex...) where {T,N}
+ @@generatedfunction splat3(A :: AbstractArray{T, N}, indx :: Base.RangeIndex...) where T, N
- @generated function staged_t1(a,b)
+ @@generatedfunction staged_t1(a, b)
- @generated function test_20902()
+ @@generatedfunction test_20902
- @generated function thrice_iota(::Type{Vec{N,T}}) where {N,T}
+ @@generatedfunction thrice_iota(??? :: Type{Vec{N, T}}) where N, T
- @generated function vecadd(x::Vec{N, T}, y::Vec{N, T}) where {N, T}
+ @@generatedfunction vecadd(x :: Vec{N, T}, y :: Vec{N, T}) where N, T
- @inline function  _find_nonascii_chunk(chunk_size,cu::AbstractVector{CU}, first,last) where {CU}
+ @@inlinefunction _find_nonascii_chunk(chunk_size, cu :: AbstractVector{CU}, first, last) where CU
- @inline function  _isascii_chunks(chunk_size,cu::AbstractVector{CU}, first,last) where {CU}
+ @@inlinefunction _isascii_chunks(chunk_size, cu :: AbstractVector{CU}, first, last) where CU
- @inline function (op::FlatteningRF)(acc, x)
+ @@inlinefunction op::FlatteningRF(acc, x)
- @inline function +(x::T, y::Integer) where {T<:AbstractChar}
+ @@inlinefunction +(x :: T, y :: Integer) where T <: AbstractChar
- @inline function -(x::T, y::Integer) where {T<:AbstractChar}
+ @@inlinefunction -(x :: T, y :: Integer) where T <: AbstractChar
- @inline function A1()
+ @@inlinefunction A1
- @inline function A2()
+ @@inlinefunction A2
- @inline function B1()
+ @@inlinefunction B1
- @inline function Base._reverse(iter::CartesianIndices, ::Colon)
+ @@inlinefunction Base._reverse(iter :: CartesianIndices, ??? :: Colon)
- @inline function Base.fill!(F::Fill, v)
+ @@inlinefunction Base.fill!(F :: Fill, v)
- @inline function Base.getindex(A::OffsetArray, r::AbstractUnitRange{Int})
+ @@inlinefunction Base.getindex(A :: OffsetArray, r :: AbstractUnitRange{Int})
- @inline function Base.getindex(A::OffsetArray{<:Any,N}, I::Vararg{Int,N}) where N
+ @@inlinefunction Base.getindex(A :: OffsetArray{??? <: Any, N}, I :: Vararg{Int, N}) where N
- @inline function Base.getindex(A::OffsetVector, i::Int)
+ @@inlinefunction Base.getindex(A :: OffsetVector, i :: Int)
- @inline function Base.getindex(A::OffsetVector, r::AbstractRange{Int})
+ @@inlinefunction Base.getindex(A :: OffsetVector, r :: AbstractRange{Int})
- @inline function Base.getindex(A::OffsetVector, r::AbstractUnitRange{Int})
+ @@inlinefunction Base.getindex(A :: OffsetVector, r :: AbstractUnitRange{Int})
- @inline function Base.getindex(A::PermutedDimsArray{T,N,perm,iperm}, I::Vararg{Int,N}) where {T,N,perm,iperm}
+ @@inlinefunction Base.getindex(A :: PermutedDimsArray{T, N, perm, iperm}, I :: Vararg{Int, N}) where T, N, perm, iperm
- @inline function Base.getindex(F::Fill{<:Any,N}, i::Vararg{Int,N}) where {N}
+ @@inlinefunction Base.getindex(F :: Fill{??? <: Any, N}, i :: Vararg{Int, N}) where N
- @inline function Base.getindex(bc::Broadcasted, I::Union{Integer,CartesianIndex})
+ @@inlinefunction Base.getindex(bc :: Broadcasted, I :: Union{Integer, CartesianIndex})
- @inline function Base.getindex(iter::CartesianIndices{N,R}, I::Vararg{Int, N}) where {N,R}
+ @@inlinefunction Base.getindex(iter :: CartesianIndices{N, R}, I :: Vararg{Int, N}) where N, R
- @inline function Base.getindex(r::IdOffsetRange, i::Integer)
+ @@inlinefunction Base.getindex(r :: IdOffsetRange, i :: Integer)
- @inline function Base.isassigned(A::Bidiagonal, i::Int, j::Int)
+ @@inlinefunction Base.isassigned(A :: Bidiagonal, i :: Int, j :: Int)
- @inline function Base.isassigned(A::HermOrSym, i::Int, j::Int)
+ @@inlinefunction Base.isassigned(A :: HermOrSym, i :: Int, j :: Int)
- @inline function Base.isassigned(A::SymTridiagonal, i::Int, j::Int)
+ @@inlinefunction Base.isassigned(A :: SymTridiagonal, i :: Int, j :: Int)
- @inline function Base.isassigned(A::Tridiagonal, i::Int, j::Int)
+ @@inlinefunction Base.isassigned(A :: Tridiagonal, i :: Int, j :: Int)
- @inline function Base.isassigned(D::Diagonal, i::Int, j::Int)
+ @@inlinefunction Base.isassigned(D :: Diagonal, i :: Int, j :: Int)
- @inline function Base.isstored(A::Bidiagonal, i::Int, j::Int)
+ @@inlinefunction Base.isstored(A :: Bidiagonal, i :: Int, j :: Int)
- @inline function Base.isstored(A::SymTridiagonal, i::Int, j::Int)
+ @@inlinefunction Base.isstored(A :: SymTridiagonal, i :: Int, j :: Int)
- @inline function Base.isstored(A::Tridiagonal, i::Int, j::Int)
+ @@inlinefunction Base.isstored(A :: Tridiagonal, i :: Int, j :: Int)
- @inline function Base.isstored(D::Diagonal, i::Int, j::Int)
+ @@inlinefunction Base.isstored(D :: Diagonal, i :: Int, j :: Int)
- @inline function Base.setindex!(A::OffsetArray{T,N}, val, I::Vararg{Int,N}) where {T,N}
+ @@inlinefunction Base.setindex!(A :: OffsetArray{T, N}, val, I :: Vararg{Int, N}) where T, N
- @inline function Base.setindex!(A::OffsetVector, val, i::Int)
+ @@inlinefunction Base.setindex!(A :: OffsetVector, val, i :: Int)
- @inline function Base.setindex!(A::PermutedDimsArray{T,N,perm,iperm}, val, I::Vararg{Int,N}) where {T,N,perm,iperm}
+ @@inlinefunction Base.setindex!(A :: PermutedDimsArray{T, N, perm, iperm}, val, I :: Vararg{Int, N}) where T, N, perm, iperm
- @inline function Base.setindex!(F::Fill, v, k::Integer)
+ @@inlinefunction Base.setindex!(F :: Fill, v, k :: Integer)
- @inline function Base.to_index(r::OffsetUnitRange{<:Union{Int,BigInt}})
+ @@inlinefunction Base.to_index(r :: OffsetUnitRange{??? <: Union{Int, BigInt}})
- @inline function Base.unsafe_convert(::Type{Ref{BigFloat}}, x::Ref{BigFloat})
+ @@inlinefunction Base.unsafe_convert(??? :: Type{Ref{BigFloat}}, x :: Ref{BigFloat})
- @inline function BitMaskedBitArray(parent::BitArray{N}, mask::BitArray{M}) where {N,M}
+ @@inlinefunction BitMaskedBitArray(parent :: BitArray{N}, mask :: BitArray{M}) where N, M
- @inline function DoAllocNoEscapeSparam(x::T) where {T}
+ @@inlinefunction DoAllocNoEscapeSparam(x :: T) where T
- @inline function MulAddMul(alpha::TA, beta::TB) where {TA,TB}
+ @@inlinefunction MulAddMul(alpha :: TA, beta :: TB) where TA, TB
- @inline function OffsetArray(A::AbstractArray, offsets::Tuple{Vararg{Integer}}; kw...)
+ @@inlinefunction OffsetArray(A :: AbstractArray, offsets :: Tuple{Vararg{Integer}}, kw...)
- @inline function OffsetArray{T, N, AA}(parent::AA, offsets::NTuple{N, Int}; checkoverflow = true) where {T, N, AA<:AbstractArray{T,N}}
+ @@inlinefunction OffsetArray{T,N,AA}(parent :: AA, offsets :: NTuple{N, Int}, checkoverflow = true) where T, N, AA <: AbstractArray{T, N}
- @inline function OffsetArray{T, N, AA}(parent::AbstractArray{<:Any,N}, offsets::NTuple{N, Integer}; kw...) where {T, N, AA<:AbstractArray{T,N}}
+ @@inlinefunction OffsetArray{T,N,AA}(parent :: AbstractArray{??? <: Any, N}, offsets :: NTuple{N, Integer}, kw...) where T, N, AA <: AbstractArray{T, N}
- @inline function OffsetArray{T, N}(init::ArrayInitializer, inds::Tuple; kw...) where {T, N}
+ @@inlinefunction OffsetArray{T,N}(init :: ArrayInitializer, inds :: Tuple, kw...) where T, N
- @inline function OffsetArray{T,N,A}(M::AbstractArray{<:Any,N}, I::NTuple{N,Int}; checkoverflow = true) where {T,N,A<:AbstractArray{T,N}}
+ @@inlinefunction OffsetArray{T,N,A}(M :: AbstractArray{??? <: Any, N}, I :: NTuple{N, Int}, checkoverflow = true) where T, N, A <: AbstractArray{T, N}
- @inline function OffsetArray{T,N,A}(M::AbstractArray{<:Any,N}, I::Tuple; kw...) where {T,N,A<:AbstractArray{T,N}}
+ @@inlinefunction OffsetArray{T,N,A}(M :: AbstractArray{??? <: Any, N}, I :: Tuple, kw...) where T, N, A <: AbstractArray{T, N}
- @inline function OffsetArray{T,N,A}(M::AbstractArray{<:Any,N}, I::Tuple{AbstractUnitRange,Vararg{AbstractUnitRange}}; kw...) where {T,N,A<:AbstractArray{T,N}}
+ @@inlinefunction OffsetArray{T,N,A}(M :: AbstractArray{??? <: Any, N}, I :: Tuple{AbstractUnitRange, Vararg{AbstractUnitRange}}, kw...) where T, N, A <: AbstractArray{T, N}
- @inline function OffsetArray{T,N,A}(M::AbstractArray{<:Any,N}; kw...) where {T,N,A<:AbstractArray{T,N}}
+ @@inlinefunction OffsetArray{T,N,A}(M :: AbstractArray{??? <: Any, N}, kw...) where T, N, A <: AbstractArray{T, N}
- @inline function OffsetArray{T,N}(M::AbstractArray{<:Any,N}, I...; kw...) where {T,N}
+ @@inlinefunction OffsetArray{T,N}(M :: AbstractArray{??? <: Any, N}, I..., kw...) where T, N
- @inline function OffsetArray{T,N}(init::ArrayInitializer, inds::Tuple{Vararg{OffsetAxisKnownLength}}; kw...) where {T,N}
+ @@inlinefunction OffsetArray{T,N}(init :: ArrayInitializer, inds :: Tuple{Vararg{OffsetAxisKnownLength}}, kw...) where T, N
- @inline function OffsetArray{T}(init::ArrayInitializer, inds::Tuple; kw...) where {T}
+ @@inlinefunction OffsetArray{T}(init :: ArrayInitializer, inds :: Tuple, kw...) where T
- @inline function SimdLoop.simd_index(::SCartesianIndices2{K}, Ilast::Int, I1::Int) where {K}
+ @@inlinefunction SimdLoop.simd_index(??? :: SCartesianIndices2{K}, Ilast :: Int, I1 :: Int) where K
- @inline function Stateful(itr::T) where {T}
+ @@inlinefunction Stateful(itr :: T) where T
- @inline function Stateful{<:Any, Any}(itr::T) where {T}
+ @@inlinefunction Stateful{<:Any,Any}(itr :: T) where T
- @inline function __convert_digit(_c::UInt32, base::UInt32)
+ @@inlinefunction __convert_digit(_c :: UInt32, base :: UInt32)
- @inline function __dec(state::Tuple{Int,Int,Vararg{Int}}, indices::Tuple{OrdinalRangeInt,OrdinalRangeInt,Vararg{OrdinalRangeInt}})
+ @@inlinefunction __dec(state :: Tuple{Int, Int, Vararg{Int}}, indices :: Tuple{OrdinalRangeInt, OrdinalRangeInt, Vararg{OrdinalRangeInt}})
- @inline function __dec(state::Tuple{Int}, indices::Tuple{OrdinalRangeInt})
+ @@inlinefunction __dec(state :: Tuple{Int}, indices :: Tuple{OrdinalRangeInt})
- @inline function __inc(state::Tuple{Int,Int,Vararg{Int}}, indices::Tuple{OrdinalRangeInt,OrdinalRangeInt,Vararg{OrdinalRangeInt}})
+ @@inlinefunction __inc(state :: Tuple{Int, Int, Vararg{Int}}, indices :: Tuple{OrdinalRangeInt, OrdinalRangeInt, Vararg{OrdinalRangeInt}})
- @inline function __inc(state::Tuple{Int}, indices::Tuple{OrdinalRangeInt})
+ @@inlinefunction __inc(state :: Tuple{Int}, indices :: Tuple{OrdinalRangeInt})
- @inline function __normalize!(a::AbstractArray, nrm)
+ @@inlinefunction __normalize!(a :: AbstractArray, nrm)
- @inline function __unsafe_string!(out, c::Char, offs::Integer)
+ @@inlinefunction __unsafe_string!(out, c :: Char, offs :: Integer)
- @inline function __unsafe_string!(out, s::SubString{String}, offs::Integer)
+ @@inlinefunction __unsafe_string!(out, s :: SubString{String}, offs :: Integer)
- @inline function _all_tuple(f, anymissing, x, rest...)
+ @@inlinefunction _all_tuple(f, anymissing, x, rest...)
- @inline function _any_tuple(f, anymissing, x, rest...)
+ @@inlinefunction _any_tuple(f, anymissing, x, rest...)
- @inline function _approx_cbrt(x::T) where {T<:Union{Float32,Float64}}
+ @@inlinefunction _approx_cbrt(x :: T) where T <: Union{Float32, Float64}
- @inline function _bits2float(x::UInt64, ::Type{Float32})
+ @@inlinefunction _bits2float(x :: UInt64, ??? :: Type{Float32})
- @inline function _boundscheck_index_retaining_axes(r, s)
+ @@inlinefunction _boundscheck_index_retaining_axes(r, s)
- @inline function _cat_t(dims, ::Type{T}, X...) where {T}
+ @@inlinefunction _cat_t(dims, ??? :: Type{T}, X...) where T
- @inline function _checked_strides(stp::Tuple, els::Integer, elp::Integer)
+ @@inlinefunction _checked_strides(stp :: Tuple, els :: Integer, elp :: Integer)
- @inline function _cshp(ndim::Int, ::Tuple{}, shape, ::Tuple{})
+ @@inlinefunction _cshp(ndim :: Int, ??? :: Tuple, shape, ??? :: Tuple)
- @inline function _cshp(ndim::Int, ::Tuple{}, shape, nshape)
+ @@inlinefunction _cshp(ndim :: Int, ??? :: Tuple, shape, nshape)
- @inline function _cshp(ndim::Int, dims, shape, nshape)
+ @@inlinefunction _cshp(ndim :: Int, dims, shape, nshape)
- @inline function _eachslice(A::AbstractArray, dim::Integer, drop::Bool)
+ @@inlinefunction _eachslice(A :: AbstractArray, dim :: Integer, drop :: Bool)
- @inline function _foldoneto(op, acc, ::Val{N}) where N
+ @@inlinefunction _foldoneto(op, acc, ??? :: Val{N}) where N
- @inline function _fpint(x)
+ @@inlinefunction _fpint(x)
- @inline function _getindex(Q::AbstractQ, ::Colon, J::AbstractVector{<:Integer})
+ @@inlinefunction _getindex(Q :: AbstractQ, ??? :: Colon, J :: AbstractVector{??? <: Integer})
- @inline function _getindex(Q::AbstractQ, ::Colon, j::Int)
+ @@inlinefunction _getindex(Q :: AbstractQ, ??? :: Colon, j :: Int)
- @inline function _getindex(l::IndexStyle, A::AbstractArray, I::Union{Real, AbstractArray}...)
+ @@inlinefunction _getindex(l :: IndexStyle, A :: AbstractArray, I :: Union{Real, AbstractArray}...)
- @inline function _getindex(r, s::AbstractUnitRange)
+ @@inlinefunction _getindex(r, s :: AbstractUnitRange)
- @inline function _getindex(r, s::AbstractUnitRange{Bool})
+ @@inlinefunction _getindex(r, s :: AbstractUnitRange{Bool})
- @inline function _getindex(r, s::StepRange)
+ @@inlinefunction _getindex(r, s :: StepRange)
- @inline function _getindex(r, s::StepRange{Bool})
+ @@inlinefunction _getindex(r, s :: StepRange{Bool})
- @inline function _getindex_ptr(a::ReinterpretArray{T}, inds...) where {T}
+ @@inlinefunction _getindex_ptr(a :: ReinterpretArray{T}, inds...) where T
- @inline function _growbeg0!(b::Bits, nchunks::Int)
+ @@inlinefunction _growbeg0!(b :: Bits, nchunks :: Int)
- @inline function _growend0!(b::Bits, nchunks::Int)
+ @@inlinefunction _growend0!(b :: Bits, nchunks :: Int)
- @inline function _hypot(x::Float16, y::Float16)
+ @@inlinefunction _hypot(x :: Float16, y :: Float16)
- @inline function _hypot(x::Float32, y::Float32)
+ @@inlinefunction _hypot(x :: Float32, y :: Float32)
- @inline function _improve_cbrt(x::Float32, t::Float32)
+ @@inlinefunction _improve_cbrt(x :: Float32, t :: Float32)
- @inline function _improve_cbrt(x::Float64, t::Float64)
+ @@inlinefunction _improve_cbrt(x :: Float64, t :: Float64)
- @inline function _ind2sub_rs(ax, strds, ind)
+ @@inlinefunction _ind2sub_rs(ax, strds, ind)
- @inline function _indexedby(r::AbstractUnitRange{<:Integer}, ax::AbstractUnitRange)
+ @@inlinefunction _indexedby(r :: AbstractUnitRange{??? <: Integer}, ax :: AbstractUnitRange)
- @inline function _indicesmightoverlap(A::Tuple{AbstractArray, Vararg{Any}}, B::Tuple{AbstractArray, Vararg{Any}})
+ @@inlinefunction _indicesmightoverlap(A :: Tuple{AbstractArray, Vararg{Any}}, B :: Tuple{AbstractArray, Vararg{Any}})
- @inline function _indicesmightoverlap(A::Tuple{AbstractRange, Vararg{Any}}, B::Tuple{AbstractRange, Vararg{Any}})
+ @@inlinefunction _indicesmightoverlap(A :: Tuple{AbstractRange, Vararg{Any}}, B :: Tuple{AbstractRange, Vararg{Any}})
- @inline function _indicesmightoverlap(A::Tuple{AbstractUnitRange, Vararg{Any}}, B::Tuple{AbstractUnitRange, Vararg{Any}})
+ @@inlinefunction _indicesmightoverlap(A :: Tuple{AbstractUnitRange, Vararg{Any}}, B :: Tuple{AbstractUnitRange, Vararg{Any}})
- @inline function _isascii(code_units::AbstractVector{CU}, first, last) where {CU}
+ @@inlinefunction _isascii(code_units :: AbstractVector{CU}, first, last) where CU
- @inline function _isone_cachefriendly(A::AbstractMatrix, m::Int)
+ @@inlinefunction _isone_cachefriendly(A :: AbstractMatrix, m :: Int)
- @inline function _isone_triacheck(A::AbstractMatrix, m::Int)
+ @@inlinefunction _isone_triacheck(A :: AbstractMatrix, m :: Int)
- @inline function _istril(A::AbstractMatrix, k)
+ @@inlinefunction _istril(A :: AbstractMatrix, k)
- @inline function _istriu(A::AbstractMatrix, k)
+ @@inlinefunction _istriu(A :: AbstractMatrix, k)
- @inline function _isvalid_utf8_dfa(state::_UTF8DFAState, bytes::AbstractVector{UInt8}, first::Int = firstindex(bytes), last::Int = lastindex(bytes))
+ @@inlinefunction _isvalid_utf8_dfa(state :: _UTF8DFAState, bytes :: AbstractVector{UInt8}, first :: Int = firstindex(bytes), last :: Int = lastindex(bytes))
- @inline function _iterate(r::IdOffsetRange, i...)
+ @@inlinefunction _iterate(r :: IdOffsetRange, i...)
- @inline function _lift_svec_ref(def::Expr, compact::IncrementalCompact)
+ @@inlinefunction _lift_svec_ref(def :: Expr, compact :: IncrementalCompact)
- @inline function _log(x::Float32, base, func)
+ @@inlinefunction _log(x :: Float32, base, func)
- @inline function _log(x::Float64, base, func)
+ @@inlinefunction _log(x :: Float64, base, func)
- @inline function _lu_tridiag!(dl, d, du, du2, ipiv, pivot, check)
+ @@inlinefunction _lu_tridiag!(dl, d, du, du2, ipiv, pivot, check)
- @inline function _make_makeargs(args::Tuple, n::Int)
+ @@inlinefunction _make_makeargs(args :: Tuple, n :: Int)
- @inline function _make_makeargs1(bc::Broadcasted, n::Int)
+ @@inlinefunction _make_makeargs1(bc :: Broadcasted, n :: Int)
- @inline function _newindexer(indsA::Tuple)
+ @@inlinefunction _newindexer(indsA :: Tuple)
- @inline function _nextind_str(s, i::Int)
+ @@inlinefunction _nextind_str(s, i :: Int)
- @inline function _overflowind(i1, irest, size)
+ @@inlinefunction _overflowind(i1, irest, size)
- @inline function _pisdone(iters, states)
+ @@inlinefunction _pisdone(iters, states)
- @inline function _piterate(iter1, rest...)
+ @@inlinefunction _piterate(iter1, rest...)
- @inline function _piterate1(iters, states)
+ @@inlinefunction _piterate1(iters, states)
- @inline function _randn(rng::AbstractRNG, r::UInt64)
+ @@inlinefunction _randn(rng :: AbstractRNG, r :: UInt64)
- @inline function _real_sqrt(θ, μ)
+ @@inlinefunction _real_sqrt(θ, μ)
- @inline function _reinterpret(::Type{Out}, x::In) where {Out, In}
+ @@inlinefunction _reinterpret(??? :: Type{Out}, x :: In) where Out, In
- @inline function _reshape_uncolon(A, dims)
+ @@inlinefunction _reshape_uncolon(A, dims)
- @inline function _rmul_or_fill!(C::AbstractArray, beta::Number)
+ @@inlinefunction _rmul_or_fill!(C :: AbstractArray, beta :: Number)
- @inline function _setdiag!(data, f, diag, diag′ = nothing)
+ @@inlinefunction _setdiag!(data, f, diag, diag′ = nothing)
- @inline function _setindex_ptr!(a::ReinterpretArray{T}, v, inds...) where {T}
+ @@inlinefunction _setindex_ptr!(a :: ReinterpretArray{T}, v, inds...) where T
- @inline function _setint!(s::BitSet, idx::Int, b::Bool)
+ @@inlinefunction _setint!(s :: BitSet, idx :: Int, b :: Bool)
- @inline function _slice_index(s::Slices, c...)
+ @@inlinefunction _slice_index(s :: Slices, c...)
- @inline function _stack_size_check(x, ax1::Tuple)
+ @@inlinefunction _stack_size_check(x, ax1 :: Tuple)
- @inline function _thisind_str(s, i::Int)
+ @@inlinefunction _thisind_str(s, i :: Int)
- @inline function _unsafe_bitsetindex!(Bc::Array{UInt64}, x::Bool, i1::Int, i2::Int)
+ @@inlinefunction _unsafe_bitsetindex!(Bc :: Array{UInt64}, x :: Bool, i1 :: Int, i2 :: Int)
- @inline function _unsafe_getindex!(X::BitArray, B::BitArray, I0::Union{AbstractUnitRange{Int},Slice})
+ @@inlinefunction _unsafe_getindex!(X :: BitArray, B :: BitArray, I0 :: Union{AbstractUnitRange{Int}, Slice})
- @inline function _unsafe_getindex(A::ReshapedArray{T,N}, indices::Vararg{Int,N}) where {T,N}
+ @@inlinefunction _unsafe_getindex(A :: ReshapedArray{T, N}, indices :: Vararg{Int, N}) where T, N
- @inline function _unsafe_setindex!(A::ReshapedArray{T,N}, val, indices::Vararg{Int,N}) where {T,N}
+ @@inlinefunction _unsafe_setindex!(A :: ReshapedArray{T, N}, val, indices :: Vararg{Int, N}) where T, N
- @inline function _zip_any_isdone(is, ss)
+ @@inlinefunction _zip_any_isdone(is, ss)
- @inline function accept(l::Parser, f::Union{Function, Char})::Bool
+ @@inlinefunction accept(l :: Parser, f :: Union{Function, Char})
- @inline function accept_n(l::Parser, n, f::F)::Bool where {F}
+ @@inlinefunction accept_n(l :: Parser, n, f :: F) where F
- @inline function asin_kernel(t::Float32, x::Float32)
+ @@inlinefunction asin_kernel(t :: Float32, x :: Float32)
- @inline function asin_kernel(t::Float64, x::Float64)
+ @@inlinefunction asin_kernel(t :: Float64, x :: Float64)
- @inline function atan_pq(x)
+ @@inlinefunction atan_pq(x)
- @inline function basic_blocks_starts(stmts::Vector{Any})
+ @@inlinefunction basic_blocks_starts(stmts :: Vector{Any})
- @inline function big_dead_throw_catch()
+ @@inlinefunction big_dead_throw_catch
- @inline function broadcast_preserving_zero_d(f, As...)
+ @@inlinefunction broadcast_preserving_zero_d(f, As...)
- @inline function broadcasted(f::F, arg1, arg2, args...) where {F}
+ @@inlinefunction broadcasted(f :: F, arg1, arg2, args...) where F
- @inline function broadcasted(f::F, arg1, args...) where {F}
+ @@inlinefunction broadcasted(f :: F, arg1, args...) where F
- @inline function broadcasted(f::F, args...) where {F}
+ @@inlinefunction broadcasted(f :: F, args...) where F
- @inline function broadcasted_kwsyntax(f, args...; kwargs...)
+ @@inlinefunction broadcasted_kwsyntax(f, args..., kwargs...)
- @inline function cdiv(a::Float64, b::Float64, c::Float64, d::Float64)
+ @@inlinefunction cdiv(a :: Float64, b :: Float64, c :: Float64, d :: Float64)
- @inline function check_broadcast_axes(shp, A, As...)
+ @@inlinefunction check_broadcast_axes(shp, A, As...)
- @inline function check_valid_base(base)
+ @@inlinefunction check_valid_base(base)
- @inline function chunkedcopyto!(dest::BitArray, bc::Broadcasted)
+ @@inlinefunction chunkedcopyto!(dest :: BitArray, bc :: Broadcasted)
- @inline function close_current_timer()
+ @@inlinefunction close_current_timer
- @inline function cody_waite_2c_pio2(x::Float64, fn, n)
+ @@inlinefunction cody_waite_2c_pio2(x :: Float64, fn, n)
- @inline function cody_waite_ext_pio2(x::Float64, xhp)
+ @@inlinefunction cody_waite_ext_pio2(x :: Float64, xhp)
- @inline function computelen(substringranges, formats, args)
+ @@inlinefunction computelen(substringranges, formats, args)
- @inline function copy(bc::Broadcasted)
+ @@inlinefunction copy(bc :: Broadcasted)
- @inline function copy(bc::Broadcasted{Style{Tuple}})
+ @@inlinefunction copy(bc :: Broadcasted{Style{Tuple}})
- @inline function copyto!(dest::AbstractArray, bc::Broadcasted{<:AbstractArrayStyle{0}})
+ @@inlinefunction copyto!(dest :: AbstractArray, bc :: Broadcasted{??? <: AbstractArrayStyle{DependentType@2a84aee7}})
- @inline function copyto!(dest::AbstractArray, bc::Broadcasted{Nothing})
+ @@inlinefunction copyto!(dest :: AbstractArray, bc :: Broadcasted{Nothing})
- @inline function copyto!(dest::BitArray, bc::Broadcasted{Nothing})
+ @@inlinefunction copyto!(dest :: BitArray, bc :: Broadcasted{Nothing})
- @inline function copyto!(dest::BitVector, bc::Broadcasted{Nothing})
+ @@inlinefunction copyto!(dest :: BitVector, bc :: Broadcasted{Nothing})
- @inline function copytri!(A::AbstractMatrix, uplo::AbstractChar, conjugate::Bool=false, diag::Bool=false)
+ @@inlinefunction copytri!(A :: AbstractMatrix, uplo :: AbstractChar, conjugate :: Bool = false, diag :: Bool = false)
- @inline function cos_kernel(y::DoubleFloat32)
+ @@inlinefunction cos_kernel(y :: DoubleFloat32)
- @inline function cos_kernel(y::DoubleFloat64)
+ @@inlinefunction cos_kernel(y :: DoubleFloat64)
- @inline function cos_kernel(y::Float64)
+ @@inlinefunction cos_kernel(y :: Float64)
- @inline function cospi_kernel(x::Float16)
+ @@inlinefunction cospi_kernel(x :: Float16)
- @inline function cospi_kernel(x::Float32)
+ @@inlinefunction cospi_kernel(x :: Float32)
- @inline function cospi_kernel(x::Float64)
+ @@inlinefunction cospi_kernel(x :: Float64)
- @inline function cospi_kernel_wide(x::Float16)
+ @@inlinefunction cospi_kernel_wide(x :: Float16)
- @inline function cospi_kernel_wide(x::Float32)
+ @@inlinefunction cospi_kernel_wide(x :: Float32)
- @inline function cospi_kernel_wide(x::Float64)
+ @@inlinefunction cospi_kernel_wide(x :: Float64)
- @inline function dec(state, indices)
+ @@inlinefunction dec(state, indices)
- @inline function depth(node::Node, d)
+ @@inlinefunction depth(node :: Node, d)
- @inline function eachindex(::IndexCartesian, A::AbstractArray, B::AbstractArray...)
+ @@inlinefunction eachindex(??? :: IndexCartesian, A :: AbstractArray, B :: AbstractArray...)
- @inline function eachindex(style::IndexSCartesian2{K}, A::AbstractArray, B::AbstractArray...) where {K}
+ @@inlinefunction eachindex(style :: IndexSCartesian2{K}, A :: AbstractArray, B :: AbstractArray...) where K
- @inline function eachslice(A; dims, drop=true)
+ @@inlinefunction eachslice(A, dims, drop = true)
- @inline function eat_char(l::Parser)::Char
+ @@inlinefunction eat_char(l :: Parser)
- @inline function egal_condition(c::Const, @nospecialize(xt), max_union_splitting::Int)
+ @@inlinefunction egal_condition(c :: Const, xt, max_union_splitting :: Int)
- @inline function ensureroom(io::GenericIOBuffer, nshort::UInt)
+ @@inlinefunction ensureroom(io :: GenericIOBuffer, nshort :: UInt)
- @inline function enter_new_timer(frame)
+ @@inlinefunction enter_new_timer(frame)
- @inline function exit_current_timer(_expected_frame_)
+ @@inlinefunction exit_current_timer(_expected_frame_)
- @inline function exp2(x::Base.BitInteger)
+ @@inlinefunction exp2(x :: Base.BitInteger)
- @inline function exp_impl(a::Float16, base)
+ @@inlinefunction exp_impl(a :: Float16, base)
- @inline function exp_impl(x::Float32, base)
+ @@inlinefunction exp_impl(x :: Float32, base)
- @inline function exp_impl(x::Float64, base)
+ @@inlinefunction exp_impl(x :: Float64, base)
- @inline function exp_impl(x::Float64, xlo::Float64, base)
+ @@inlinefunction exp_impl(x :: Float64, xlo :: Float64, base)
- @inline function exp_impl_fast(x::Float32, base)
+ @@inlinefunction exp_impl_fast(x :: Float32, base)
- @inline function exp_impl_fast(x::Float64, base)
+ @@inlinefunction exp_impl_fast(x :: Float64, base)
- @inline function explicit_inline(args...)
+ @@inlinefunction explicit_inline(args...)
- @inline function expm1_small(x::Float32)
+ @@inlinefunction expm1_small(x :: Float32)
- @inline function expm1_small(x::Float64)
+ @@inlinefunction expm1_small(x :: Float64)
- @inline function f1(a)
+ @@inlinefunction f1(a)
- @inline function f_inlined(x)
+ @@inlinefunction f_inlined(x)
- @inline function f_line()
+ @@inlinefunction f_line
- @inline function fill_to_length(t::Tuple, val, ::Val{_N}) where {_N}
+ @@inlinefunction fill_to_length(t :: Tuple, val, ??? :: Val{_N}) where _N
- @inline function finalizer_sparam(d::DoAllocNoEscapeSparam{T}) where {T}
+ @@inlinefunction finalizer_sparam(d :: DoAllocNoEscapeSparam{T}) where T
- @inline function fmt(buf, pos, arg, spec::Spec{T}) where {T <: Chars}
+ @@inlinefunction fmt(buf, pos, arg, spec :: Spec{T}) where T <: Chars
- @inline function fmt(buf, pos, arg, spec::Spec{T}) where {T <: Floats}
+ @@inlinefunction fmt(buf, pos, arg, spec :: Spec{T}) where T <: Floats
- @inline function fmt(buf, pos, arg, spec::Spec{T}) where {T <: Ints}
+ @@inlinefunction fmt(buf, pos, arg, spec :: Spec{T}) where T <: Ints
- @inline function fmt(buf, pos, arg, spec::Spec{T}) where {T <: Strings}
+ @@inlinefunction fmt(buf, pos, arg, spec :: Spec{T}) where T <: Strings
- @inline function fmt(buf, pos, args, argp, spec::Spec{T}) where {T}
+ @@inlinefunction fmt(buf, pos, args, argp, spec :: Spec{T}) where T
- @inline function foo11904(x::Nullable11904{S}) where S
+ @@inlinefunction foo11904(x :: Nullable11904{S}) where S
- @inline function foo27240()
+ @@inlinefunction foo27240
- @inline function foo_inl(x)
+ @@inlinefunction foo_inl(x)
- @inline function format(buf::Vector{UInt8}, pos::Integer, f::Format, args...)
+ @@inlinefunction format(buf :: Vector{UInt8}, pos :: Integer, f :: Format, args...)
- @inline function format(io, d::AbstractDateToken, dt, locale)
+ @@inlinefunction format(io, d :: AbstractDateToken, dt, locale)
- @inline function format(io, d::DatePart{'y'}, dt)
+ @@inlinefunction format(io, d :: DatePart{'y'}, dt)
- @inline function format(io, d::Delim, dt, locale)
+ @@inlinefunction format(io, d :: Delim, dt, locale)
- @inline function func_nospecialized_inline(@nospecialize a)
+ @@inlinefunction func_nospecialized_inline(a)
- @inline function g1(a)
+ @@inlinefunction g1(a)
- @inline function get_cached_result(state::InliningState, mi::MethodInstance)
+ @@inlinefunction get_cached_result(state :: InliningState, mi :: MethodInstance)
- @inline function get_local_result(inf_result::InferenceResult)
+ @@inlinefunction get_local_result(inf_result :: InferenceResult)
- @inline function getindex(A::Bidiagonal{T}, i::Integer, j::Integer) where T
+ @@inlinefunction getindex(A :: Bidiagonal{T}, i :: Integer, j :: Integer) where T
- @inline function getindex(A::Hermitian, i::Integer, j::Integer)
+ @@inlinefunction getindex(A :: Hermitian, i :: Integer, j :: Integer)
- @inline function getindex(A::ReshapedArray, index::ReshapedIndex)
+ @@inlinefunction getindex(A :: ReshapedArray, index :: ReshapedIndex)
- @inline function getindex(A::ReshapedArrayLF, index::Int)
+ @@inlinefunction getindex(A :: ReshapedArrayLF, index :: Int)
- @inline function getindex(A::ReshapedArray{T,N}, indices::Vararg{Int,N}) where {T,N}
+ @@inlinefunction getindex(A :: ReshapedArray{T, N}, indices :: Vararg{Int, N}) where T, N
- @inline function getindex(A::SymTridiagonal{T}, i::Integer, j::Integer) where T
+ @@inlinefunction getindex(A :: SymTridiagonal{T}, i :: Integer, j :: Integer) where T
- @inline function getindex(A::Symmetric, i::Integer, j::Integer)
+ @@inlinefunction getindex(A :: Symmetric, i :: Integer, j :: Integer)
- @inline function getindex(A::Tridiagonal{T}, i::Integer, j::Integer) where T
+ @@inlinefunction getindex(A :: Tridiagonal{T}, i :: Integer, j :: Integer) where T
- @inline function getindex(B::BitArray, i::Int)
+ @@inlinefunction getindex(B :: BitArray, i :: Int)
- @inline function getindex(D::Diagonal, i::Int, j::Int)
+ @@inlinefunction getindex(D :: Diagonal, i :: Int, j :: Int)
- @inline function getindex(Q::AbstractQ, inds...)
+ @@inlinefunction getindex(Q :: AbstractQ, inds...)
- @inline function getindex(iter::SCartesianIndices2{K}, i::Int, j::Int) where {K}
+ @@inlinefunction getindex(iter :: SCartesianIndices2{K}, i :: Int, j :: Int) where K
- @inline function getindex(node::Instruction, fld::Symbol)
+ @@inlinefunction getindex(node :: Instruction, fld :: Symbol)
- @inline function getindex(s::Slices{P,SM,AX,S,N}, I::Vararg{Int,N}) where {P,SM,AX,S,N}
+ @@inlinefunction getindex(s :: Slices{P, SM, AX, S, N}, I :: Vararg{Int, N}) where P, SM, AX, S, N
- @inline function getindex(s::String, r::UnitRange{Int})
+ @@inlinefunction getindex(s :: String, r :: UnitRange{Int})
- @inline function getprop(F::NotQRSparse, d::Symbol)
+ @@inlinefunction getprop(F :: NotQRSparse, d :: Symbol)
- @inline function getproperty(F::GeneralizedSVD{T}, d::Symbol) where T
+ @@inlinefunction getproperty(F :: GeneralizedSVD{T}, d :: Symbol) where T
- @inline function getproperty(t::Task, field::Symbol)
+ @@inlinefunction getproperty(t :: Task, field :: Symbol)
- @inline function getstate(::TaskLocalRNG)
+ @@inlinefunction getstate(??? :: TaskLocalRNG)
- @inline function inc(state, indices)
+ @@inlinefunction inc(state, indices)
- @inline function index_dimsum(::AbstractArray{<:Any,N}, I...) where N
+ @@inlinefunction index_dimsum(??? :: AbstractArray{??? <: Any, N}, I...) where N
- @inline function index_ndims(i1::AbstractArray{CartesianIndex{N}}, I...) where N
+ @@inlinefunction index_ndims(i1 :: AbstractArray{CartesianIndex{N}}, I...) where N
- @inline function index_ndims(i1::CartesianIndex, I...)
+ @@inlinefunction index_ndims(i1 :: CartesianIndex, I...)
- @inline function initstate!(x::Union{TaskLocalRNG, Xoshiro}, state)
+ @@inlinefunction initstate!(x :: Union{TaskLocalRNG, Xoshiro}, state)
- @inline function inlined_usually(x, y, z)
+ @@inlinefunction inlined_usually(x, y, z)
- @inline function insert!(found, present, trie::HAMT{K,V}, i, bi, h, val) where {K,V}
+ @@inlinefunction insert!(found, present, trie :: HAMT{K, V}, i, bi, h, val) where K, V
- @inline function instantiate(bc::Broadcasted)
+ @@inlinefunction instantiate(bc :: Broadcasted)
- @inline function isa_condition(@nospecialize(xt), @nospecialize(ty), max_union_splitting::Int)
+ @@inlinefunction isa_condition(xt, ty, max_union_splitting :: Int)
- @inline function isassigned(A::ReshapedArrayLF, index::Int)
+ @@inlinefunction isassigned(A :: ReshapedArrayLF, index :: Int)
- @inline function isassigned(A::ReshapedArray{T,N}, indices::Vararg{Int, N}) where {T,N}
+ @@inlinefunction isassigned(A :: ReshapedArray{T, N}, indices :: Vararg{Int, N}) where T, N
- @inline function isless(a::T, b::T) where T<:IEEEFloat
+ @@inlinefunction isless(a :: T, b :: T) where T <: IEEEFloat
- @inline function iterate(L::LogicalIndex{<:Any,<:BitArray}, (i1, Bi, irest, c))
+ @@inlinefunction iterate(L :: LogicalIndex{??? <: Any, ??? <: BitArray}, (i1,Bi,irest,c))
- @inline function iterate(L::LogicalIndex{<:CartesianIndex,<:BitArray})
+ @@inlinefunction iterate(L :: LogicalIndex{??? <: CartesianIndex, ??? <: BitArray})
- @inline function iterate(L::LogicalIndex{<:CartesianIndex})
+ @@inlinefunction iterate(L :: LogicalIndex{??? <: CartesianIndex})
- @inline function iterate(L::LogicalIndex{Int,<:BitArray})
+ @@inlinefunction iterate(L :: LogicalIndex{Int, ??? <: BitArray})
- @inline function iterate(L::LogicalIndex{Int})
+ @@inlinefunction iterate(L :: LogicalIndex{Int})
- @inline function iterate(P::ProductIterator)
+ @@inlinefunction iterate(P :: ProductIterator)
- @inline function iterate(P::ProductIterator, states)
+ @@inlinefunction iterate(P :: ProductIterator, states)
- @inline function iterate(R::ReshapedArrayIterator, i...)
+ @@inlinefunction iterate(R :: ReshapedArrayIterator, i...)
- @inline function iterate(compact::IncrementalCompact, state=nothing)
+ @@inlinefunction iterate(compact :: IncrementalCompact, state = nothing)
- @inline function iterate(it::UseRefIterator, op::Int=0)
+ @@inlinefunction iterate(it :: UseRefIterator, op :: Int = 0)
- @inline function iterate(iter::CartesianIndices)
+ @@inlinefunction iterate(iter :: CartesianIndices)
- @inline function iterate(iter::CartesianIndices, state)
+ @@inlinefunction iterate(iter :: CartesianIndices, state)
- @inline function iterate(iter::CartesianPartition)
+ @@inlinefunction iterate(iter :: CartesianPartition)
- @inline function iterate(iter::CartesianPartition, (state, n))
+ @@inlinefunction iterate(iter :: CartesianPartition, (state,n))
- @inline function iterate(r::Reverse{<:CartesianIndices})
+ @@inlinefunction iterate(r :: Reverse{??? <: CartesianIndices})
- @inline function iterate(r::Reverse{<:CartesianIndices}, state)
+ @@inlinefunction iterate(r :: Reverse{??? <: CartesianIndices}, state)
- @inline function iterate(r::Reverse{<:Enumerate})
+ @@inlinefunction iterate(r :: Reverse{??? <: Enumerate})
- @inline function iterate(r::Reverse{<:Enumerate}, state)
+ @@inlinefunction iterate(r :: Reverse{??? <: Enumerate}, state)
- @inline function iterate(s::String, i::Int=firstindex(s))
+ @@inlinefunction iterate(s :: String, i :: Int = firstindex(s))
- @inline function kron!(C::AbstractMatrix, A::AbstractMatrix, B::Diagonal)
+ @@inlinefunction kron!(C :: AbstractMatrix, A :: AbstractMatrix, B :: Diagonal)
- @inline function kron!(C::AbstractMatrix, A::Diagonal, B::AbstractMatrix)
+ @@inlinefunction kron!(C :: AbstractMatrix, A :: Diagonal, B :: AbstractMatrix)
- @inline function kron!(C::AbstractMatrix, A::Diagonal, B::Diagonal)
+ @@inlinefunction kron!(C :: AbstractMatrix, A :: Diagonal, B :: Diagonal)
- @inline function kron!(R::BitVector, a::BitVector, b::BitVector)
+ @@inlinefunction kron!(R :: BitVector, a :: BitVector, b :: BitVector)
- @inline function literal_pow(f::typeof(^), x, ::Val{p}) where {p}
+ @@inlinefunction literal_pow(f :: typeof(^), x, ??? :: Val{p}) where p
- @inline function lmul!(G::Givens, A::AbstractVecOrMat)
+ @@inlinefunction lmul!(G :: Givens, A :: AbstractVecOrMat)
- @inline function lock(rl::ReentrantLock)
+ @@inlinefunction lock(rl :: ReentrantLock)
- @inline function log_proc2(f::Float32,base=Val(:ℯ))
+ @@inlinefunction log_proc2(f :: Float32, base = Val(:ℯ))
- @inline function log_proc2(f::Float64,base=Val(:ℯ))
+ @@inlinefunction log_proc2(f :: Float64, base = Val(:ℯ))
- @inline function log_tab_unpack(t::UInt64)
+ @@inlinefunction log_tab_unpack(t :: UInt64)
- @inline function longdef(x)
+ @@inlinefunction longdef(x)
- @inline function materialize!(::BroadcastStyle, dest, bc::Broadcasted{<:Any})
+ @@inlinefunction materialize!(??? :: BroadcastStyle, dest, bc :: Broadcasted{??? <: Any})
- @inline function materialize!(dest, bc::Broadcasted{<:Any})
+ @@inlinefunction materialize!(dest, bc :: Broadcasted{??? <: Any})
- @inline function materialize!(dest, x)
+ @@inlinefunction materialize!(dest, x)
- @inline function mul!(C, A, B)
+ @@inlinefunction mul!(C, A, B)
- @inline function mul!(C::AbstractArray, X::AbstractArray, s::Number, alpha::Number, beta::Number)
+ @@inlinefunction mul!(C :: AbstractArray, X :: AbstractArray, s :: Number, alpha :: Number, beta :: Number)
- @inline function mul!(C::AbstractArray, s::Number, X::AbstractArray, alpha::Number, beta::Number)
+ @@inlinefunction mul!(C :: AbstractArray, s :: Number, X :: AbstractArray, alpha :: Number, beta :: Number)
- @inline function my_ntuple(f::F, ::Val{N}) where {F,N}
+ @@inlinefunction my_ntuple(f :: F, ??? :: Val{N}) where F, N
- @inline function new(x)
+ @@inlinefunction new(x)
- @inline function next_char(l::Parser)::Char
+ @@inlinefunction next_char(l :: Parser)
- @inline function norm(x::Number, p::Real=2)
+ @@inlinefunction norm(x :: Number, p :: Real = 2)
- @inline function ntuple(f::F, ::Val{N}) where {F,N}
+ @@inlinefunction ntuple(f :: F, ??? :: Val{N}) where F, N
- @inline function ntuple(f::F, n::Integer) where F
+ @@inlinefunction ntuple(f :: F, n :: Integer) where F
- @inline function number_from_hex(c::UInt8)
+ @@inlinefunction number_from_hex(c :: UInt8)
- @inline function overdub(c::Ctx, f::Union{Core.Builtin, Core.IntrinsicFunction}, args...)
+ @@inlinefunction overdub(c :: Ctx, f :: Union{Core.Builtin, Core.IntrinsicFunction}, args...)
- @inline function path(trie::HAMT{K,V}, key, _h, copy=false) where {K, V}
+ @@inlinefunction path(trie :: HAMT{K, V}, key, _h, copy = false) where K, V
- @inline function peek(s::Stateful, sentinel=nothing)
+ @@inlinefunction peek(s :: Stateful, sentinel = nothing)
- @inline function plength(f::Spec{T}, args, argp) where {T}
+ @@inlinefunction plength(f :: Spec{T}, args, argp) where T
- @inline function pop!(s::BitSet, n::Integer)
+ @@inlinefunction pop!(s :: BitSet, n :: Integer)
- @inline function pop!(s::BitSet, n::Integer, default)
+ @@inlinefunction pop!(s :: BitSet, n :: Integer, default)
- @inline function popfirst!(s::Stateful)
+ @@inlinefunction popfirst!(s :: Stateful)
- @inline function pow_body(x::T, y::T) where T <: Union{Float16, Float32}
+ @@inlinefunction pow_body(x :: T, y :: T) where T <: Union{Float16, Float32}
- @inline function pow_body(xu::UInt64, y::Float64)
+ @@inlinefunction pow_body(xu :: UInt64, y :: Float64)
- @inline function propagate_alias_change!(estate::EscapeState, change::AliasChange)
+ @@inlinefunction propagate_alias_change!(estate :: EscapeState, change :: AliasChange)
- @inline function propagate_liveness_change!(estate::EscapeState, change::LivenessChange)
+ @@inlinefunction propagate_liveness_change!(estate :: EscapeState, change :: LivenessChange)
- @inline function rand(rng::Union{TaskLocalRNG, Xoshiro}, ::SamplerType{UInt128})
+ @@inlinefunction rand(rng :: Union{TaskLocalRNG, Xoshiro}, ??? :: SamplerType{UInt128})
- @inline function rand(x::Union{TaskLocalRNG, Xoshiro}, ::SamplerType{UInt64})
+ @@inlinefunction rand(x :: Union{TaskLocalRNG, Xoshiro}, ??? :: SamplerType{UInt64})
- @inline function randn(rng::AbstractRNG=default_rng())
+ @@inlinefunction randn(rng :: AbstractRNG = default_rng())
- @inline function read(from::GenericIOBuffer, ::Type{UInt8})
+ @@inlinefunction read(from :: GenericIOBuffer, ??? :: Type{UInt8})
- @inline function reduce_shortest(f::T, maxsignif=nothing) where {T}
+ @@inlinefunction reduce_shortest(f :: T, maxsignif = nothing) where T
- @inline function reflector!(x::AbstractVector{T}) where {T}
+ @@inlinefunction reflector!(x :: AbstractVector{T}) where T
- @inline function reflectorApply!(x::AbstractVector, τ::Number, A::AbstractVecOrMat)
+ @@inlinefunction reflectorApply!(x :: AbstractVector, τ :: Number, A :: AbstractVecOrMat)
- @inline function rem_pio2_kernel(x::Float32)
+ @@inlinefunction rem_pio2_kernel(x :: Float32)
- @inline function rem_pio2_kernel(x::Float64)
+ @@inlinefunction rem_pio2_kernel(x :: Float64)
- @inline function rmdynamic(spec::Spec{T}, args, argp) where {T}
+ @@inlinefunction rmdynamic(spec :: Spec{T}, args, argp) where T
- @inline function rmul!(A::AbstractMatrix, G::Givens)
+ @@inlinefunction rmul!(A :: AbstractMatrix, G :: Givens)
- @inline function robust_cdiv1(a::Float64, b::Float64, c::Float64, d::Float64)
+ @@inlinefunction robust_cdiv1(a :: Float64, b :: Float64, c :: Float64, d :: Float64)
- @inline function selectpivot!(v::AbstractVector, lo::Integer, hi::Integer, o::Ordering)
+ @@inlinefunction selectpivot!(v :: AbstractVector, lo :: Integer, hi :: Integer, o :: Ordering)
- @inline function setindex!(A::Bidiagonal, x, i::Integer, j::Integer)
+ @@inlinefunction setindex!(A :: Bidiagonal, x, i :: Integer, j :: Integer)
- @inline function setindex!(A::ReshapedArray, val, index::ReshapedIndex)
+ @@inlinefunction setindex!(A :: ReshapedArray, val, index :: ReshapedIndex)
- @inline function setindex!(A::ReshapedArrayLF, val, index::Int)
+ @@inlinefunction setindex!(A :: ReshapedArrayLF, val, index :: Int)
- @inline function setindex!(A::ReshapedArray{T,N}, val, indices::Vararg{Int,N}) where {T,N}
+ @@inlinefunction setindex!(A :: ReshapedArray{T, N}, val, indices :: Vararg{Int, N}) where T, N
- @inline function setindex!(A::SymTridiagonal, x, i::Integer, j::Integer)
+ @@inlinefunction setindex!(A :: SymTridiagonal, x, i :: Integer, j :: Integer)
- @inline function setindex!(A::Tridiagonal, x, i::Integer, j::Integer)
+ @@inlinefunction setindex!(A :: Tridiagonal, x, i :: Integer, j :: Integer)
- @inline function setindex!(B::BitArray, X::AbstractArray, I::BitArray)
+ @@inlinefunction setindex!(B :: BitArray, X :: AbstractArray, I :: BitArray)
- @inline function setindex!(B::BitArray, X::Union{StridedArray,BitArray}, J0::Union{Colon,AbstractUnitRange{Int}})
+ @@inlinefunction setindex!(B :: BitArray, X :: Union{StridedArray, BitArray}, J0 :: Union{Colon, AbstractUnitRange{Int}})
- @inline function setindex!(B::BitArray, x, i::Int)
+ @@inlinefunction setindex!(B :: BitArray, x, i :: Int)
- @inline function setindex!(node::Instruction, @nospecialize(val), fld::Symbol)
+ @@inlinefunction setindex!(node :: Instruction, val, fld :: Symbol)
- @inline function setindex!(s::Slices{P,SM,AX,S,N}, val, I::Vararg{Int,N}) where {P,SM,AX,S,N}
+ @@inlinefunction setindex!(s :: Slices{P, SM, AX, S, N}, val, I :: Vararg{Int, N}) where P, SM, AX, S, N
- @inline function setindex!(x::UseRef, @nospecialize(v))
+ @@inlinefunction setindex!(x :: UseRef, v)
- @inline function setstate!(x::TaskLocalRNG, (s0, s1, s2, s3, s4))
+ @@inlinefunction setstate!(x :: TaskLocalRNG, (s0,s1,s2,s3,s4))
- @inline function setstate!(x::Xoshiro, (s0, s1, s2, s3, s4))
+ @@inlinefunction setstate!(x :: Xoshiro, (s0,s1,s2,s3,s4))
- @inline function simd_outer_range(iter::CartesianPartition)
+ @@inlinefunction simd_outer_range(iter :: CartesianPartition)
- @inline function simd_outer_range(iter::CartesianPartition{CartesianIndex{2}})
+ @@inlinefunction simd_outer_range(iter :: CartesianPartition{CartesianIndex{DependentType@a09ee92}})
- @inline function sin_kernel(y::DoubleFloat32)
+ @@inlinefunction sin_kernel(y :: DoubleFloat32)
- @inline function sin_kernel(y::DoubleFloat64)
+ @@inlinefunction sin_kernel(y :: DoubleFloat64)
- @inline function sin_kernel(y::Float64)
+ @@inlinefunction sin_kernel(y :: Float64)
- @inline function sincos_fast(v::Float16)
+ @@inlinefunction sincos_fast(v :: Float16)
- @inline function sinh16_kernel(x::Float32)
+ @@inlinefunction sinh16_kernel(x :: Float32)
- @inline function sinpi_kernel(x::Float16)
+ @@inlinefunction sinpi_kernel(x :: Float16)
- @inline function sinpi_kernel(x::Float32)
+ @@inlinefunction sinpi_kernel(x :: Float32)
- @inline function sinpi_kernel(x::Float64)
+ @@inlinefunction sinpi_kernel(x :: Float64)
- @inline function sinpi_kernel_wide(x::Float16)
+ @@inlinefunction sinpi_kernel_wide(x :: Float16)
- @inline function sinpi_kernel_wide(x::Float32)
+ @@inlinefunction sinpi_kernel_wide(x :: Float32)
- @inline function sinpi_kernel_wide(x::Float64)
+ @@inlinefunction sinpi_kernel_wide(x :: Float64)
- @inline function size(B::BitVector, d::Integer)
+ @@inlinefunction size(B :: BitVector, d :: Integer)
- @inline function slot_id(s)
+ @@inlinefunction slot_id(s)
- @inline function specialize_method(method::Method, @nospecialize(atype), sparams::SimpleVector; preexisting::Bool=false)
+ @@inlinefunction specialize_method(method :: Method, atype, sparams :: SimpleVector, preexisting :: Bool = false)
- @inline function split(I::CartesianIndex, V::Val)
+ @@inlinefunction split(I :: CartesianIndex, V :: Val)
- @inline function split(t, V::Val)
+ @@inlinefunction split(t, V :: Val)
- @inline function splitbits(x::Float64)
+ @@inlinefunction splitbits(x :: Float64)
- @inline function sqrt(x::Union{Float32,Float64})
+ @@inlinefunction sqrt(x :: Union{Float32, Float64})
- @inline function tan_kernel(y::DoubleFloat32, k)
+ @@inlinefunction tan_kernel(y :: DoubleFloat32, k)
- @inline function tan_kernel(y::DoubleFloat64, k)
+ @@inlinefunction tan_kernel(y :: DoubleFloat64, k)
- @inline function tanh_kernel(x::Float32)
+ @@inlinefunction tanh_kernel(x :: Float32)
- @inline function tanh_kernel(x::Float64)
+ @@inlinefunction tanh_kernel(x :: Float64)
- @inline function test_inner(count)
+ @@inlinefunction test_inner(count)
- @inline function tmerge_fast_path(lattice::AbstractLattice, @nospecialize(typea), @nospecialize(typeb))
+ @@inlinefunction tmerge_fast_path(lattice :: AbstractLattice, typea, typeb)
- @inline function truncbits(x::Float64)
+ @@inlinefunction truncbits(x :: Float64)
- @inline function trylock(rl::ReentrantLock)
+ @@inlinefunction trylock(rl :: ReentrantLock)
- @inline function tryparsenext(d::AbstractDateToken, str, i, len, locale)
+ @@inlinefunction tryparsenext(d :: AbstractDateToken, str, i, len, locale)
- @inline function tryparsenext(d::DatePart{'s'}, str, i, len)
+ @@inlinefunction tryparsenext(d :: DatePart{'s'}, str, i, len)
- @inline function tryparsenext(d::Delim{<:AbstractChar, N}, str, i::Int, len) where N
+ @@inlinefunction tryparsenext(d :: Delim{??? <: AbstractChar, N}, str, i :: Int, len) where N
- @inline function tryparsenext(d::Delim{String, N}, str, i::Int, len) where N
+ @@inlinefunction tryparsenext(d :: Delim{String, N}, str, i :: Int, len) where N
- @inline function tryparsenext_base10(str::AbstractString, i::Int, len::Int, min_width::Int=1, max_width::Int=0)
+ @@inlinefunction tryparsenext_base10(str :: AbstractString, i :: Int, len :: Int, min_width :: Int = 1, max_width :: Int = 0)
- @inline function tryparsenext_word(str::AbstractString, i, len, locale, maxchars=0)
+ @@inlinefunction tryparsenext_word(str :: AbstractString, i, len, locale, maxchars = 0)
- @inline function unique_from(itr, out::Vector{T}, seen, i) where T
+ @@inlinefunction unique_from(itr, out :: Vector{T}, seen, i) where T
- @inline function unlock(rl::ReentrantLock)
+ @@inlinefunction unlock(rl :: ReentrantLock)
- @inline function unsafe_bitgetindex(Bc::Vector{UInt64}, i::Int)
+ @@inlinefunction unsafe_bitgetindex(Bc :: Vector{UInt64}, i :: Int)
- @inline function unsafe_bitsetindex!(Bc::Array{UInt64}, x::Bool, i::Int)
+ @@inlinefunction unsafe_bitsetindex!(Bc :: Array{UInt64}, x :: Bool, i :: Int)
- @inline function update23685!(::Node23685{T}) where T
+ @@inlinefunction update23685!(??? :: Node23685{T}) where T
- @inline function uuid_kernel(s, i, u)
+ @@inlinefunction uuid_kernel(s, i, u)
- @inline function vec_pointer_stride(x::AbstractArray, stride0check = nothing)
+ @@inlinefunction vec_pointer_stride(x :: AbstractArray, stride0check = nothing)
- @inline function write(to::GenericIOBuffer, a::UInt8)
+ @@inlinefunction write(to :: GenericIOBuffer, a :: UInt8)
- @inline function writechar(buf, pos, c)
+ @@inlinefunction writechar(buf, pos, c)
- @inline function xoshiro_bulk(rng::Union{TaskLocalRNG, Xoshiro}, dst::Ptr{UInt8}, len::Int, T::Union{Type{UInt8}, Type{Bool}, Type{Float32}, Type{Float64}}, ::Val{N}, f::F = _id) where {N, F}
+ @@inlinefunction xoshiro_bulk(rng :: Union{TaskLocalRNG, Xoshiro}, dst :: Ptr{UInt8}, len :: Int, T :: Union{Type{UInt8}, Type{Bool}, Type{Float32}, Type{Float64}}, ??? :: Val{N}, f :: F = _id) where N, F
- @nospecializeinfer function assert_nested_slotwrapper(@nospecialize t)
+ @@nospecializeinferfunction assert_nested_slotwrapper(t)
- @nospecializeinfer function bool_rt_to_conditional(@nospecialize(rt), info::BestguessInfo)
+ @@nospecializeinferfunction bool_rt_to_conditional(rt, info :: BestguessInfo)
- @nospecializeinfer function bool_rt_to_conditional(@nospecialize(rt), slot_id::Int, info::BestguessInfo)
+ @@nospecializeinferfunction bool_rt_to_conditional(rt, slot_id :: Int, info :: BestguessInfo)
- @nospecializeinfer function form_mustalias_conditional(alias::MustAlias, @nospecialize(thentype), @nospecialize(elsetype))
+ @@nospecializeinferfunction form_mustalias_conditional(alias :: MustAlias, thentype, elsetype)
- @nospecializeinfer function has_nontrivial_extended_info(L::ConstsLattice, @nospecialize t)
+ @@nospecializeinferfunction has_nontrivial_extended_info(L :: ConstsLattice, t)
- @nospecializeinfer function has_nontrivial_extended_info(L::PartialsLattice, @nospecialize t)
+ @@nospecializeinferfunction has_nontrivial_extended_info(L :: PartialsLattice, t)
- @nospecializeinfer function is_const_prop_profitable_arg(L::ConstsLattice, @nospecialize t)
+ @@nospecializeinferfunction is_const_prop_profitable_arg(L :: ConstsLattice, t)
- @nospecializeinfer function is_const_prop_profitable_arg(L::PartialsLattice, @nospecialize t)
+ @@nospecializeinferfunction is_const_prop_profitable_arg(L :: PartialsLattice, t)
- @nospecializeinfer function is_forwardable_argtype(L::ConditionalsLattice, @nospecialize x)
+ @@nospecializeinferfunction is_forwardable_argtype(L :: ConditionalsLattice, x)
- @nospecializeinfer function is_forwardable_argtype(L::ConstsLattice, @nospecialize x)
+ @@nospecializeinferfunction is_forwardable_argtype(L :: ConstsLattice, x)
- @nospecializeinfer function is_forwardable_argtype(L::PartialsLattice, @nospecialize x)
+ @@nospecializeinferfunction is_forwardable_argtype(L :: PartialsLattice, x)
- @nospecializeinfer function is_lattice_equal(lattice::AnyConditionalsLattice, @nospecialize(a), @nospecialize(b))
+ @@nospecializeinferfunction is_lattice_equal(lattice :: AnyConditionalsLattice, a, b)
- @nospecializeinfer function is_lattice_equal(lattice::ConstsLattice, @nospecialize(a), @nospecialize(b))
+ @@nospecializeinferfunction is_lattice_equal(lattice :: ConstsLattice, a, b)
- @nospecializeinfer function is_lattice_equal(lattice::InferenceLattice, @nospecialize(a), @nospecialize(b))
+ @@nospecializeinferfunction is_lattice_equal(lattice :: InferenceLattice, a, b)
- @nospecializeinfer function is_lattice_equal(lattice::PartialsLattice, @nospecialize(a), @nospecialize(b))
+ @@nospecializeinferfunction is_lattice_equal(lattice :: PartialsLattice, a, b)
- @nospecializeinfer function is_lattice_equal(L::AbstractLattice, @nospecialize(a), @nospecialize(b))
+ @@nospecializeinferfunction is_lattice_equal(L :: AbstractLattice, a, b)
- @nospecializeinfer function isalreadyconst(@nospecialize t)
+ @@nospecializeinferfunction isalreadyconst(t)
- @nospecializeinfer function issimplertype(L::AbstractLattice, @nospecialize(typea), @nospecialize(typeb))
+ @@nospecializeinferfunction issimplertype(L :: AbstractLattice, typea, typeb)
- @nospecializeinfer function issubconditional(lattice::AbstractLattice, a::C, b::C) where {C<:AnyConditional}
+ @@nospecializeinferfunction issubconditional(lattice :: AbstractLattice, a :: C, b :: C) where C <: AnyConditional
- @nospecializeinfer function maybe_const_fldidx(@nospecialize(objtyp), @nospecialize(fldval))
+ @@nospecializeinferfunction maybe_const_fldidx(objtyp, fldval)
- @nospecializeinfer function maybe_singleton_const(@nospecialize(t))
+ @@nospecializeinferfunction maybe_singleton_const(t)
- @nospecializeinfer function singleton_type(@nospecialize(ft))
+ @@nospecializeinferfunction singleton_type(ft)
- @nospecializeinfer function tmeet(lattice::ConditionalsLattice, @nospecialize(v), @nospecialize(t::Type))
+ @@nospecializeinferfunction tmeet(lattice :: ConditionalsLattice, v, t :: Type)
- @nospecializeinfer function tmeet(lattice::ConstsLattice, @nospecialize(v), @nospecialize(t::Type))
+ @@nospecializeinferfunction tmeet(lattice :: ConstsLattice, v, t :: Type)
- @nospecializeinfer function tmeet(lattice::InferenceLattice, @nospecialize(v), @nospecialize(t::Type))
+ @@nospecializeinferfunction tmeet(lattice :: InferenceLattice, v, t :: Type)
- @nospecializeinfer function tmeet(lattice::InterConditionalsLattice, @nospecialize(v), @nospecialize(t::Type))
+ @@nospecializeinferfunction tmeet(lattice :: InterConditionalsLattice, v, t :: Type)
- @nospecializeinfer function tmeet(lattice::PartialsLattice, @nospecialize(v), @nospecialize(t::Type))
+ @@nospecializeinferfunction tmeet(lattice :: PartialsLattice, v, t :: Type)
- @nospecializeinfer function tmeet(L::InterMustAliasesLattice, @nospecialize(v), @nospecialize(t::Type))
+ @@nospecializeinferfunction tmeet(L :: InterMustAliasesLattice, v, t :: Type)
- @nospecializeinfer function tmeet(L::MustAliasesLattice, @nospecialize(v), @nospecialize(t::Type))
+ @@nospecializeinferfunction tmeet(L :: MustAliasesLattice, v, t :: Type)
- @nospecializeinfer function tmerge(lattice::ConditionalsLattice, @nospecialize(typea), @nospecialize(typeb))
+ @@nospecializeinferfunction tmerge(lattice :: ConditionalsLattice, typea, typeb)
- @nospecializeinfer function tmerge(lattice::ConstsLattice, @nospecialize(typea), @nospecialize(typeb))
+ @@nospecializeinferfunction tmerge(lattice :: ConstsLattice, typea, typeb)
- @nospecializeinfer function tmerge(lattice::InferenceLattice, @nospecialize(typea), @nospecialize(typeb))
+ @@nospecializeinferfunction tmerge(lattice :: InferenceLattice, typea, typeb)
- @nospecializeinfer function tmerge(lattice::InterConditionalsLattice, @nospecialize(typea), @nospecialize(typeb))
+ @@nospecializeinferfunction tmerge(lattice :: InterConditionalsLattice, typea, typeb)
- @nospecializeinfer function tmerge(lattice::JLTypeLattice, @nospecialize(typea::Type), @nospecialize(typeb::Type))
+ @@nospecializeinferfunction tmerge(lattice :: JLTypeLattice, typea :: Type, typeb :: Type)
- @nospecializeinfer function tmerge(lattice::PartialsLattice, @nospecialize(typea), @nospecialize(typeb))
+ @@nospecializeinferfunction tmerge(lattice :: PartialsLattice, typea, typeb)
- @nospecializeinfer function tmerge(L::AnyMustAliasesLattice, @nospecialize(typea), @nospecialize(typeb))
+ @@nospecializeinferfunction tmerge(L :: AnyMustAliasesLattice, typea, typeb)
- @nospecializeinfer function tmerge_limited(lattice::InferenceLattice, @nospecialize(typea), @nospecialize(typeb))
+ @@nospecializeinferfunction tmerge_limited(lattice :: InferenceLattice, typea, typeb)
- @nospecializeinfer function tmerge_partial_struct(lattice::PartialsLattice, @nospecialize(typea), @nospecialize(typeb))
+ @@nospecializeinferfunction tmerge_partial_struct(lattice :: PartialsLattice, typea, typeb)
- @nospecializeinfer function tmerge_types_slow(@nospecialize(typea::Type), @nospecialize(typeb::Type))
+ @@nospecializeinferfunction tmerge_types_slow(typea :: Type, typeb :: Type)
- @nospecializeinfer function tname_intersect(aname::Core.TypeName, bname::Core.TypeName)
+ @@nospecializeinferfunction tname_intersect(aname :: Core.TypeName, bname :: Core.TypeName)
- @nospecializeinfer function widenconditional(@nospecialize typ)
+ @@nospecializeinferfunction widenconditional(typ)
- @nospecializeinfer function widenmustalias(@nospecialize typ)
+ @@nospecializeinferfunction widenmustalias(typ)
- @nospecializeinfer function widenreturn(::ConstsLattice, @nospecialize(rt), ::BestguessInfo)
+ @@nospecializeinferfunction widenreturn(??? :: ConstsLattice, rt, ??? :: BestguessInfo)
- @nospecializeinfer function widenreturn(::JLTypeLattice, @nospecialize(rt), ::BestguessInfo)
+ @@nospecializeinferfunction widenreturn(??? :: JLTypeLattice, rt, ??? :: BestguessInfo)
- @nospecializeinfer function widenreturn(@nospecialize(rt), info::BestguessInfo)
+ @@nospecializeinferfunction widenreturn(rt, info :: BestguessInfo)
- @nospecializeinfer function widenreturn(Lᵢ::AbstractLattice, @nospecialize(rt), info::BestguessInfo)
+ @@nospecializeinferfunction widenreturn(Lᵢ :: AbstractLattice, rt, info :: BestguessInfo)
- @nospecializeinfer function widenreturn(Lᵢ::ConditionalsLattice, @nospecialize(rt), info::BestguessInfo)
+ @@nospecializeinferfunction widenreturn(Lᵢ :: ConditionalsLattice, rt, info :: BestguessInfo)
- @nospecializeinfer function widenreturn(Lᵢ::MustAliasesLattice, @nospecialize(rt), info::BestguessInfo)
+ @@nospecializeinferfunction widenreturn(Lᵢ :: MustAliasesLattice, rt, info :: BestguessInfo)
- @nospecializeinfer function widenreturn(Lᵢ::PartialsLattice, @nospecialize(rt), info::BestguessInfo)
+ @@nospecializeinferfunction widenreturn(Lᵢ :: PartialsLattice, rt, info :: BestguessInfo)
- @nospecializeinfer function widenreturn_consts(@nospecialize(rt))
+ @@nospecializeinferfunction widenreturn_consts(rt)
- @nospecializeinfer function widenreturn_noslotwrapper(::ConstsLattice, @nospecialize(rt), ::BestguessInfo)
+ @@nospecializeinferfunction widenreturn_noslotwrapper(??? :: ConstsLattice, rt, ??? :: BestguessInfo)
- @nospecializeinfer function widenreturn_noslotwrapper(::JLTypeLattice, @nospecialize(rt), ::BestguessInfo)
+ @@nospecializeinferfunction widenreturn_noslotwrapper(??? :: JLTypeLattice, rt, ??? :: BestguessInfo)
- @nospecializeinfer function widenreturn_noslotwrapper(Lᵢ::AbstractLattice, @nospecialize(rt), info::BestguessInfo)
+ @@nospecializeinferfunction widenreturn_noslotwrapper(Lᵢ :: AbstractLattice, rt, info :: BestguessInfo)
- @nospecializeinfer function widenreturn_noslotwrapper(Lᵢ::PartialsLattice, @nospecialize(rt), info::BestguessInfo)
+ @@nospecializeinferfunction widenreturn_noslotwrapper(Lᵢ :: PartialsLattice, rt, info :: BestguessInfo)
- @nospecializeinfer function widenreturn_partials(Lᵢ::PartialsLattice, @nospecialize(rt), info::BestguessInfo)
+ @@nospecializeinferfunction widenreturn_partials(Lᵢ :: PartialsLattice, rt, info :: BestguessInfo)
- @nospecializeinfer function widenslotwrapper(@nospecialize typ)
+ @@nospecializeinferfunction widenslotwrapper(typ)
- @nospecializeinfer function widenwrappedconditional(@nospecialize typ)
+ @@nospecializeinferfunction widenwrappedconditional(typ)
- @nospecializeinfer function widenwrappedslotwrapper(@nospecialize typ)
+ @@nospecializeinferfunction widenwrappedslotwrapper(typ)
- @nospecializeinfer function leq(lattice::AnyConditionalsLattice, @nospecialize(a), @nospecialize(b))
+ @@nospecializeinferfunction leq(lattice :: AnyConditionalsLattice, a, b)
- @nospecializeinfer function leq(lattice::ConstsLattice, @nospecialize(a), @nospecialize(b))
+ @@nospecializeinferfunction leq(lattice :: ConstsLattice, a, b)
- @nospecializeinfer function leq(lattice::InferenceLattice, @nospecialize(a), @nospecialize(b))
+ @@nospecializeinferfunction leq(lattice :: InferenceLattice, a, b)
- @nospecializeinfer function leq(lattice::PartialsLattice, @nospecialize(a), @nospecialize(b))
+ @@nospecializeinferfunction leq(lattice :: PartialsLattice, a, b)
- @nospecializeinfer function leq(L::AnyMustAliasesLattice, @nospecialize(a), @nospecialize(b))
+ @@nospecializeinferfunction leq(L :: AnyMustAliasesLattice, a, b)
- @nospecs function _builtin_nothrow(L::AbstractLattice, f, argtypes::Vector{Any}, rt)
+ @@nospecsfunction _builtin_nothrow(L :: AbstractLattice, f, argtypes :: Vector{Any}, rt)
- @nospecs function _fieldtype_tfunc(L::AbstractLattice, s, name, exact::Bool)
+ @@nospecsfunction _fieldtype_tfunc(L :: AbstractLattice, s, name, exact :: Bool)
- @nospecs function _getfield_tfunc(L::AnyConditionalsLattice, s00, name, setfield::Bool)
+ @@nospecsfunction _getfield_tfunc(L :: AnyConditionalsLattice, s00, name, setfield :: Bool)
- @nospecs function _getfield_tfunc(L::AnyMustAliasesLattice, s00, name, setfield::Bool)
+ @@nospecsfunction _getfield_tfunc(L :: AnyMustAliasesLattice, s00, name, setfield :: Bool)
- @nospecs function _getfield_tfunc(L::ConstsLattice, s00, name, setfield::Bool)
+ @@nospecsfunction _getfield_tfunc(L :: ConstsLattice, s00, name, setfield :: Bool)
- @nospecs function _getfield_tfunc(L::InferenceLattice, s00, name, setfield::Bool)
+ @@nospecsfunction _getfield_tfunc(L :: InferenceLattice, s00, name, setfield :: Bool)
- @nospecs function _getfield_tfunc(L::JLTypeLattice, s00, name, setfield::Bool)
+ @@nospecsfunction _getfield_tfunc(L :: JLTypeLattice, s00, name, setfield :: Bool)
- @nospecs function _getfield_tfunc(L::PartialsLattice, s00, name, setfield::Bool)
+ @@nospecsfunction _getfield_tfunc(L :: PartialsLattice, s00, name, setfield :: Bool)
- @nospecs function _memoryref_isassigned_tfunc(L::AbstractLattice, mem, order, boundscheck)
+ @@nospecsfunction _memoryref_isassigned_tfunc(L :: AbstractLattice, mem, order, boundscheck)
- @nospecs function _memoryrefget_tfunc(L::AbstractLattice, mem, order, boundscheck)
+ @@nospecsfunction _memoryrefget_tfunc(L :: AbstractLattice, mem, order, boundscheck)
- @nospecs function _typeof_tfunc(L::AbstractLattice, t)
+ @@nospecsfunction _typeof_tfunc(L :: AbstractLattice, t)
- @nospecs function and_int_tfunc(L::ConstsLattice, x, y)
+ @@nospecsfunction and_int_tfunc(L :: ConstsLattice, x, y)
- @nospecs function apply_type_tfunc(L::AbstractLattice, headtypetype, args...)
+ @@nospecsfunction apply_type_tfunc(L :: AbstractLattice, headtypetype, args...)
- @nospecs function atomic_fence_tfunc(L::AbstractLattice, order)
+ @@nospecsfunction atomic_fence_tfunc(L :: AbstractLattice, order)
- @nospecs function atomic_pointermodify_tfunc(L::AbstractLattice, ptr, op, v, order)
+ @@nospecsfunction atomic_pointermodify_tfunc(L :: AbstractLattice, ptr, op, v, order)
- @nospecs function atomic_pointerref_tfunc(L::AbstractLattice, a, order)
+ @@nospecsfunction atomic_pointerref_tfunc(L :: AbstractLattice, a, order)
- @nospecs function atomic_pointerreplace_tfunc(L::AbstractLattice, ptr, x, v, success_order, failure_order)
+ @@nospecsfunction atomic_pointerreplace_tfunc(L :: AbstractLattice, ptr, x, v, success_order, failure_order)
- @nospecs function atomic_pointerset_tfunc(L::AbstractLattice, a, v, order)
+ @@nospecsfunction atomic_pointerset_tfunc(L :: AbstractLattice, a, v, order)
- @nospecs function atomic_pointerswap_tfunc(L::AbstractLattice, a, v, order)
+ @@nospecsfunction atomic_pointerswap_tfunc(L :: AbstractLattice, a, v, order)
- @nospecs function cglobal_tfunc(L::AbstractLattice, fptr, t)
+ @@nospecsfunction cglobal_tfunc(L :: AbstractLattice, fptr, t)
- @nospecs function compilerbarrier_nothrow(setting, val)
+ @@nospecsfunction compilerbarrier_nothrow(setting, val)
- @nospecs function compilerbarrier_tfunc(L::AbstractLattice, setting, val)
+ @@nospecsfunction compilerbarrier_tfunc(L :: AbstractLattice, setting, val)
- @nospecs function egal_tfunc(::JLTypeLattice, x, y)
+ @@nospecsfunction egal_tfunc(??? :: JLTypeLattice, x, y)
- @nospecs function egal_tfunc(L::ConditionalsLattice, x, y)
+ @@nospecsfunction egal_tfunc(L :: ConditionalsLattice, x, y)
- @nospecs function egal_tfunc(L::ConstsLattice, x, y)
+ @@nospecsfunction egal_tfunc(L :: ConstsLattice, x, y)
- @nospecs function egal_tfunc(L::MustAliasesLattice, x, y)
+ @@nospecsfunction egal_tfunc(L :: MustAliasesLattice, x, y)
- @nospecs function fieldtype_nothrow(L::AbstractLattice, s0, name)
+ @@nospecsfunction fieldtype_nothrow(L :: AbstractLattice, s0, name)
- @nospecs function fieldtype_tfunc(L::AbstractLattice, s0, name)
+ @@nospecsfunction fieldtype_tfunc(L :: AbstractLattice, s0, name)
- @nospecs function fieldtype_tfunc(L::AbstractLattice, s0, name, boundscheck)
+ @@nospecsfunction fieldtype_tfunc(L :: AbstractLattice, s0, name, boundscheck)
- @nospecs function get_binding_type_effect_free(M, s)
+ @@nospecsfunction get_binding_type_effect_free(M, s)
- @nospecs function get_binding_type_nothrow(L::AbstractLattice, M, s)
+ @@nospecsfunction get_binding_type_nothrow(L :: AbstractLattice, M, s)
- @nospecs function get_binding_type_tfunc(L::AbstractLattice, M, s)
+ @@nospecsfunction get_binding_type_tfunc(L :: AbstractLattice, M, s)
- @nospecs function getfield_nothrow(L::AbstractLattice, s00, name, boundscheck::Bool)
+ @@nospecsfunction getfield_nothrow(L :: AbstractLattice, s00, name, boundscheck :: Bool)
- @nospecs function getfield_notundefined(typ0, name)
+ @@nospecsfunction getfield_notundefined(typ0, name)
- @nospecs function getfield_tfunc(L::AbstractLattice, s00, name)
+ @@nospecsfunction getfield_tfunc(L :: AbstractLattice, s00, name)
- @nospecs function getfield_tfunc(L::AbstractLattice, s00, name, boundscheck_or_order)
+ @@nospecsfunction getfield_tfunc(L :: AbstractLattice, s00, name, boundscheck_or_order)
- @nospecs function getfield_tfunc(L::AbstractLattice, s00, name, order, boundscheck)
+ @@nospecsfunction getfield_tfunc(L :: AbstractLattice, s00, name, order, boundscheck)
- @nospecs function getglobal_nothrow(M, s)
+ @@nospecsfunction getglobal_nothrow(M, s)
- @nospecs function getglobal_nothrow(M, s, o)
+ @@nospecsfunction getglobal_nothrow(M, s, o)
- @nospecs function getglobal_tfunc(L::AbstractLattice, M, s, order=Symbol)
+ @@nospecsfunction getglobal_tfunc(L :: AbstractLattice, M, s, order = Symbol)
- @nospecs function ifelse_nothrow(L::AbstractLattice, cond, x, y)
+ @@nospecsfunction ifelse_nothrow(L :: AbstractLattice, cond, x, y)
- @nospecs function ifelse_tfunc(L::AbstractLattice, cnd, x, y)
+ @@nospecsfunction ifelse_tfunc(L :: AbstractLattice, cnd, x, y)
- @nospecs function isa_nothrow(L::AbstractLattice, obj, typ)
+ @@nospecsfunction isa_nothrow(L :: AbstractLattice, obj, typ)
- @nospecs function isa_tfunc(L::AbstractLattice, v, tt)
+ @@nospecsfunction isa_tfunc(L :: AbstractLattice, v, tt)
- @nospecs function isdefined_nothrow(L::AbstractLattice, x, name)
+ @@nospecsfunction isdefined_nothrow(L :: AbstractLattice, x, name)
- @nospecs function isdefined_tfunc(L::AbstractLattice, arg1, sym)
+ @@nospecsfunction isdefined_tfunc(L :: AbstractLattice, arg1, sym)
- @nospecs function isdefined_tfunc(L::AbstractLattice, arg1, sym, order)
+ @@nospecsfunction isdefined_tfunc(L :: AbstractLattice, arg1, sym, order)
- @nospecs function llvmcall_tfunc(L::AbstractLattice, fptr, rt, at, a...)
+ @@nospecsfunction llvmcall_tfunc(L :: AbstractLattice, fptr, rt, at, a...)
- @nospecs function memoryref_builtin_common_errorcheck(mem, order, boundscheck)
+ @@nospecsfunction memoryref_builtin_common_errorcheck(mem, order, boundscheck)
- @nospecs function memoryref_builtin_common_typecheck(boundscheck, memtype, order)
+ @@nospecsfunction memoryref_builtin_common_typecheck(boundscheck, memtype, order)
- @nospecs function memoryref_isassigned_tfunc(L::AbstractLattice, mem, order, boundscheck)
+ @@nospecsfunction memoryref_isassigned_tfunc(L :: AbstractLattice, mem, order, boundscheck)
- @nospecs function memoryref_tfunc(L::AbstractLattice, mem)
+ @@nospecsfunction memoryref_tfunc(L :: AbstractLattice, mem)
- @nospecs function memoryref_tfunc(L::AbstractLattice, ref, idx)
+ @@nospecsfunction memoryref_tfunc(L :: AbstractLattice, ref, idx)
- @nospecs function memoryref_tfunc(L::AbstractLattice, ref, idx, boundscheck)
+ @@nospecsfunction memoryref_tfunc(L :: AbstractLattice, ref, idx, boundscheck)
- @nospecs function memoryrefget_tfunc(L::AbstractLattice, mem, order, boundscheck)
+ @@nospecsfunction memoryrefget_tfunc(L :: AbstractLattice, mem, order, boundscheck)
- @nospecs function memoryrefoffset_tfunc(L::AbstractLattice, mem)
+ @@nospecsfunction memoryrefoffset_tfunc(L :: AbstractLattice, mem)
- @nospecs function memoryrefset!_tfunc(L::AbstractLattice, mem, item, order, boundscheck)
+ @@nospecsfunction memoryrefset!_tfunc(L :: AbstractLattice, mem, item, order, boundscheck)
- @nospecs function memoryset_typecheck(memtype, elemtype)
+ @@nospecsfunction memoryset_typecheck(memtype, elemtype)
- @nospecs function modifyfield!_tfunc(L::AbstractLattice, o, f, op, v)
+ @@nospecsfunction modifyfield!_tfunc(L :: AbstractLattice, o, f, op, v)
- @nospecs function modifyfield!_tfunc(L::AbstractLattice, o, f, op, v, order)
+ @@nospecsfunction modifyfield!_tfunc(L :: AbstractLattice, o, f, op, v, order)
- @nospecs function nfields_tfunc(L::AbstractLattice, x)
+ @@nospecsfunction nfields_tfunc(L :: AbstractLattice, x)
- @nospecs function opaque_closure_tfunc(L::AbstractLattice, arg, lb, ub, source, env::Vector{Any}, linfo::MethodInstance)
+ @@nospecsfunction opaque_closure_tfunc(L :: AbstractLattice, arg, lb, ub, source, env :: Vector{Any}, linfo :: MethodInstance)
- @nospecs function or_int_tfunc(L::ConstsLattice, x, y)
+ @@nospecsfunction or_int_tfunc(L :: ConstsLattice, x, y)
- @nospecs function pointerref_tfunc(L::AbstractLattice, a, i, align)
+ @@nospecsfunction pointerref_tfunc(L :: AbstractLattice, a, i, align)
- @nospecs function pointerset_tfunc(L::AbstractLattice, a, v, i, align)
+ @@nospecsfunction pointerset_tfunc(L :: AbstractLattice, a, v, i, align)
- @nospecs function replacefield!_tfunc(L::AbstractLattice, o, f, x, v)
+ @@nospecsfunction replacefield!_tfunc(L :: AbstractLattice, o, f, x, v)
- @nospecs function replacefield!_tfunc(L::AbstractLattice, o, f, x, v, success_order)
+ @@nospecsfunction replacefield!_tfunc(L :: AbstractLattice, o, f, x, v, success_order)
- @nospecs function replacefield!_tfunc(L::AbstractLattice, o, f, x, v, success_order, failure_order)
+ @@nospecsfunction replacefield!_tfunc(L :: AbstractLattice, o, f, x, v, success_order, failure_order)
- @nospecs function setfield!_nothrow(L::AbstractLattice, s00, name, v)
+ @@nospecsfunction setfield!_nothrow(L :: AbstractLattice, s00, name, v)
- @nospecs function setfield!_nothrow(L::AbstractLattice, s00, name, v, order)
+ @@nospecsfunction setfield!_nothrow(L :: AbstractLattice, s00, name, v, order)
- @nospecs function setfield!_tfunc(L::AbstractLattice, o, f, v)
+ @@nospecsfunction setfield!_tfunc(L :: AbstractLattice, o, f, v)
- @nospecs function setfield!_tfunc(L::AbstractLattice, o, f, v, order)
+ @@nospecsfunction setfield!_tfunc(L :: AbstractLattice, o, f, v, order)
- @nospecs function setglobal!_nothrow(M, s, newty)
+ @@nospecsfunction setglobal!_nothrow(M, s, newty)
- @nospecs function setglobal!_nothrow(M, s, newty, o)
+ @@nospecsfunction setglobal!_nothrow(M, s, newty, o)
- @nospecs function setglobal!_tfunc(L::AbstractLattice, M, s, v, order=Symbol)
+ @@nospecsfunction setglobal!_tfunc(L :: AbstractLattice, M, s, v, order = Symbol)
- @nospecs function sizeof_tfunc(L::AbstractLattice, x)
+ @@nospecsfunction sizeof_tfunc(L :: AbstractLattice, x)
- @nospecs function subtype_nothrow(L::AbstractLattice, lty, rty)
+ @@nospecsfunction subtype_nothrow(L :: AbstractLattice, lty, rty)
- @nospecs function subtype_tfunc(L::AbstractLattice, a, b)
+ @@nospecsfunction subtype_tfunc(L :: AbstractLattice, a, b)
- @nospecs function swapfield!_tfunc(L::AbstractLattice, o, f, v)
+ @@nospecsfunction swapfield!_tfunc(L :: AbstractLattice, o, f, v)
- @nospecs function swapfield!_tfunc(L::AbstractLattice, o, f, v, order)
+ @@nospecsfunction swapfield!_tfunc(L :: AbstractLattice, o, f, v, order)
- @nospecs function typeassert_nothrow(L::AbstractLattice, v, t)
+ @@nospecsfunction typeassert_nothrow(L :: AbstractLattice, v, t)
- @nospecs function typeassert_tfunc(L::AbstractLattice, v, t)
+ @@nospecsfunction typeassert_tfunc(L :: AbstractLattice, v, t)
- @nospecs function typebound_nothrow(b)
+ @@nospecsfunction typebound_nothrow(b)
- @nospecs function typeof_tfunc(L::AbstractLattice, t)
+ @@nospecsfunction typeof_tfunc(L :: AbstractLattice, t)
- @nospecs function typevar_nothrow(L::AbstractLattice, n, lb, ub)
+ @@nospecsfunction typevar_nothrow(L :: AbstractLattice, n, lb, ub)
- @nospecs function typevar_tfunc(L::AbstractLattice, n, lb_arg, ub_arg)
+ @@nospecsfunction typevar_tfunc(L :: AbstractLattice, n, lb_arg, ub_arg)
- @propagate_inbounds function Base.getindex(A::AbstractRange, r::OffsetRange{Int})
+ @@propagate_inboundsfunction Base.getindex(A :: AbstractRange, r :: OffsetRange{Int})
- @propagate_inbounds function Base.getindex(A::Array, r::OffsetUnitRange{Int})
+ @@propagate_inboundsfunction Base.getindex(A :: Array, r :: OffsetUnitRange{Int})
- @propagate_inbounds function Base.getindex(A::OffsetArray, r::OffsetRange{Int})
+ @@propagate_inboundsfunction Base.getindex(A :: OffsetArray, r :: OffsetRange{Int})
- @propagate_inbounds function Base.getindex(iter::CartesianIndices{0,R}) where {R}
+ @@propagate_inboundsfunction Base.getindex(iter :: CartesianIndices{DependentType@30f39991, R}) where R
- @propagate_inbounds function Base.iterate(v::T, i::Int = v.dict.idxfloor) where T <: Union{KeySet{<:Any, <:Dict}, ValueIterator{<:Dict}}
+ @@propagate_inboundsfunction Base.iterate(v :: T, i :: Int = v.dict.idxfloor) where T <: Union{KeySet{??? <: Any, ??? <: Dict}, ValueIterator{??? <: Dict}}
- @propagate_inbounds function Base.setindex!(A::OffsetArray, val, i::Int)
+ @@propagate_inboundsfunction Base.setindex!(A :: OffsetArray, val, i :: Int)
- @propagate_inbounds function Base.view(c::CartesianIndices{N}, C::CartesianIndices{N}) where {N}
+ @@propagate_inboundsfunction Base.view(c :: CartesianIndices{N}, C :: CartesianIndices{N}) where N
- @propagate_inbounds function Base.view(c::CartesianIndices{N}, r::Vararg{Union{OrdinalRange{<:Integer, <:Integer}, Colon},N}) where {N}
+ @@propagate_inboundsfunction Base.view(c :: CartesianIndices{N}, r :: Vararg{Union{OrdinalRange{??? <: Integer, ??? <: Integer}, Colon}, N}) where N
- @propagate_inbounds function SubString(s::SubString, i::Int, j::Int)
+ @@propagate_inboundsfunction SubString(s :: SubString, i :: Int, j :: Int)
- @propagate_inbounds function _getindex_ra(a::NonReshapedReinterpretArray{T,N,S}, i1::Int, tailinds::TT) where {T,N,S,TT}
+ @@propagate_inboundsfunction _getindex_ra(a :: NonReshapedReinterpretArray{T, N, S}, i1 :: Int, tailinds :: TT) where T, N, S, TT
- @propagate_inbounds function _getindex_ra(a::ReshapedReinterpretArray{T,N,S}, i1::Int, tailinds::TT) where {T,N,S,TT}
+ @@propagate_inboundsfunction _getindex_ra(a :: ReshapedReinterpretArray{T, N, S}, i1 :: Int, tailinds :: TT) where T, N, S, TT
- @propagate_inbounds function _setindex!(h::Dict, v, key, index, sh = _shorthash7(hash(key)))
+ @@propagate_inboundsfunction _setindex!(h :: Dict, v, key, index, sh = _shorthash7(hash(key)))
- @propagate_inbounds function _setindex_ra!(a::NonReshapedReinterpretArray{T,N,S}, v, i1::Int, tailinds::TT) where {T,N,S,TT}
+ @@propagate_inboundsfunction _setindex_ra!(a :: NonReshapedReinterpretArray{T, N, S}, v, i1 :: Int, tailinds :: TT) where T, N, S, TT
- @propagate_inbounds function _setindex_ra!(a::ReshapedReinterpretArray{T,N,S}, v, i1::Int, tailinds::TT) where {T,N,S,TT}
+ @@propagate_inboundsfunction _setindex_ra!(a :: ReshapedReinterpretArray{T, N, S}, v, i1 :: Int, tailinds :: TT) where T, N, S, TT
- @propagate_inbounds function _zip_iterate_all(is, ss)
+ @@propagate_inboundsfunction _zip_iterate_all(is, ss)
- @propagate_inbounds function _zip_iterate_some(is, ss, ds::Tuple{T,Vararg{Any}}, f::T) where T
+ @@propagate_inboundsfunction _zip_iterate_some(is, ss, ds :: Tuple{T, Vararg{Any}}, f :: T) where T
- @propagate_inbounds function getindex(a::NonReshapedReinterpretArray{T,0,S}) where {T,S}
+ @@propagate_inboundsfunction getindex(a :: NonReshapedReinterpretArray{T, DependentType@452b3a41, S}) where T, S
- @propagate_inbounds function getindex(a::ReinterpretArray{T,N,S}, i::Int) where {T,N,S}
+ @@propagate_inboundsfunction getindex(a :: ReinterpretArray{T, N, S}, i :: Int) where T, N, S
- @propagate_inbounds function getindex(a::ReinterpretArray{T,N,S}, inds::Vararg{Int, N}) where {T,N,S}
+ @@propagate_inboundsfunction getindex(a :: ReinterpretArray{T, N, S}, inds :: Vararg{Int, N}) where T, N, S
- @propagate_inbounds function getindex(a::ReshapedReinterpretArray{T,N,S}, ind::SCartesianIndex2) where {T,N,S}
+ @@propagate_inboundsfunction getindex(a :: ReshapedReinterpretArray{T, N, S}, ind :: SCartesianIndex2) where T, N, S
- @propagate_inbounds function getindex(itr::SkipMissing, I...)
+ @@propagate_inboundsfunction getindex(itr :: SkipMissing, I...)
- @propagate_inbounds function getindex(s::String, i::Int)
+ @@propagate_inboundsfunction getindex(s :: String, i :: Int)
- @propagate_inbounds function getindex(v::AbstractRange, i::Integer)
+ @@propagate_inboundsfunction getindex(v :: AbstractRange, i :: Integer)
- @propagate_inbounds function isassigned(iter::CartesianIndices{N,R}, I::Vararg{Int, N}) where {N,R}
+ @@propagate_inboundsfunction isassigned(iter :: CartesianIndices{N, R}, I :: Vararg{Int, N}) where N, R
- @propagate_inbounds function iterate(A::Reverse{<:AbstractArray}, state=(reverse(eachindex(A.itr)),))
+ @@propagate_inboundsfunction iterate(A :: Reverse{??? <: AbstractArray}, state = (reverse(eachindex(A.itr)),))
- @propagate_inbounds function iterate(L::LogicalIndex, s)
+ @@propagate_inboundsfunction iterate(L :: LogicalIndex, s)
- @propagate_inbounds function iterate(e::Enumerate, state=(1,))
+ @@propagate_inboundsfunction iterate(e :: Enumerate, state = (1,))
- @propagate_inbounds function iterate(f::Flatten, state=())
+ @@propagate_inboundsfunction iterate(f :: Flatten, state = ())
- @propagate_inbounds function iterate(it::Take, state=(it.n,))
+ @@propagate_inboundsfunction iterate(it :: Take, state = (it.n,))
- @propagate_inbounds function iterate(p::Pairs{K, V}, state...) where {K, V}
+ @@propagate_inboundsfunction iterate(p :: Pairs{K, V}, state...) where K, V
- @propagate_inbounds function iterate(r::Reverse{<:Pairs}, state=(reverse(getfield(r.itr, :itr)),))
+ @@propagate_inboundsfunction iterate(r :: Reverse{??? <: Pairs}, state = (reverse(getfield(r.itr,:itr)),))
- @propagate_inbounds function iterate(t::Dict)
+ @@propagate_inboundsfunction iterate(t :: Dict)
- @propagate_inbounds function lt(p::Perm, a::Integer, b::Integer)
+ @@propagate_inboundsfunction lt(p :: Perm, a :: Integer, b :: Integer)
- @propagate_inbounds function only(x)
+ @@propagate_inboundsfunction only(x)
- @propagate_inbounds function setindex!(B::BitArray, X::AbstractArray, J0::Union{Colon,AbstractUnitRange{Int}})
+ @@propagate_inboundsfunction setindex!(B :: BitArray, X :: AbstractArray, J0 :: Union{Colon, AbstractUnitRange{Int}})
- @propagate_inbounds function setindex!(a::NonReshapedReinterpretArray{T,0,S}, v) where {T,S}
+ @@propagate_inboundsfunction setindex!(a :: NonReshapedReinterpretArray{T, DependentType@4a574795, S}, v) where T, S
- @propagate_inbounds function setindex!(a::ReinterpretArray{T,N,S}, v, i::Int) where {T,N,S}
+ @@propagate_inboundsfunction setindex!(a :: ReinterpretArray{T, N, S}, v, i :: Int) where T, N, S
- @propagate_inbounds function setindex!(a::ReinterpretArray{T,N,S}, v, inds::Vararg{Int, N}) where {T,N,S}
+ @@propagate_inboundsfunction setindex!(a :: ReinterpretArray{T, N, S}, v, inds :: Vararg{Int, N}) where T, N, S
- @propagate_inbounds function setindex!(a::ReshapedReinterpretArray{T,N,S}, v, ind::SCartesianIndex2) where {T,N,S}
+ @@propagate_inboundsfunction setindex!(a :: ReshapedReinterpretArray{T, N, S}, v, ind :: SCartesianIndex2) where T, N, S
- function (*)(A::AbstractMatrix, B::AbstractMatrix)
+ function *(A :: AbstractMatrix, B :: AbstractMatrix)
- function (*)(A::AbstractMatrix, Q::AbstractQ)
+ function *(A :: AbstractMatrix, Q :: AbstractQ)
- function (*)(A::AbstractMatrix{T}, x::AbstractVector{S}) where {T,S}
+ function *(A :: AbstractMatrix{T}, x :: AbstractVector{S}) where T, S
- function (*)(A::AbstractVector, Q::AbstractQ)
+ function *(A :: AbstractVector, Q :: AbstractQ)
- function (*)(A::AdjOrTransAbsMat, D::Diagonal)
+ function *(A :: AdjOrTransAbsMat, D :: Diagonal)
- function (*)(A::AdjOrTransStridedMat{<:BlasComplex}, B::StridedMaybeAdjOrTransMat{<:BlasReal})
+ function *(A :: AdjOrTransStridedMat{??? <: BlasComplex}, B :: StridedMaybeAdjOrTransMat{??? <: BlasReal})
- function (*)(A::StridedMatrix{<:BlasComplex}, B::StridedMaybeAdjOrTransMat{<:BlasReal})
+ function *(A :: StridedMatrix{??? <: BlasComplex}, B :: StridedMaybeAdjOrTransMat{??? <: BlasReal})
- function (*)(A::StridedMatrix{<:BlasReal}, B::StridedMatrix{<:BlasComplex})
+ function *(A :: StridedMatrix{??? <: BlasReal}, B :: StridedMatrix{??? <: BlasComplex})
- function (*)(A::StridedMaybeAdjOrTransMat{<:BlasComplex}, B::StridedMaybeAdjOrTransMat{<:BlasComplex})
+ function *(A :: StridedMaybeAdjOrTransMat{??? <: BlasComplex}, B :: StridedMaybeAdjOrTransMat{??? <: BlasComplex})
- function (*)(A::StridedMaybeAdjOrTransMat{<:BlasReal}, B::StridedMaybeAdjOrTransMat{<:BlasReal})
+ function *(A :: StridedMaybeAdjOrTransMat{??? <: BlasReal}, B :: StridedMaybeAdjOrTransMat{??? <: BlasReal})
- function (*)(A::StridedMaybeAdjOrTransMat{T}, x::StridedVector{S}) where {T<:BlasFloat,S<:Real}
+ function *(A :: StridedMaybeAdjOrTransMat{T}, x :: StridedVector{S}) where T <: BlasFloat, S <: Real
- function (*)(D::Diagonal, A::AdjOrTransAbsMat)
+ function *(D :: Diagonal, A :: AdjOrTransAbsMat)
- function (*)(D::Diagonal, V::AbstractVector)
+ function *(D :: Diagonal, V :: AbstractVector)
- function (*)(Da::Diagonal, A::AbstractMatrix, Db::Diagonal)
+ function *(Da :: Diagonal, A :: AbstractMatrix, Db :: Diagonal)
- function (*)(Da::Diagonal, Db::Diagonal)
+ function *(Da :: Diagonal, Db :: Diagonal)
- function (*)(Da::Diagonal, Db::Diagonal, Dc::Diagonal)
+ function *(Da :: Diagonal, Db :: Diagonal, Dc :: Diagonal)
- function (*)(F::Hessenberg{<:Any,<:AbstractMatrix{T}}, x::S) where {T,S<:Number}
+ function *(F :: Hessenberg{??? <: Any, ??? <: AbstractMatrix{T}}, x :: S) where T, S <: Number
- function (*)(Q::AbstractQ, B::AbstractMatrix)
+ function *(Q :: AbstractQ, B :: AbstractMatrix)
- function (*)(Q::AbstractQ, B::AbstractVector)
+ function *(Q :: AbstractQ, B :: AbstractVector)
- function (*)(Q::AbstractQ, b::Number)
+ function *(Q :: AbstractQ, b :: Number)
- function (*)(a::Number, Q::AbstractQ)
+ function *(a :: Number, Q :: AbstractQ)
- function (*)(s1::Union{AbstractChar, AbstractString}, ss::Union{AbstractChar, AbstractString}...)
+ function *(s1 :: Union{AbstractChar, AbstractString}, ss :: Union{AbstractChar, AbstractString}...)
- function (*)(x::S, F::Hessenberg{<:Any,<:AbstractMatrix{T}}) where {T,S<:Number}
+ function *(x :: S, F :: Hessenberg{??? <: Any, ??? <: AbstractMatrix{T}}) where T, S <: Number
- function (+)(A::AbstractMatrix, J::UniformScaling)
+ function +(A :: AbstractMatrix, J :: UniformScaling)
- function (+)(A::Hermitian, J::UniformScaling{<:Complex})
+ function +(A :: Hermitian, J :: UniformScaling{??? <: Complex})
- function (+)(dt::Date, z::Month)
+ function +(dt :: Date, z :: Month)
- function (+)(dt::Date,y::Year)
+ function +(dt :: Date, y :: Year)
- function (+)(dt::DateTime, y::Year)
+ function +(dt :: DateTime, y :: Year)
- function (+)(dt::DateTime, z::Month)
+ function +(dt :: DateTime, z :: Month)
- function (+)(x::AbstractArray{<:TimeType}, y::GeneralPeriod)
+ function +(x :: AbstractArray{??? <: TimeType}, y :: GeneralPeriod)
- function (+)(x::StridedArray{<:GeneralPeriod})
+ function +(x :: StridedArray{??? <: GeneralPeriod})
- function (+)(x::StridedArray{<:GeneralPeriod}, y::TimeType)
+ function +(x :: StridedArray{??? <: GeneralPeriod}, y :: TimeType)
- function (+)(x::TimeType, y::CompoundPeriod)
+ function +(x :: TimeType, y :: CompoundPeriod)
- function (+)(y::GeneralPeriod, x::AbstractArray{<:TimeType})
+ function +(y :: GeneralPeriod, x :: AbstractArray{??? <: TimeType})
- function (+)(y::TimeType, x::StridedArray{<:GeneralPeriod})
+ function +(y :: TimeType, x :: StridedArray{??? <: GeneralPeriod})
- function (-)(A::Bidiagonal, B::Diagonal)
+ function -(A :: Bidiagonal, B :: Diagonal)
- function (-)(A::Bidiagonal, B::SymTridiagonal)
+ function -(A :: Bidiagonal, B :: SymTridiagonal)
- function (-)(A::Bidiagonal, B::Tridiagonal)
+ function -(A :: Bidiagonal, B :: Tridiagonal)
- function (-)(A::Diagonal, B::Bidiagonal)
+ function -(A :: Diagonal, B :: Bidiagonal)
- function (-)(A::Diagonal, B::SymTridiagonal)
+ function -(A :: Diagonal, B :: SymTridiagonal)
- function (-)(A::Diagonal, B::Tridiagonal)
+ function -(A :: Diagonal, B :: Tridiagonal)
- function (-)(A::SymTridiagonal, B::Bidiagonal)
+ function -(A :: SymTridiagonal, B :: Bidiagonal)
- function (-)(A::SymTridiagonal, B::Diagonal)
+ function -(A :: SymTridiagonal, B :: Diagonal)
- function (-)(A::Tridiagonal, B::Bidiagonal)
+ function -(A :: Tridiagonal, B :: Bidiagonal)
- function (-)(A::Tridiagonal, B::Diagonal)
+ function -(A :: Tridiagonal, B :: Diagonal)
- function (-)(A::UniformScaling, B::Bidiagonal)
+ function -(A :: UniformScaling, B :: Bidiagonal)
- function (-)(A::UniformScaling, B::Diagonal)
+ function -(A :: UniformScaling, B :: Diagonal)
- function (-)(A::UniformScaling, B::SymTridiagonal)
+ function -(A :: UniformScaling, B :: SymTridiagonal)
- function (-)(A::UniformScaling, B::Tridiagonal)
+ function -(A :: UniformScaling, B :: Tridiagonal)
- function (-)(B::BitArray)
+ function -(B :: BitArray)
- function (-)(J::UniformScaling, A::AbstractMatrix)
+ function -(J :: UniformScaling, A :: AbstractMatrix)
- function (-)(J::UniformScaling{<:Complex}, A::Hermitian)
+ function -(J :: UniformScaling{??? <: Complex}, A :: Hermitian)
- function (-)(dt::Date, z::Month)
+ function -(dt :: Date, z :: Month)
- function (-)(dt::Date,y::Year)
+ function -(dt :: Date, y :: Year)
- function (-)(dt::DateTime, z::Month)
+ function -(dt :: DateTime, z :: Month)
- function (-)(dt::DateTime,y::Year)
+ function -(dt :: DateTime, y :: Year)
- function (-)(x::AbstractArray{<:TimeType}, y::GeneralPeriod)
+ function -(x :: AbstractArray{??? <: TimeType}, y :: GeneralPeriod)
- function (-)(x::AbstractArray{T}, y::T) where {T<:TimeType}
+ function -(x :: AbstractArray{T}, y :: T) where T <: TimeType
- function (-)(x::StridedArray{<:GeneralPeriod}, y::TimeType)
+ function -(x :: StridedArray{??? <: GeneralPeriod}, y :: TimeType)
- function (-)(x::TimeType, y::CompoundPeriod)
+ function -(x :: TimeType, y :: CompoundPeriod)
- function (-)(y::T, x::AbstractArray{T}) where {T<:TimeType}
+ function -(y :: T, x :: AbstractArray{T}) where T <: TimeType
- function (/)(A::AbstractVecOrMat, B::AbstractVecOrMat)
+ function /(A :: AbstractVecOrMat, B :: AbstractVecOrMat)
- function (/)(B::AbstractMatrix, F::Factorization)
+ function /(B :: AbstractMatrix, F :: Factorization)
- function (/)(B::Union{Matrix{Complex{T}},AdjOrTrans{Complex{T},Vector{Complex{T}}}}, F::Factorization{T}) where {T<:BlasReal}
+ function /(B :: Union{Matrix{Complex{T}}, AdjOrTrans{Complex{T}, Vector{Complex{T}}}}, F :: Factorization{T}) where T <: BlasReal
- function (/)(S::SymTridiagonal, D::Diagonal)
+ function /(S :: SymTridiagonal, D :: Diagonal)
- function (:)(start::T, step::T, stop::T) where T<:IEEEFloat
+ function :(start :: T, step :: T, stop :: T) where T <: IEEEFloat
- function (::Type{T})(n::BigInt, ::RoundingMode{:Down}) where T<:CdoubleMax
+ function ::Type{T}(n :: BigInt, ??? :: RoundingMode{:, Down}) where T <: CdoubleMax
- function (::Type{T})(n::BigInt, ::RoundingMode{:ToZero}) where T<:Union{Float16,Float32}
+ function ::Type{T}(n :: BigInt, ??? :: RoundingMode{:, ToZero}) where T <: Union{Float16, Float32}
- function (::Type{T})(n::BigInt, ::RoundingMode{:Up}) where T<:CdoubleMax
+ function ::Type{T}(n :: BigInt, ??? :: RoundingMode{:, Up}) where T <: CdoubleMax
- function (::Type{T})(repo::GitRepo, oid::GitHash) where T<:GitObject
+ function ::Type{T}(repo :: GitRepo, oid :: GitHash) where T <: GitObject
- function (::Type{T})(repo::GitRepo, oid::GitShortHash) where T<:GitObject
+ function ::Type{T}(repo :: GitRepo, oid :: GitShortHash) where T <: GitObject
- function (::Type{T})(repo::GitRepo, spec::AbstractString) where T<:GitObject
+ function ::Type{T}(repo :: GitRepo, spec :: AbstractString) where T <: GitObject
- function (::Type{T})(te::GitTreeEntry) where T<:GitObject
+ function ::Type{T}(te :: GitTreeEntry) where T <: GitObject
- function (::Type{T})(x::BigFloat) where T<:Integer
+ function ::Type{T}(x :: BigFloat) where T <: Integer
- function (::Type{T})(x::BigInt) where T<:Base.BitSigned
+ function ::Type{T}(x :: BigInt) where T <: Base.BitSigned
- function (::Type{T})(x::BigInt) where T<:Base.BitUnsigned
+ function ::Type{T}(x :: BigInt) where T <: Base.BitUnsigned
- function (::Type{T})(x::Rational{S}) where T<:AbstractFloat where S
+ function ::Type{T}(x :: Rational{S}) where T <: AbstractFloat where S
- function (<<)(B::BitVector, i::UInt)
+ function <<(B :: BitVector, i :: UInt)
- function (==)(A::AbstractArray, B::AbstractArray)
+ function ==(A :: AbstractArray, B :: AbstractArray)
- function (==)(A::BitArray, B::BitArray)
+ function ==(A :: BitArray, B :: BitArray)
- function (>>>)(B::BitVector, i::UInt)
+ function >>>(B :: BitVector, i :: UInt)
- function (@main)(ARGS)
+ function @main(ARGS)
- function (T::Type{<:GenericDomTree})()
+ function T::Type{<:GenericDomTree}
- function (\)(A::AbstractMatrix, B::AbstractVecOrMat)
+ function \(A :: AbstractMatrix, B :: AbstractVecOrMat)
- function (\)(A::Union{QR{T},QRCompactWY{T},QRPivoted{T}}, BIn::VecOrMat{Complex{T}}) where T<:BlasReal
+ function \(A :: Union{QR{T}, QRCompactWY{T}, QRPivoted{T}}, BIn :: VecOrMat{Complex{T}}) where T <: BlasReal
- function (\)(D::Diagonal, S::SymTridiagonal)
+ function \(D :: Diagonal, S :: SymTridiagonal)
- function (\)(F::Factorization, B::AbstractVecOrMat)
+ function \(F :: Factorization, B :: AbstractVecOrMat)
- function (\)(F::Factorization{T}, B::VecOrMat{Complex{T}}) where {T<:BlasReal}
+ function \(F :: Factorization{T}, B :: VecOrMat{Complex{T}}) where T <: BlasReal
- function (\)(F::LQ{T}, B::VecOrMat{Complex{T}}) where T<:BlasReal
+ function \(F :: LQ{T}, B :: VecOrMat{Complex{T}}) where T <: BlasReal
- function (^)(A::AbstractMatrix{T}, p::Integer) where T<:Integer
+ function ^(A :: AbstractMatrix{T}, p :: Integer) where T <: Integer
- function (^)(A::AbstractMatrix{T}, p::Real) where T
+ function ^(A :: AbstractMatrix{T}, p :: Real) where T
- function (f::PrintAll)(io::IO)
+ function f::PrintAll(io :: IO)
- function (f::RedirectStdStream)(::DevNull)
+ function f::RedirectStdStream(??? :: DevNull)
- function (f::RedirectStdStream)(handle::Union{LibuvStream, IOStream})
+ function f::RedirectStdStream(handle :: Union{LibuvStream, IOStream})
- function (f::RedirectStdStream)(io::AbstractPipe)
+ function f::RedirectStdStream(io :: AbstractPipe)
- function (f::RedirectStdStream)(p::Pipe)
+ function f::RedirectStdStream(p :: Pipe)
- function (f::RedirectStdStream)(thunk::Function, stream)
+ function f::RedirectStdStream(thunk :: Function, stream)
- function (g::GeneratedFunctionStub)(world::UInt, source::LineNumberNode, @nospecialize args...)
+ function g::GeneratedFunctionStub(world :: UInt, source :: LineNumberNode, args...)
- function (h::RawBigIntRoundingIncrementHelper)(::Rounding.StickyBit)
+ function h::RawBigIntRoundingIncrementHelper(??? :: Rounding.StickyBit)
- function (io::IO, indent::String, idx::Int)
+ function io::IO,indent::String,idx::Int
- function (la::Logged)(m::Module, s::Symbol)
+ function la::Logged(m :: Module, s :: Symbol)
- function (ss::SummarySize)(obj::Core.TypeName)
+ function ss::SummarySize(obj :: Core.TypeName)
- function (ss::SummarySize)(obj::DataType)
+ function ss::SummarySize(obj :: DataType)
- function (ss::SummarySize)(obj::GenericMemory)
+ function ss::SummarySize(obj :: GenericMemory)
- function (ss::SummarySize)(obj::Module)
+ function ss::SummarySize(obj :: Module)
- function (ss::SummarySize)(obj::SimpleVector)
+ function ss::SummarySize(obj :: SimpleVector)
- function (ss::SummarySize)(obj::String)
+ function ss::SummarySize(obj :: String)
- function (ss::SummarySize)(obj::Task)
+ function ss::SummarySize(obj :: Task)
- function (this::IntermediaryCollector)(@nospecialize(pi), @nospecialize(ssa))
+ function this::IntermediaryCollector(pi, ssa)
- function (x)
+ function x
- function *(A::AbstractMatrix, B::AbstractTriangular)
+ function *(A :: AbstractMatrix, B :: AbstractTriangular)
- function *(A::AbstractTriangular, B::AbstractTriangular)
+ function *(A :: AbstractTriangular, B :: AbstractTriangular)
- function *(A::Bidiagonal, B::LowerOrUnitLowerTriangular)
+ function *(A :: Bidiagonal, B :: LowerOrUnitLowerTriangular)
- function *(A::Bidiagonal, B::UpperOrUnitUpperTriangular)
+ function *(A :: Bidiagonal, B :: UpperOrUnitUpperTriangular)
- function *(A::Diagonal, B::SymTridiagonal)
+ function *(A :: Diagonal, B :: SymTridiagonal)
- function *(A::LQ{TA}, B::AbstractVecOrMat{TB}) where {TA,TB}
+ function *(A :: LQ{TA}, B :: AbstractVecOrMat{TB}) where TA, TB
- function *(A::LowerOrUnitLowerTriangular, B::Bidiagonal)
+ function *(A :: LowerOrUnitLowerTriangular, B :: Bidiagonal)
- function *(A::SymTridiagonal, B::Diagonal)
+ function *(A :: SymTridiagonal, B :: Diagonal)
- function *(A::UpperOrUnitUpperTriangular, B::Bidiagonal)
+ function *(A :: UpperOrUnitUpperTriangular, B :: Bidiagonal)
- function *(B::Bidiagonal, H::UpperHessenberg)
+ function *(B :: Bidiagonal, H :: UpperHessenberg)
- function *(G1::Givens{S}, G2::Givens{T}) where {S,T}
+ function *(G1 :: Givens{S}, G2 :: Givens{T}) where S, T
- function *(G::Givens{S}, R::Rotation{T}) where {S,T}
+ function *(G :: Givens{S}, R :: Rotation{T}) where S, T
- function *(G::Givens{T}, Gs::Givens{T}...) where {T}
+ function *(G :: Givens{T}, Gs :: Givens{T}...) where T
- function *(H::UpperHessenberg, B::Bidiagonal)
+ function *(H :: UpperHessenberg, B :: Bidiagonal)
- function *(H::UpperHessenberg, U::UpperOrUnitUpperTriangular)
+ function *(H :: UpperHessenberg, U :: UpperOrUnitUpperTriangular)
- function *(R::Rotation{S}, G::Givens{T}) where {S,T}
+ function *(R :: Rotation{S}, G :: Givens{T}) where S, T
- function *(S1::SizedArray, S2::SizedArray)
+ function *(S1 :: SizedArray, S2 :: SizedArray)
- function *(U::UpperOrUnitUpperTriangular, H::UpperHessenberg)
+ function *(U :: UpperOrUnitUpperTriangular, H :: UpperHessenberg)
- function *(r1::Union{Regex,AbstractString,AbstractChar}, rs::Union{Regex,AbstractString,AbstractChar}...)
+ function *(r1 :: Union{Regex, AbstractString, AbstractChar}, rs :: Union{Regex, AbstractString, AbstractChar}...)
- function *(transx::Transpose{<:Any,<:StridedVector{T}}, y::StridedVector{T}) where {T<:BlasComplex}
+ function *(transx :: Transpose{??? <: Any, ??? <: StridedVector{T}}, y :: StridedVector{T}) where T <: BlasComplex
- function *(u::Int128, v::Int128)
+ function *(u :: Int128, v :: Int128)
- function *(u::UInt128, v::UInt128)
+ function *(u :: UInt128, v :: UInt128)
- function *(x::Rational, y::Integer)
+ function *(x :: Rational, y :: Integer)
- function *(x::Rational, y::Rational)
+ function *(x :: Rational, y :: Rational)
- function *(x::TwicePrecision, v::Number)
+ function *(x :: TwicePrecision, v :: Number)
- function *(x::TwicePrecision{<:IEEEFloat}, v::Integer)
+ function *(x :: TwicePrecision{??? <: IEEEFloat}, v :: Integer)
- function *(x::TwicePrecision{T}, y::TwicePrecision{T}) where {T}
+ function *(x :: TwicePrecision{T}, y :: TwicePrecision{T}) where T
- function *(y::Integer, x::Rational)
+ function *(y :: Integer, x :: Rational)
- function +(A::Array, Bs::Array...)
+ function +(A :: Array, Bs :: Array...)
- function +(A::Bidiagonal, B::Bidiagonal)
+ function +(A :: Bidiagonal, B :: Bidiagonal)
- function +(r1::StepRangeLen{T,R}, r2::StepRangeLen{T,R}) where T where R<:TwicePrecision
+ function +(r1 :: StepRangeLen{T, R}, r2 :: StepRangeLen{T, R}) where T where R <: TwicePrecision
- function +(r1::StepRangeLen{T,S}, r2::StepRangeLen{T,S}) where {T,S}
+ function +(r1 :: StepRangeLen{T, S}, r2 :: StepRangeLen{T, S}) where T, S
- function +(x::Int32, y::Int32)
+ function +(x :: Int32, y :: Int32)
- function +(x::Rational, y::Rational)
+ function +(x :: Rational, y :: Rational)
- function +(x::TwicePrecision, y::Number)
+ function +(x :: TwicePrecision, y :: Number)
- function +(x::TwicePrecision{T}, y::TwicePrecision{T}) where T
+ function +(x :: TwicePrecision{T}, y :: TwicePrecision{T}) where T
- function -(A::Bidiagonal, B::Bidiagonal)
+ function -(A :: Bidiagonal, B :: Bidiagonal)
- function -(A::UnitLowerTriangular)
+ function -(A :: UnitLowerTriangular)
- function -(A::UnitUpperTriangular)
+ function -(A :: UnitUpperTriangular)
- function -(c::BigInt, x::BigFloat)
+ function -(c :: BigInt, x :: BigFloat)
- function -(r::LinRange)
+ function -(r :: LinRange)
- function -(x::BigFloat)
+ function -(x :: BigFloat)
- function -(x::Rational, y::Rational)
+ function -(x :: Rational, y :: Rational)
- function -(x::Rational{T}) where T<:BitSigned
+ function -(x :: Rational{T}) where T <: BitSigned
- function -(x::Rational{T}) where T<:Unsigned
+ function -(x :: Rational{T}) where T <: Unsigned
- function -(x::Real, z::Complex)
+ function -(x :: Real, z :: Complex)
- function -(x::Real, z::Complex{Bool})
+ function -(x :: Real, z :: Complex{Bool})
- function /(D::Diagonal, B::Bidiagonal)
+ function /(D :: Diagonal, B :: Bidiagonal)
- function /(H::UpperHessenberg, B::Bidiagonal)
+ function /(H :: UpperHessenberg, B :: Bidiagonal)
- function /(H::UpperHessenberg, U::UnitUpperTriangular)
+ function /(H :: UpperHessenberg, U :: UnitUpperTriangular)
- function /(H::UpperHessenberg, U::UpperTriangular)
+ function /(H :: UpperHessenberg, U :: UpperTriangular)
- function /(a::Complex{T}, b::Complex{T}) where T<:Real
+ function /(a :: Complex{T}, b :: Complex{T}) where T <: Real
- function /(x::TwicePrecision, v::Number)
+ function /(x :: TwicePrecision, v :: Number)
- function /(x::TwicePrecision, y::TwicePrecision)
+ function /(x :: TwicePrecision, y :: TwicePrecision)
- function /(z::ComplexF64, w::ComplexF64)
+ function /(z :: ComplexF64, w :: ComplexF64)
- function /(z::Complex{T}, w::Complex{T}) where {T<:Union{Float16,Float32}}
+ function /(z :: Complex{T}, w :: Complex{T}) where T <: Union{Float16, Float32}
- function //(x::Integer,  y::Rational)
+ function //(x :: Integer, y :: Rational)
- function //(x::Rational, y::Integer)
+ function //(x :: Rational, y :: Integer)
- function //(x::Rational, y::Rational)
+ function //(x :: Rational, y :: Rational)
- function <(t1::Any32, t2::Any32)
+ function <(t1 :: Any32, t2 :: Any32)
- function <(t1::Tuple, t2::Tuple)
+ function <(t1 :: Tuple, t2 :: Tuple)
- function <(x::AbstractIrrational, y::AbstractIrrational)
+ function <(x :: AbstractIrrational, y :: AbstractIrrational)
- function <(x::AbstractIrrational, y::Rational{T}) where T
+ function <(x :: AbstractIrrational, y :: Rational{T}) where T
- function <(x::Rational{T}, y::AbstractIrrational) where T
+ function <(x :: Rational{T}, y :: AbstractIrrational) where T
- function <<(x::Integer, c::Integer)
+ function <<(x :: Integer, c :: Integer)
- function <<(x::Integer, c::Unsigned)
+ function <<(x :: Integer, c :: Unsigned)
- function ==(A::AbstractMatrix, J::UniformScaling)
+ function ==(A :: AbstractMatrix, J :: UniformScaling)
- function ==(A::Bidiagonal, B::Bidiagonal)
+ function ==(A :: Bidiagonal, B :: Bidiagonal)
- function ==(A::Bidiagonal, B::Tridiagonal)
+ function ==(A :: Bidiagonal, B :: Tridiagonal)
- function ==(A::StridedMatrix, J::UniformScaling)
+ function ==(A :: StridedMatrix, J :: UniformScaling)
- function ==(A::Tridiagonal, B::SymTridiagonal)
+ function ==(A :: Tridiagonal, B :: SymTridiagonal)
- function ==(a::Arr, b::Arr) where Arr <: BitIntegerArray{1}
+ function ==(a :: Arr, b :: Arr) where Arr <: BitIntegerArray{DependentType@f6f4d33}
- function ==(a::Arr, b::Arr) where {Arr <: BitIntegerArray}
+ function ==(a :: Arr, b :: Arr) where Arr <: BitIntegerArray
- function ==(a::M, b::M) where {M <: BitIntegerMemory}
+ function ==(a :: M, b :: M) where M <: BitIntegerMemory
- function ==(a::Regex, b::Regex)
+ function ==(a :: Regex, b :: Regex)
- function ==(a::StackFrame, b::StackFrame)
+ function ==(a :: StackFrame, b :: StackFrame)
- function ==(a::Union{String, SubString{String}}, b::Union{String, SubString{String}})
+ function ==(a :: Union{String, SubString{String}}, b :: Union{String, SubString{String}})
- function ==(a::VersionNumber, b::VersionNumber)
+ function ==(a :: VersionNumber, b :: VersionNumber)
- function ==(l::AbstractDict, r::AbstractDict)
+ function ==(l :: AbstractDict, r :: AbstractDict)
- function ==(r::AbstractRange, s::AbstractRange)
+ function ==(r :: AbstractRange, s :: AbstractRange)
- function ==(r::OrdinalRange, s::OrdinalRange)
+ function ==(r :: OrdinalRange, s :: OrdinalRange)
- function ==(r::T, s::T) where {T<:AbstractRange}
+ function ==(r :: T, s :: T) where T <: AbstractRange
- function ==(r::Union{StepRange{T},StepRangeLen{T,T}}, s::Union{StepRange{T},StepRangeLen{T,T}}) where {T}
+ function ==(r :: Union{StepRange{T}, StepRangeLen{T, T}}, s :: Union{StepRange{T}, StepRangeLen{T, T}}) where T
- function ==(s1::BitSet, s2::BitSet)
+ function ==(s1 :: BitSet, s2 :: BitSet)
- function ==(v1::SimpleVector, v2::SimpleVector)
+ function ==(v1 :: SimpleVector, v2 :: SimpleVector)
- function ==(x::AbstractFloat, q::Rational)
+ function ==(x :: AbstractFloat, q :: Rational)
- function >>(x::Integer, c::Integer)
+ function >>(x :: Integer, c :: Integer)
- function >>>(x::Integer, c::Integer)
+ function >>>(x :: Integer, c :: Integer)
- function >>>(x::Integer, c::Unsigned)
+ function >>>(x :: Integer, c :: Unsigned)
- function A1_inbounds()
+ function A1_inbounds
- function A1_nested()
+ function A1_nested
- function A1_noinline()
+ function A1_noinline
- function A2_inbounds()
+ function A2_inbounds
- function A2_notinlined()
+ function A2_notinlined
- function A3()
+ function A3
- function A3_inbounds()
+ function A3_inbounds
- function A3_inbounds2()
+ function A3_inbounds2
- function A42645(a::Vector{T}) where T
+ function A42645(a :: Vector{T}) where T
- function AbstractMatrix(F::CholeskyPivoted)
+ function AbstractMatrix(F :: CholeskyPivoted)
- function AbstractMatrix(F::Hessenberg)
+ function AbstractMatrix(F :: Hessenberg)
- function AddCustomMode(repl, prompt)
+ function AddCustomMode(repl, prompt)
- function Agen_nodrop(A::AbstractArray, I...)
+ function Agen_nodrop(A :: AbstractArray, I...)
- function Agen_slice(A::AbstractArray, I...)
+ function Agen_slice(A :: AbstractArray, I...)
- function AnnotatedString(chars::AbstractVector{C}) where {C<:AbstractChar}
+ function AnnotatedString(chars :: AbstractVector{C}) where C <: AbstractChar
- function ArgEscapeCache(estate::EscapeState)
+ function ArgEscapeCache(estate :: EscapeState)
- function ArgEscapeInfo(x::EscapeInfo)
+ function ArgEscapeInfo(x :: EscapeInfo)
- function Array{T,1}(r::AbstractRange{T}) where {T}
+ function Array{T,1}(r :: AbstractRange{T}) where T
- function Array{T,N}(B::BitArray{N}) where {T,N}
+ function Array{T,N}(B :: BitArray{N}) where T, N
- function AsyncCollector(f, results, c...; ntasks=0, batch_size=nothing)
+ function AsyncCollector(f, results, c..., ntasks = 0, batch_size = nothing)
- function AsyncCondition()
+ function AsyncCondition
- function AsyncCondition(cb::Function)
+ function AsyncCondition(cb :: Function)
- function AsyncGenerator(f, c...; ntasks=0)
+ function AsyncGenerator(f, c..., ntasks = 0)
- function B2()
+ function B2
- function BBScanner(ir::IRCode)
+ function BBScanner(ir :: IRCode)
- function (-)(a::Fix42528, b::Fix42528)
+ function -(a :: Fix42528, b :: Fix42528)
- function (==)(A::Eigen, B::Eigen)
+ function ==(A :: Eigen, B :: Eigen)
- function (==)(A::QRCompactWY, B::QRCompactWY)
+ function ==(A :: QRCompactWY, B :: QRCompactWY)
- function (==)(a::GitCredentialHelper, b::GitCredentialHelper)
+ function ==(a :: GitCredentialHelper, b :: GitCredentialHelper)
- function (==)(a::InterTaint, b::InterTaint)
+ function ==(a :: InterTaint, b :: InterTaint)
- function (==)(a::Platform, b::Platform)
+ function ==(a :: Platform, b :: Platform)
- function (==)(a::SSHCredential, b::SSHCredential)
+ function ==(a :: SSHCredential, b :: SSHCredential)
- function (==)(a::Taint, b::Taint)
+ function ==(a :: Taint, b :: Taint)
- function (==)(a::UserPasswordCredential, b::UserPasswordCredential)
+ function ==(a :: UserPasswordCredential, b :: UserPasswordCredential)
- function +(a::UnhandledVarargCond, xs...)
+ function +(a :: UnhandledVarargCond, xs...)
- function Base.Docs.catdoc(hs::LazyHelp...)
+ function Base.Docs.catdoc(hs :: LazyHelp...)
- function Base.LinearIndices(inds::CartesianIndices)
+ function Base.LinearIndices(inds :: CartesianIndices)
- function Base.LinearIndices(inds::CartesianIndices{N,R}) where {N,R<:NTuple{N, AbstractUnitRange}}
+ function Base.LinearIndices(inds :: CartesianIndices{N, R}) where N, R <: NTuple{N, AbstractUnitRange}
- function Base.Sort._sort!(v::AbstractVector, ::MySecondAlg, o::Base.Order.Ordering, kw)
+ function Base.Sort._sort!(v :: AbstractVector, ??? :: MySecondAlg, o :: Base.Order.Ordering, kw)
- function Base.Sort._sort!(v::AbstractVector, ::NonScalarIndexingOfWithoutMissingVectorAlg, o::Base.Order.Ordering, kw)
+ function Base.Sort._sort!(v :: AbstractVector, ??? :: NonScalarIndexingOfWithoutMissingVectorAlg, o :: Base.Order.Ordering, kw)
- function Base.Timer(delay::Period; interval::Period=Second(0))
+ function Base.Timer(delay :: Period, interval :: Period = Second(0))
- function Base._extrema_rf(x::NTuple{2,BigFloat}, y::NTuple{2,BigFloat})
+ function Base._extrema_rf(x :: NTuple{DependentType@23fc625e, BigFloat}, y :: NTuple{DependentType@3f99bd52, BigFloat})
- function Base._mapreduce_dim(f, op::CommutativeOps, init::Base._InitialValue, A::PermutedDimsArray, dims::Colon)
+ function Base._mapreduce_dim(f, op :: CommutativeOps, init :: Base._InitialValue, A :: PermutedDimsArray, dims :: Colon)
- function Base._mapreduce_dim(f::typeof(identity), op::Union{typeof(Base.mul_prod),typeof(*)}, init::Base._InitialValue, A::PermutedDimsArray{<:Union{Real,Complex}}, dims::Colon)
+ function Base._mapreduce_dim(f :: typeof(identity), op :: Union{typeof(Base.mul_prod), typeof(*)}, init :: Base._InitialValue, A :: PermutedDimsArray{??? <: Union{Real, Complex}}, dims :: Colon)
- function Base._sum(A::Bidiagonal, dims::Integer)
+ function Base._sum(A :: Bidiagonal, dims :: Integer)
- function Base._sum(A::Diagonal, dims::Integer)
+ function Base._sum(A :: Diagonal, dims :: Integer)
- function Base._sum(A::SymTridiagonal, ::Colon)
+ function Base._sum(A :: SymTridiagonal, ??? :: Colon)
- function Base._sum(A::SymTridiagonal, dims::Integer)
+ function Base._sum(A :: SymTridiagonal, dims :: Integer)
- function Base._sum(A::Tridiagonal, dims::Integer)
+ function Base._sum(A :: Tridiagonal, dims :: Integer)
- function Base.cconvert(::Type{Ptr{DiffOptionsStruct}}, pathspecs::AbstractString)
+ function Base.cconvert(??? :: Type{Ptr{DiffOptionsStruct}}, pathspecs :: AbstractString)
- function Base.cconvert(::Type{Ptr{StrArrayStruct}}, x::Vector)
+ function Base.cconvert(??? :: Type{Ptr{StrArrayStruct}}, x :: Vector)
- function Base.cconvert(::Type{Ref{PtrStruct}}, a::RealStruct)
+ function Base.cconvert(??? :: Type{Ref{PtrStruct}}, a :: RealStruct)
- function Base.ceil(dt::TimeType, p::Period)
+ function Base.ceil(dt :: TimeType, p :: Period)
- function Base.ceil(x::ConvertiblePeriod, precision::ConvertiblePeriod)
+ function Base.ceil(x :: ConvertiblePeriod, precision :: ConvertiblePeriod)
- function Base.close(idle::UvTestIdle)
+ function Base.close(idle :: UvTestIdle)
- function Base.close(lock::LockMonitor)
+ function Base.close(lock :: LockMonitor)
- function Base.close(obj::GitSignature)
+ function Base.close(obj :: GitSignature)
- function Base.close(pipe::Base64EncodePipe)
+ function Base.close(pipe :: Base64EncodePipe)
- function Base.cmp(id1::GitHash, id2::GitHash)
+ function Base.cmp(id1 :: GitHash, id2 :: GitHash)
- function Base.cmp(id1::GitShortHash, id2::GitShortHash)
+ function Base.cmp(id1 :: GitShortHash, id2 :: GitShortHash)
- function Base.cmp(x::Rational{BigInt}, y::Rational{BigInt})
+ function Base.cmp(x :: Rational{BigInt}, y :: Rational{BigInt})
- function Base.collect(inds::CartesianIndices)
+ function Base.collect(inds :: CartesianIndices)
- function Base.collect(inds::CartesianIndices{N, R}) where {N,R<:NTuple{N, AbstractUnitRange}}
+ function Base.collect(inds :: CartesianIndices{N, R}) where N, R <: NTuple{N, AbstractUnitRange}
- function Base.convert(::Type{GitSignature}, sig::Signature)
+ function Base.convert(??? :: Type{GitSignature}, sig :: Signature)
- function Base.convert(::Type{Vector{String}}, sa::StrArrayStruct)
+ function Base.convert(??? :: Type{Vector{String}}, sa :: StrArrayStruct)
- function Base.copy!(a::GitCredential, b::GitCredential)
+ function Base.copy!(a :: GitCredential, b :: GitCredential)
- function Base.copy(V::SubArray)
+ function Base.copy(V :: SubArray)
- function Base.copy(aB::Adjoint{<:Any,<:Bidiagonal})
+ function Base.copy(aB :: Adjoint{??? <: Any, ??? <: Bidiagonal})
- function Base.copy(bc::Broadcast.Broadcasted{Broadcast.Style{T22053}})
+ function Base.copy(bc :: Broadcast.Broadcasted{Broadcast.Style{T22053}})
- function Base.copy(tB::Transpose{<:Any,<:Bidiagonal})
+ function Base.copy(tB :: Transpose{??? <: Any, ??? <: Bidiagonal})
- function Base.copyto!(dest::PermutedDimsArray{T,N}, src::AbstractArray{T,N}) where {T,N}
+ function Base.copyto!(dest :: PermutedDimsArray{T, N}, src :: AbstractArray{T, N}) where T, N
- function Base.copyto_unaliased!(deststyle::IndexStyle, dest::AbstractMatrix, srcstyle::IndexCartesian, src::AdjOrTransAbsMat)
+ function Base.copyto_unaliased!(deststyle :: IndexStyle, dest :: AbstractMatrix, srcstyle :: IndexCartesian, src :: AdjOrTransAbsMat)
- function Base.deepcopy_internal(x::BigFloat, stackdict::IdDict)
+ function Base.deepcopy_internal(x :: BigFloat, stackdict :: IdDict)
- function Base.fill!(B::BitMaskedBitArray, b::Bool)
+ function Base.fill!(B :: BitMaskedBitArray, b :: Bool)
- function Base.findall(path::String, idx::GitIndex)
+ function Base.findall(path :: String, idx :: GitIndex)
- function Base.floor(dt::Date, p::Day)
+ function Base.floor(dt :: Date, p :: Day)
- function Base.floor(dt::Date, p::Month)
+ function Base.floor(dt :: Date, p :: Month)
- function Base.floor(dt::Date, p::Quarter)
+ function Base.floor(dt :: Date, p :: Quarter)
- function Base.floor(dt::Date, p::Week)
+ function Base.floor(dt :: Date, p :: Week)
- function Base.floor(dt::Date, p::Year)
+ function Base.floor(dt :: Date, p :: Year)
- function Base.floor(dt::DateTime, p::TimePeriod)
+ function Base.floor(dt :: DateTime, p :: TimePeriod)
- function Base.floor(x::ConvertiblePeriod, precision::T) where T <: ConvertiblePeriod
+ function Base.floor(x :: ConvertiblePeriod, precision :: T) where T <: ConvertiblePeriod
- function Base.getindex(M::MyIdentity, i::Int, j::Int)
+ function Base.getindex(M :: MyIdentity, i :: Int, j :: Int)
- function Base.getindex(M::OneElVec, i::Int)
+ function Base.getindex(M :: OneElVec, i :: Int)
- function Base.getindex(S::Strider{<:Any,N}, I::Vararg{Int,N}) where {N}
+ function Base.getindex(S :: Strider{??? <: Any, N}, I :: Vararg{Int, N}) where N
- function Base.getindex(blame::GitBlame, i::Integer)
+ function Base.getindex(blame :: GitBlame, i :: Integer)
- function Base.getindex(diff::GitDiff, i::Integer)
+ function Base.getindex(diff :: GitDiff, i :: Integer)
- function Base.getindex(idx::GitIndex, i::Integer)
+ function Base.getindex(idx :: GitIndex, i :: Integer)
- function Base.getindex(r::OneToThree, i::Int)
+ function Base.getindex(r :: OneToThree, i :: Int)
- function Base.getindex(rb::GitRebase, i::Integer)
+ function Base.getindex(rb :: GitRebase, i :: Integer)
- function Base.getindex(status::GitStatus, i::Integer)
+ function Base.getindex(status :: GitStatus, i :: Integer)
- function Base.getindex(tree::GitTree, i::Integer)
+ function Base.getindex(tree :: GitTree, i :: Integer)
- function Base.getindex(tree::GitTree, target::AbstractString)
+ function Base.getindex(tree :: GitTree, target :: AbstractString)
- function Base.getindex(val::ScopedValue{T})::T where T
+ function Base.getindex(val :: ScopedValue{T}) where T
- function Base.getindex(x::OneHotVecOrMat{N}, inds::Vararg{Int,N}) where {N}
+ function Base.getindex(x :: OneHotVecOrMat{N}, inds :: Vararg{Int, N}) where N
- function Base.getproperty(c::Completion, name::Symbol)
+ function Base.getproperty(c :: Completion, name :: Symbol)
- function Base.getproperty(mstrct::TestMutable, p::Symbol)
+ function Base.getproperty(mstrct :: TestMutable, p :: Symbol)
- function Base.getproperty(obj::AbstractGitObject, name::Symbol)
+ function Base.getproperty(obj :: AbstractGitObject, name :: Symbol)
- function Base.getproperty(obj::GitObject, name::Symbol)
+ function Base.getproperty(obj :: GitObject, name :: Symbol)
- function Base.getproperty(s::ModeState, name::Symbol)
+ function Base.getproperty(s :: ModeState, name :: Symbol)
- function Base.getproperty(stats::DiskStat, field::Symbol)
+ function Base.getproperty(stats :: DiskStat, field :: Symbol)
- function Base.getproperty(tcd::Issue51499CompletionDict, name::Symbol)
+ function Base.getproperty(tcd :: Issue51499CompletionDict, name :: Symbol)
- function Base.getproperty(ti::TextInterface, name::Symbol)
+ function Base.getproperty(ti :: TextInterface, name :: Symbol)
- function Base.getproperty(v::Issue36437, s::Symbol)
+ function Base.getproperty(v :: Issue36437, s :: Symbol)
- function Base.hash(F::Eigen, h::UInt)
+ function Base.hash(F :: Eigen, h :: UInt)
- function Base.hash(F::QRCompactWY, h::UInt)
+ function Base.hash(F :: QRCompactWY, h :: UInt)
- function Base.hash(ci::CartesianIndex, h::UInt)
+ function Base.hash(ci :: CartesianIndex, h :: UInt)
- function Base.hash(p::Platform, h::UInt)
+ function Base.hash(p :: Platform, h :: UInt)
- function Base.hash(x::CompoundPeriod, h::UInt)
+ function Base.hash(x :: CompoundPeriod, h :: UInt)
- function Base.haskey(tree::GitTree, target::AbstractString)
+ function Base.haskey(tree :: GitTree, target :: AbstractString)
- function Base.inds2string(inds::Tuple{Vararg{Union{IdOffsetRange, IdentityUnitRange{<:IdOffsetRange}}}})
+ function Base.inds2string(inds :: Tuple{Vararg{Union{IdOffsetRange, IdentityUnitRange{??? <: IdOffsetRange}}}})
- function Base.isassigned(A::PermutedDimsArray{T,N,perm,iperm}, I::Vararg{Int,N}) where {T,N,perm,iperm}
+ function Base.isassigned(A :: PermutedDimsArray{T, N, perm, iperm}, I :: Vararg{Int, N}) where T, N, perm, iperm
- function Base.isequal(A::Eigen, B::Eigen)
+ function Base.isequal(A :: Eigen, B :: Eigen)
- function Base.isequal(A::QRCompactWY, B::QRCompactWY)
+ function Base.isequal(A :: QRCompactWY, B :: QRCompactWY)
- function Base.isequal(a::ComparesWithGC38727, b::WeakRef)
+ function Base.isequal(a :: ComparesWithGC38727, b :: WeakRef)
- function Base.isreal(A::HermOrSym)
+ function Base.isreal(A :: HermOrSym)
- function Base.iterate(::CountsIterate47688{N}, n=0) where N
+ function Base.iterate(??? :: CountsIterate47688{N}, n = 0) where N
- function Base.iterate(bc::Broadcasted)
+ function Base.iterate(bc :: Broadcasted)
- function Base.iterate(bi::GitBranchIter, state=nothing)
+ function Base.iterate(bi :: GitBranchIter, state = nothing)
- function Base.iterate(ci::GitConfigIter, state=nothing)
+ function Base.iterate(ci :: GitConfigIter, state = nothing)
- function Base.iterate(f::Foo36572, i=1)
+ function Base.iterate(f :: Foo36572, i = 1)
- function Base.iterate(it::RSplitIterator, (to, remaining_splits)=(lastindex(it.str), it.limit-1))
+ function Base.iterate(it :: RSplitIterator, (to,remaining_splits) = (lastindex(it.str),it.limit-1))
- function Base.iterate(iter::RLEIterator, (i, j, cid))
+ function Base.iterate(iter :: RLEIterator, (i,j,cid))
- function Base.iterate(n::Node, state::Node = n.child)
+ function Base.iterate(n :: Node, state :: Node = n.child)
- function Base.iterate(rb::GitRebase, state=nothing)
+ function Base.iterate(rb :: GitRebase, state = nothing)
- function Base.iterate(w::GitRevWalker, state=nothing)
+ function Base.iterate(w :: GitRevWalker, state = nothing)
- function Base.length(blob::GitBlob)
+ function Base.length(blob :: GitBlob)
- function Base.length(status::GitStatus)
+ function Base.length(status :: GitStatus)
- function Base.mapreduce(f, op, A1::OffsetUnitRange{<:Integer}, As::OffsetUnitRange{<:Integer}...; kw...)
+ function Base.mapreduce(f, op, A1 :: OffsetUnitRange{??? <: Integer}, As :: OffsetUnitRange{??? <: Integer}..., kw...)
- function Base.mapreducedim!(f, op::CommutativeOps, B::AbstractArray{T,N}, A::PermutedDimsArray{S,N,perm,iperm}) where {T,S,N,perm,iperm}
+ function Base.mapreducedim!(f, op :: CommutativeOps, B :: AbstractArray{T, N}, A :: PermutedDimsArray{S, N, perm, iperm}) where T, S, N, perm, iperm
- function Base.mapreducedim!(f::typeof(identity), op::Union{typeof(Base.mul_prod),typeof(*)}, B::AbstractArray{T,N}, A::PermutedDimsArray{<:Union{Real,Complex},N,perm,iperm}) where {T,N,perm,iperm}
+ function Base.mapreducedim!(f :: typeof(identity), op :: Union{typeof(Base.mul_prod), typeof(*)}, B :: AbstractArray{T, N}, A :: PermutedDimsArray{??? <: Union{Real, Complex}, N, perm, iperm}) where T, N, perm, iperm
- function Base.maximum(D::Diagonal{T}) where T <: Number
+ function Base.maximum(D :: Diagonal{T}) where T <: Number
- function Base.minimum(D::Diagonal{T}) where T <: Number
+ function Base.minimum(D :: Diagonal{T}) where T <: Number
- function Base.muladd(A::AbstractMatrix, y::AbstractVecOrMat, z::Union{Number, AbstractArray})
+ function Base.muladd(A :: AbstractMatrix, y :: AbstractVecOrMat, z :: Union{Number, AbstractArray})
- function Base.muladd(A::Diagonal, B::Diagonal, z::Diagonal)
+ function Base.muladd(A :: Diagonal, B :: Diagonal, z :: Diagonal)
- function Base.muladd(A::StridedMaybeAdjOrTransMat{<:Number}, B::StridedMaybeAdjOrTransMat{<:Number}, z::Union{Number, AbstractVecOrMat})
+ function Base.muladd(A :: StridedMaybeAdjOrTransMat{??? <: Number}, B :: StridedMaybeAdjOrTransMat{??? <: Number}, z :: Union{Number, AbstractVecOrMat})
- function Base.muladd(A::StridedMaybeAdjOrTransMat{<:Number}, y::AbstractVector{<:Number}, z::Union{Number, AbstractVector})
+ function Base.muladd(A :: StridedMaybeAdjOrTransMat{??? <: Number}, y :: AbstractVector{??? <: Number}, z :: Union{Number, AbstractVector})
- function Base.muladd(u::AbstractVector, v::AdjOrTransAbsVec, z::Union{Number, AbstractArray})
+ function Base.muladd(u :: AbstractVector, v :: AdjOrTransAbsVec, z :: Union{Number, AbstractArray})
- function Base.nextind(a::AbstractArray{<:Any,N}, i::CartesianIndex{N}) where {N}
+ function Base.nextind(a :: AbstractArray{??? <: Any, N}, i :: CartesianIndex{N}) where N
- function Base.parentmodule(frame::StackFrame)
+ function Base.parentmodule(frame :: StackFrame)
- function Base.parse(::Type{DateTime}, s::AbstractString, df::typeof(ISODateTimeFormat))
+ function Base.parse(??? :: Type{DateTime}, s :: AbstractString, df :: typeof(ISODateTimeFormat))
- function Base.parse(::Type{GitCredentialHelper}, helper::AbstractString)
+ function Base.parse(??? :: Type{GitCredentialHelper}, helper :: AbstractString)
- function Base.parse(::Type{GitCredential}, url::AbstractString)
+ function Base.parse(??? :: Type{GitCredential}, url :: AbstractString)
- function Base.parse(::Type{Platform}, triplet::String; validate_strict::Bool = false)
+ function Base.parse(??? :: Type{Platform}, triplet :: String, validate_strict :: Bool = false)
- function Base.parse(::Type{T}, str::AbstractString, df::DateFormat=default_format(T)) where T<:TimeType
+ function Base.parse(??? :: Type{T}, str :: AbstractString, df :: DateFormat = default_format(T)) where T <: TimeType
- function Base.parse(::Type{UUID}, s::AbstractString)
+ function Base.parse(??? :: Type{UUID}, s :: AbstractString)
- function Base.prevind(a::AbstractArray{<:Any,N}, i::CartesianIndex{N}) where {N}
+ function Base.prevind(a :: AbstractArray{??? <: Any, N}, i :: CartesianIndex{N}) where N
- function Base.print(io::IO, dt::Date)
+ function Base.print(io :: IO, dt :: Date)
- function Base.print(io::IO, dt::DateTime)
+ function Base.print(io :: IO, dt :: DateTime)
- function Base.print(io::IO, id::GitHash)
+ function Base.print(io :: IO, id :: GitHash)
- function Base.promote_rule(A::Type{<:Diagonal{<:Any,V}}, B::Type{<:Diagonal{<:Any,W}}) where {V,W}
+ function Base.promote_rule(A :: Type{??? <: Diagonal{??? <: Any, V}}, B :: Type{??? <: Diagonal{??? <: Any, W}}) where V, W
- function Base.rand(rng::AbstractRNG, ::Random.SamplerType{Quaternion{T}}) where {T<:Real}
+ function Base.rand(rng :: AbstractRNG, ??? :: Random.SamplerType{Quaternion{T}}) where T <: Real
- function Base.randn(rng::AbstractRNG, ::Type{Quaternion{T}}) where {T<:AbstractFloat}
+ function Base.randn(rng :: AbstractRNG, ??? :: Type{Quaternion{T}}) where T <: AbstractFloat
- function Base.read!(io::IO, cred::GitCredential)
+ function Base.read!(io :: IO, cred :: GitCredential)
- function Base.read(pipe::Base64DecodePipe, ::Type{UInt8})
+ function Base.read(pipe :: Base64DecodePipe, ??? :: Type{UInt8})
- function Base.readbytes!(pipe::Base64DecodePipe, data::AbstractVector{UInt8}, nb::Integer=length(data))
+ function Base.readbytes!(pipe :: Base64DecodePipe, data :: AbstractVector{UInt8}, nb :: Integer = length(data))
- function Base.replace_in_print_matrix(A::AdjOrTrans,i::Integer,j::Integer,s::AbstractString)
+ function Base.replace_in_print_matrix(A :: AdjOrTrans, i :: Integer, j :: Integer, s :: AbstractString)
- function Base.replace_in_print_matrix(A::Bidiagonal,i::Integer,j::Integer,s::AbstractString)
+ function Base.replace_in_print_matrix(A :: Bidiagonal, i :: Integer, j :: Integer, s :: AbstractString)
- function Base.replace_in_print_matrix(A::Diagonal,i::Integer,j::Integer,s::AbstractString)
+ function Base.replace_in_print_matrix(A :: Diagonal, i :: Integer, j :: Integer, s :: AbstractString)
- function Base.replace_in_print_matrix(A::HermOrSym,i::Integer,j::Integer,s::AbstractString)
+ function Base.replace_in_print_matrix(A :: HermOrSym, i :: Integer, j :: Integer, s :: AbstractString)
- function Base.replace_in_print_matrix(A::OffsetArray{<:Any,1}, i::Integer, j::Integer, s::AbstractString)
+ function Base.replace_in_print_matrix(A :: OffsetArray{??? <: Any, DependentType@4f023edb}, i :: Integer, j :: Integer, s :: AbstractString)
- function Base.replace_in_print_matrix(A::OffsetArray{<:Any,2}, i::Integer, j::Integer, s::AbstractString)
+ function Base.replace_in_print_matrix(A :: OffsetArray{??? <: Any, DependentType@3a71f4dd}, i :: Integer, j :: Integer, s :: AbstractString)
- function Base.replace_in_print_matrix(A::SymTridiagonal, i::Integer, j::Integer, s::AbstractString)
+ function Base.replace_in_print_matrix(A :: SymTridiagonal, i :: Integer, j :: Integer, s :: AbstractString)
- function Base.replace_in_print_matrix(A::Tridiagonal,i::Integer,j::Integer,s::AbstractString)
+ function Base.replace_in_print_matrix(A :: Tridiagonal, i :: Integer, j :: Integer, s :: AbstractString)
- function Base.replace_in_print_matrix(A::UpperHessenberg, i::Integer, j::Integer, s::AbstractString)
+ function Base.replace_in_print_matrix(A :: UpperHessenberg, i :: Integer, j :: Integer, s :: AbstractString)
- function Base.replace_in_print_matrix(M::MyIdentity, i::Integer, j::Integer, s::AbstractString)
+ function Base.replace_in_print_matrix(M :: MyIdentity, i :: Integer, j :: Integer, s :: AbstractString)
- function Base.replace_in_print_matrix(M::OneElVec, i::Integer, j::Integer, s::AbstractString)
+ function Base.replace_in_print_matrix(M :: OneElVec, i :: Integer, j :: Integer, s :: AbstractString)
- function Base.reshape(A::AbstractArray, inds::Tuple{OffsetAxis,Vararg{OffsetAxis}})
+ function Base.reshape(A :: AbstractArray, inds :: Tuple{OffsetAxis, Vararg{OffsetAxis}})
- function Base.rest(s::AbstractString, st...)
+ function Base.rest(s :: AbstractString, st...)
- function Base.round(::Type{Date}, x::TimeTypeOrPeriod, ::Type{P}, r::RoundingMode=RoundNearestTiesUp) where P <: Period
+ function Base.round(??? :: Type{Date}, x :: TimeTypeOrPeriod, ??? :: Type{P}, r :: RoundingMode = RoundNearestTiesUp) where P <: Period
- function Base.round(dt::TimeType, p::Period, r::RoundingMode{:NearestTiesUp})
+ function Base.round(dt :: TimeType, p :: Period, r :: RoundingMode{:, NearestTiesUp})
- function Base.round(x::AbstractFloat, ::typeof(RoundFromZero))
+ function Base.round(x :: AbstractFloat, ??? :: typeof(RoundFromZero))
- function Base.round(x::ConvertiblePeriod, precision::ConvertiblePeriod, r::RoundingMode{:NearestTiesUp})
+ function Base.round(x :: ConvertiblePeriod, precision :: ConvertiblePeriod, r :: RoundingMode{:, NearestTiesUp})
- function Base.round(x::TimeTypeOrPeriod, ::Type{P}, r::RoundingMode=RoundNearestTiesUp) where P <: Period
+ function Base.round(x :: TimeTypeOrPeriod, ??? :: Type{P}, r :: RoundingMode = RoundNearestTiesUp) where P <: Period
- function Base.seek(h::FILE, offset::Integer)
+ function Base.seek(h :: FILE, offset :: Integer)
- function Base.setindex!(p::AbstractPlatform, v::String, k::String)
+ function Base.setindex!(p :: AbstractPlatform, v :: String, k :: String)
- function Base.setproperty!(cred::SSHCredential, name::Symbol, value)
+ function Base.setproperty!(cred :: SSHCredential, name :: Symbol, value)
- function Base.setproperty!(cred::UserPasswordCredential, name::Symbol, value)
+ function Base.setproperty!(cred :: UserPasswordCredential, name :: Symbol, value)
- function Base.setproperty!(mstrct::TestMutable, p::Symbol, v)
+ function Base.setproperty!(mstrct :: TestMutable, p :: Symbol, v)
- function Base.show(io::IO, ::MIME"text/plain", h::LazyHelp)
+ function Base.show(io :: IO, ??? :: MIME"text/plain", h :: LazyHelp)
- function Base.show(io::IO, ::MIME"text/plain", p::Platform)
+ function Base.show(io :: IO, ??? :: MIME"text/plain", p :: Platform)
- function Base.show(io::IO, ::MIME"text/plain", x::AdjointFactorization)
+ function Base.show(io :: IO, ??? :: MIME"text/plain", x :: AdjointFactorization)
- function Base.show(io::IO, ::MIME"text/plain", x::Enum)
+ function Base.show(io :: IO, ??? :: MIME"text/plain", x :: Enum)
- function Base.show(io::IO, ::MIME"text/plain", x::TransposeFactorization)
+ function Base.show(io :: IO, ??? :: MIME"text/plain", x :: TransposeFactorization)
- function Base.show(io::IO, A::ZeroBasedUnitRange)
+ function Base.show(io :: IO, A :: ZeroBasedUnitRange)
- function Base.show(io::IO, a::Alloc)
+ function Base.show(io :: IO, a :: Alloc)
- function Base.show(io::IO, alg::Algorithm)
+ function Base.show(io :: IO, alg :: Algorithm)
- function Base.show(io::IO, b::Binding)
+ function Base.show(io :: IO, b :: Binding)
- function Base.show(io::IO, bc::Broadcasted{Style}) where {Style}
+ function Base.show(io :: IO, bc :: Broadcasted{Style}) where Style
- function Base.show(io::IO, blame_hunk::BlameHunk)
+ function Base.show(io :: IO, blame_hunk :: BlameHunk)
- function Base.show(io::IO, blob::GitBlob)
+ function Base.show(io :: IO, blob :: GitBlob)
- function Base.show(io::IO, c::GitCommit)
+ function Base.show(io :: IO, c :: GitCommit)
- function Base.show(io::IO, ce::ConfigEntry)
+ function Base.show(io :: IO, ce :: ConfigEntry)
- function Base.show(io::IO, cfg::CFG)
+ function Base.show(io :: IO, cfg :: CFG)
- function Base.show(io::IO, d::DatePart{c}) where c
+ function Base.show(io :: IO, d :: DatePart{c}) where c
- function Base.show(io::IO, d::Delim)
+ function Base.show(io :: IO, d :: Delim)
- function Base.show(io::IO, dd::DiffDelta)
+ function Base.show(io :: IO, dd :: DiffDelta)
- function Base.show(io::IO, df::DateFormat{S,T}) where {S,T}
+ function Base.show(io :: IO, df :: DateFormat{S, T}) where S, T
- function Base.show(io::IO, df::DiffFile)
+ function Base.show(io :: IO, df :: DiffFile)
- function Base.show(io::IO, diff::GitDiff)
+ function Base.show(io :: IO, diff :: GitDiff)
- function Base.show(io::IO, diff_stat::GitDiffStats)
+ function Base.show(io :: IO, diff_stat :: GitDiffStats)
- function Base.show(io::IO, e::Effects)
+ function Base.show(io :: IO, e :: Effects)
- function Base.show(io::IO, ex::TestSetException)
+ function Base.show(io :: IO, ex :: TestSetException)
- function Base.show(io::IO, fh::FetchHead)
+ function Base.show(io :: IO, fh :: FetchHead)
- function Base.show(io::IO, idx::GitIndex)
+ function Base.show(io :: IO, idx :: GitIndex)
- function Base.show(io::IO, lbt::LBTConfig)
+ function Base.show(io :: IO, lbt :: LBTConfig)
- function Base.show(io::IO, m::MIME"text/plain", t::Type{<:Enum})
+ function Base.show(io :: IO, m :: MIME"text/plain", t :: Type{??? <: Enum})
- function Base.show(io::IO, mime::MIME{Symbol("text/plain")}, B::BunchKaufman)
+ function Base.show(io :: IO, mime :: MIME{Symbol, ("text/plain", )}, B :: BunchKaufman)
- function Base.show(io::IO, mime::MIME{Symbol("text/plain")}, lbt::LBTConfig)
+ function Base.show(io :: IO, mime :: MIME{Symbol, ("text/plain", )}, lbt :: LBTConfig)
- function Base.show(io::IO, mime::MIME{Symbol("text/plain")}, lbt::LBTLibraryInfo)
+ function Base.show(io :: IO, mime :: MIME{Symbol, ("text/plain", )}, lbt :: LBTLibraryInfo)
- function Base.show(io::IO, op::BroadcastFunction)
+ function Base.show(io :: IO, op :: BroadcastFunction)
- function Base.show(io::IO, p::Platform)
+ function Base.show(io :: IO, p :: Platform)
- function Base.show(io::IO, r::OffsetRange)
+ function Base.show(io :: IO, r :: OffsetRange)
- function Base.show(io::IO, rb::GitRebase)
+ function Base.show(io :: IO, rb :: GitRebase)
- function Base.show(io::IO, rbo::RebaseOperation)
+ function Base.show(io :: IO, rbo :: RebaseOperation)
- function Base.show(io::IO, rbs::RainbowString)
+ function Base.show(io :: IO, rbs :: RainbowString)
- function Base.show(io::IO, ref::GitReference)
+ function Base.show(io :: IO, ref :: GitReference)
- function Base.show(io::IO, repo::GitRepo)
+ function Base.show(io :: IO, repo :: GitRepo)
- function Base.show(io::IO, result::GitDescribeResult)
+ function Base.show(io :: IO, result :: GitDescribeResult)
- function Base.show(io::IO, scope::Scope)
+ function Base.show(io :: IO, scope :: Scope)
- function Base.show(io::IO, sig::Signature)
+ function Base.show(io :: IO, sig :: Signature)
- function Base.show(io::IO, t::Broken)
+ function Base.show(io :: IO, t :: Broken)
- function Base.show(io::IO, t::Error)
+ function Base.show(io :: IO, t :: Error)
- function Base.show(io::IO, t::Fail)
+ function Base.show(io :: IO, t :: Fail)
- function Base.show(io::IO, t::LogTestFailure)
+ function Base.show(io :: IO, t :: LogTestFailure)
- function Base.show(io::IO, t::Pass)
+ function Base.show(io :: IO, t :: Pass)
- function Base.show(io::IO, t::Time)
+ function Base.show(io :: IO, t :: Time)
- function Base.show(io::IO, te::GitTreeEntry)
+ function Base.show(io :: IO, te :: GitTreeEntry)
- function Base.show(io::IO, tree::GitTree)
+ function Base.show(io :: IO, tree :: GitTree)
- function Base.show(io::IO, val::ScopedValue)
+ function Base.show(io :: IO, val :: ScopedValue)
- function Base.show(io::IO, x::AdjointFactorization)
+ function Base.show(io :: IO, x :: AdjointFactorization)
- function Base.show(io::IO, x::Enum)
+ function Base.show(io :: IO, x :: Enum)
- function Base.show(io::IO, x::EscapeInfo)
+ function Base.show(io :: IO, x :: EscapeInfo)
- function Base.show(io::IO, x::T, forceuntyped::Bool=false, fromprint::Bool=false) where {T <: Base.IEEEFloat}
+ function Base.show(io :: IO, x :: T, forceuntyped :: Bool = false, fromprint :: Bool = false) where T <: Base.IEEEFloat
- function Base.show(io::IO, x::TransposeFactorization)
+ function Base.show(io :: IO, x :: TransposeFactorization)
- function Base.show(io::IO, x::X28004)
+ function Base.show(io :: IO, x :: X28004)
- function Base.showarg(io::IO, @nospecialize(a::OffsetArray), toplevel)
+ function Base.showarg(io :: IO, a :: OffsetArray, toplevel)
- function Base.showarg(io::IO, A::PermutedDimsArray{T,N,perm}, toplevel) where {T,N,perm}
+ function Base.showarg(io :: IO, A :: PermutedDimsArray{T, N, perm}, toplevel) where T, N, perm
- function Base.showarg(io::IO, r::Iterators.Pairs{<:Any, <:Any, I, D}, toplevel) where {D, I}
+ function Base.showarg(io :: IO, r :: Iterators.Pairs{??? <: Any, ??? <: Any, I, D}, toplevel) where D, I
- function Base.showarg(io::IO, r::Iterators.Pairs{<:CartesianIndex, <:Any, <:Any, T}, toplevel) where T <: AbstractArray
+ function Base.showarg(io :: IO, r :: Iterators.Pairs{??? <: CartesianIndex, ??? <: Any, ??? <: Any, T}, toplevel) where T <: AbstractArray
- function Base.showarg(io::IO, r::Iterators.Pairs{<:CartesianIndex, <:Any, <:Any, T}, toplevel) where T<:AbstractVector
+ function Base.showarg(io :: IO, r :: Iterators.Pairs{??? <: CartesianIndex, ??? <: Any, ??? <: Any, T}, toplevel) where T <: AbstractVector
- function Base.showarg(io::IO, r::Iterators.Pairs{<:Integer, <:Any, <:Any, T}, toplevel) where T <: Union{AbstractVector, Tuple}
+ function Base.showarg(io :: IO, r :: Iterators.Pairs{??? <: Integer, ??? <: Any, ??? <: Any, T}, toplevel) where T <: Union{AbstractVector, Tuple}
- function Base.showarg(io::IO, r::Iterators.Pairs{<:Integer, <:Any, <:Any, T}, toplevel) where T<:AbstractArray
+ function Base.showarg(io :: IO, r :: Iterators.Pairs{??? <: Integer, ??? <: Any, ??? <: Any, T}, toplevel) where T <: AbstractArray
- function Base.showarg(io::IO, r::Iterators.Pairs{Symbol, <:Any, <:Any, T}, toplevel) where {T <: NamedTuple}
+ function Base.showarg(io :: IO, r :: Iterators.Pairs{Symbol, ??? <: Any, ??? <: Any, T}, toplevel) where T <: NamedTuple
- function Base.showarg(io::IO, v::Adjoint, toplevel)
+ function Base.showarg(io :: IO, v :: Adjoint, toplevel)
- function Base.showarg(io::IO, v::SubArray, toplevel)
+ function Base.showarg(io :: IO, v :: SubArray, toplevel)
- function Base.showarg(io::IO, v::Transpose, toplevel)
+ function Base.showarg(io :: IO, v :: Transpose, toplevel)
- function Base.showerror(io::IO, err::InvalidFormatStringError)
+ function Base.showerror(io :: IO, err :: InvalidFormatStringError)
- function Base.showerror(io::IO, err::ParserError)
+ function Base.showerror(io :: IO, err :: ParserError)
- function Base.showerror(io::IO, ex::FallbackTestSetException, bt; backtrace=true)
+ function Base.showerror(io :: IO, ex :: FallbackTestSetException, bt, backtrace = true)
- function Base.showerror(io::IO, ex::PosDefException)
+ function Base.showerror(io :: IO, ex :: PosDefException)
- function Base.showerror(io::IO, ex::TestSetException, bt; backtrace=true)
+ function Base.showerror(io :: IO, ex :: TestSetException, bt, backtrace = true)
- function Base.showerror(io::IO, ex::ZeroPivotException)
+ function Base.showerror(io :: IO, ex :: ZeroPivotException)
- function Base.showerror(io::IO, exc::StringIndexError)
+ function Base.showerror(io :: IO, exc :: StringIndexError)
- function Base.shred!(cred::GitCredential)
+ function Base.shred!(cred :: GitCredential)
- function Base.shred!(cred::SSHCredential)
+ function Base.shred!(cred :: SSHCredential)
- function Base.shred!(cred::UserPasswordCredential)
+ function Base.shred!(cred :: UserPasswordCredential)
- function Base.shred!(p::CachedCredentials)
+ function Base.shred!(p :: CachedCredentials)
- function Base.shred!(p::CredentialPayload)
+ function Base.shred!(p :: CredentialPayload)
- function Base.similar(::Type{T}, shape::Tuple{OffsetAxisKnownLength,Vararg{OffsetAxisKnownLength}}) where {T<:AbstractArray}
+ function Base.similar(??? :: Type{T}, shape :: Tuple{OffsetAxisKnownLength, Vararg{OffsetAxisKnownLength}}) where T <: AbstractArray
- function Base.similar(A::AbstractArray, ::Type{T}, shape::Tuple{OffsetAxisKnownLength,Vararg{OffsetAxisKnownLength}}) where T
+ function Base.similar(A :: AbstractArray, ??? :: Type{T}, shape :: Tuple{OffsetAxisKnownLength, Vararg{OffsetAxisKnownLength}}) where T
- function Base.similar(bc::Broadcasted{StructuredMatrixStyle{T}}, ::Type{ElType}) where {T,ElType}
+ function Base.similar(bc :: Broadcasted{StructuredMatrixStyle{T}}, ??? :: Type{ElType}) where T, ElType
- function Base.sinh(a::Float16)
+ function Base.sinh(a :: Float16)
- function Base.sort!(v::AbstractVector, lo::Integer, hi::Integer, ::DispatchLoopTestAlg, order::Base.Order.Ordering)
+ function Base.sort!(v :: AbstractVector, lo :: Integer, hi :: Integer, ??? :: DispatchLoopTestAlg, order :: Base.Order.Ordering)
- function Base.sort!(v::AbstractVector{Int}, lo::Integer, hi::Integer, ::MyFirstAlg, o::Base.Order.Ordering)
+ function Base.sort!(v :: AbstractVector{Int}, lo :: Integer, hi :: Integer, ??? :: MyFirstAlg, o :: Base.Order.Ordering)
- function Base.sort!(w::GitRevWalker; by::Cint = Consts.SORT_NONE, rev::Bool=false)
+ function Base.sort!(w :: GitRevWalker, by :: Cint = Consts.SORT_NONE, rev :: Bool = false)
- function Base.startswith(io::IO, prefix::Base.Chars)
+ function Base.startswith(io :: IO, prefix :: Base.Chars)
- function Base.startswith(io::IO, prefix::Union{String,SubString{String}})
+ function Base.startswith(io :: IO, prefix :: Union{String, SubString{String}})
- function Base.steprange_last(start::T, step, stop) where T<:TimeType
+ function Base.steprange_last(start :: T, step, stop) where T <: TimeType
- function Base.strides(A::PermutedDimsArray{T,N,perm}) where {T,N,perm}
+ function Base.strides(A :: PermutedDimsArray{T, N, perm}) where T, N, perm
- function Base.string(t::Time)
+ function Base.string(t :: Time)
- function Base.string(x::CompoundPeriod)
+ function Base.string(x :: CompoundPeriod)
- function Base.string(x::T) where {T <: Base.IEEEFloat}
+ function Base.string(x :: T) where T <: Base.IEEEFloat
- function Base.timedwait(testcb, timeout::Period; pollint::Period=Millisecond(100))
+ function Base.timedwait(testcb, timeout :: Period, pollint :: Period = Millisecond(100))
- function Base.tryparse(::Type{Platform}, triplet::AbstractString)
+ function Base.tryparse(??? :: Type{Platform}, triplet :: AbstractString)
- function Base.tryparse(::Type{T}, str::AbstractString, df::DateFormat=default_format(T)) where T<:TimeType
+ function Base.tryparse(??? :: Type{T}, str :: AbstractString, df :: DateFormat = default_format(T)) where T <: TimeType
- function Base.tryparse(::Type{UUID}, s::AbstractString)
+ function Base.tryparse(??? :: Type{UUID}, s :: AbstractString)
- function Base.unsafe_convert(::Type{Ptr{DiffOptionsStruct}}, rr::Tuple{Ref{DiffOptionsStruct}, Ref{Cstring}})
+ function Base.unsafe_convert(??? :: Type{Ptr{DiffOptionsStruct}}, rr :: Tuple{Ref{DiffOptionsStruct}, Ref{Cstring}})
- function Base.unsafe_convert(::Type{Ptr{StrArrayStruct}}, rr::Tuple{Ref{StrArrayStruct}, Ref{Cstring}})
+ function Base.unsafe_convert(??? :: Type{Ptr{StrArrayStruct}}, rr :: Tuple{Ref{StrArrayStruct}, Ref{Cstring}})
- function Base.unsafe_convert(::Type{SpillPint}, vr)
+ function Base.unsafe_convert(??? :: Type{SpillPint}, vr)
- function Base.unsafe_read(pipe::Base64DecodePipe, ptr::Ptr{UInt8}, n::UInt)
+ function Base.unsafe_read(pipe :: Base64DecodePipe, ptr :: Ptr{UInt8}, n :: UInt)
- function Base.unsafe_write(pipe::Base64EncodePipe, ptr::Ptr{UInt8}, n::UInt)::Int
+ function Base.unsafe_write(pipe :: Base64EncodePipe, ptr :: Ptr{UInt8}, n :: UInt)
- function Base.uvfinalize(t::UvTestIdle)
+ function Base.uvfinalize(t :: UvTestIdle)
- function Base.wait(idle::UvTestIdle)
+ function Base.wait(idle :: UvTestIdle)
- function Base.write(io::IO, cred::GitCredential)
+ function Base.write(io :: IO, cred :: GitCredential)
- function Base.write(pipe::Base64EncodePipe, x::UInt8)
+ function Base.write(pipe :: Base64EncodePipe, x :: UInt8)
- function Base64DecodePipe(io::IO)
+ function Base64DecodePipe(io :: IO)
- function Base64EncodePipe(io::IO)
+ function Base64EncodePipe(io :: IO)
- function BasicBlock(old_bb, stmts)
+ function BasicBlock(old_bb, stmts)
- function BasicBlock(stmts::StmtRange)
+ function BasicBlock(stmts :: StmtRange)
- function Bidiagonal(A::AbstractMatrix, uplo::Symbol)
+ function Bidiagonal(A :: AbstractMatrix, uplo :: Symbol)
- function Bidiagonal(dv::V, ev::V, uplo::AbstractChar) where {T,V<:AbstractVector{T}}
+ function Bidiagonal(dv :: V, ev :: V, uplo :: AbstractChar) where T, V <: AbstractVector{T}
- function Bidiagonal(dv::V, ev::V, uplo::Symbol) where {T,V<:AbstractVector{T}}
+ function Bidiagonal(dv :: V, ev :: V, uplo :: Symbol) where T, V <: AbstractVector{T}
- function Bidiagonal(dv::Vector{T}, ev::Vector{S}, uplo::Symbol) where {T,S}
+ function Bidiagonal(dv :: Vector{T}, ev :: Vector{S}, uplo :: Symbol) where T, S
- function Bidiagonal{T,V}(A::Bidiagonal) where {T,V<:AbstractVector{T}}
+ function Bidiagonal{T,V}(A :: Bidiagonal) where T, V <: AbstractVector{T}
- function Bidiagonal{T,V}(dv, ev, uplo::AbstractChar) where {T,V<:AbstractVector{T}}
+ function Bidiagonal{T,V}(dv, ev, uplo :: AbstractChar) where T, V <: AbstractVector{T}
- function Bidiagonal{T,V}(dv, ev, uplo::Symbol) where {T,V<:AbstractVector{T}}
+ function Bidiagonal{T,V}(dv, ev, uplo :: Symbol) where T, V <: AbstractVector{T}
- function Bidiagonal{T}(dv::AbstractVector, ev::AbstractVector, uplo::Union{Symbol,AbstractChar}) where {T}
+ function Bidiagonal{T}(dv :: AbstractVector, ev :: AbstractVector, uplo :: Union{Symbol, AbstractChar}) where T
- function BigFloat(; precision::Integer=DEFAULT_PRECISION[])
+ function BigFloat(precision :: Integer = DEFAULT_PRECISION[])
- function BigFloat(x::BigFloat, r::MPFRRoundingMode=ROUNDING_MODE[]; precision::Integer=DEFAULT_PRECISION[])
+ function BigFloat(x :: BigFloat, r :: MPFRRoundingMode = ROUNDING_MODE[], precision :: Integer = DEFAULT_PRECISION[])
- function BigFloat(x::BigInt, r::MPFRRoundingMode=ROUNDING_MODE[]; precision::Integer=DEFAULT_PRECISION[])
+ function BigFloat(x :: BigInt, r :: MPFRRoundingMode = ROUNDING_MODE[], precision :: Integer = DEFAULT_PRECISION[])
- function BigFloat(x::Float64, r::MPFRRoundingMode=ROUNDING_MODE[]; precision::Integer=DEFAULT_PRECISION[])
+ function BigFloat(x :: Float64, r :: MPFRRoundingMode = ROUNDING_MODE[], precision :: Integer = DEFAULT_PRECISION[])
- function BigFloat(x::Rational, r::MPFRRoundingMode=ROUNDING_MODE[]; precision::Integer=DEFAULT_PRECISION[])
+ function BigFloat(x :: Rational, r :: MPFRRoundingMode = ROUNDING_MODE[], precision :: Integer = DEFAULT_PRECISION[])
- function BigInt(; nbits::Integer=0)
+ function BigInt(nbits :: Integer = 0)
- function BigInt(x::BigFloat)
+ function BigInt(x :: BigFloat)
- function BigInt(x::Float64)
+ function BigInt(x :: Float64)
- function BigInt(x::Integer)
+ function BigInt(x :: Integer)
- function Binding(m::Module, v::Symbol)
+ function Binding(m :: Module, v :: Symbol)
- function BitArray(undef, dims::Int...)
+ function BitArray(undef, dims :: Int...)
- function BitArray{N}(::UndefInitializer, dims::Vararg{Int,N}) where N
+ function BitArray{N}(??? :: UndefInitializer, dims :: Vararg{Int, N}) where N
- function BitArray{N}(A::AbstractArray{T,N}) where N where T
+ function BitArray{N}(A :: AbstractArray{T, N}) where N where T
- function BitPerm(p::NTuple{8,UInt8})
+ function BitPerm(p :: NTuple{DependentType@7adf9f5f, UInt8})
- function BitSet()
+ function BitSet
- function BitSetBoundedMinPrioritySet(max::Int)
+ function BitSetBoundedMinPrioritySet(max :: Int)
- function BitVector(nt::Tuple{Vararg{Bool}})
+ function BitVector(nt :: Tuple{Vararg{Bool}})
- function Bool(x::BigFloat)
+ function Bool(x :: BigFloat)
- function Broadcast.broadcasted(::typeof(Base.literal_pow), ::typeof(^), J::UniformScaling, x::Val)
+ function Broadcast.broadcasted(??? :: typeof(Base.literal_pow), ??? :: typeof(^), J :: UniformScaling, x :: Val)
- function BroadcastStyle(a::A, b::B) where {A<:AbstractArrayStyle{M},B<:AbstractArrayStyle{N}} where {M,N}
+ function BroadcastStyle(a :: A, b :: B) where A <: AbstractArrayStyle{M}, B <: AbstractArrayStyle{N}, M, N
- function Broadcasted(f::F, args::Tuple, axes=nothing) where {F}
+ function Broadcasted(f :: F, args :: Tuple, axes = nothing) where F
- function Broadcasted(style::Union{Nothing,BroadcastStyle}, f::F, args::Tuple, axes=nothing) where {F}
+ function Broadcasted(style :: Union{Nothing, BroadcastStyle}, f :: F, args :: Tuple, axes = nothing) where F
- function Broadcasted{Style,Axes,F,Args}(f, args, axes) where {Style,Axes,F,Args}
+ function Broadcasted{Style,Axes,F,Args}(f, args, axes) where Style, Axes, F, Args
- function Broadcasted{Style}(f::F, args, axes=nothing) where {Style, F}
+ function Broadcasted{Style}(f :: F, args, axes = nothing) where Style, F
- function Buffer(bufsize)
+ function Buffer(bufsize)
- function BunchKaufman{T,S,P}(LD, ipiv, uplo, symmetric, rook, info) where {T,S<:AbstractMatrix,P<:AbstractVector}
+ function BunchKaufman{T,S,P}(LD, ipiv, uplo, symmetric, rook, info) where T, S <: AbstractMatrix, P <: AbstractVector
- function CC.:leq(L::AnyTaintLattice, @nospecialize(typea), @nospecialize(typeb))
+ function CC.:leq(L :: AnyTaintLattice, typea, typeb)
- function CC.add_remark!(interp::MTOverlayInterp, ::CC.InferenceState, remark)
+ function CC.add_remark!(interp :: MTOverlayInterp, ??? :: CC.InferenceState, remark)
- function CC.cache_result!(interp::EscapeAnalyzer, result::InferenceResult)
+ function CC.cache_result!(interp :: EscapeAnalyzer, result :: InferenceResult)
- function CC.code_cache(interp::EscapeAnalyzer)
+ function CC.code_cache(interp :: EscapeAnalyzer)
- function CC.const_prop_argument_heuristic(interp::REPLInterpreter, arginfo::CC.ArgInfo, sv::CC.InferenceState)
+ function CC.const_prop_argument_heuristic(interp :: REPLInterpreter, arginfo :: CC.ArgInfo, sv :: CC.InferenceState)
- function CC.optimize(interp::EscapeAnalyzer, opt::OptimizationState, caller::InferenceResult)
+ function CC.optimize(interp :: EscapeAnalyzer, opt :: OptimizationState, caller :: InferenceResult)
- function CC.setindex!(wvc::WorldView{EscapeAnalyzerCacheView}, ci::CodeInstance, mi::MethodInstance)
+ function CC.setindex!(wvc :: WorldView{EscapeAnalyzerCacheView}, ci :: CodeInstance, mi :: MethodInstance)
- function CC.setindex!(wvc::WorldView{InvalidationTesterCacheView}, ci::CodeInstance, mi::MethodInstance)
+ function CC.setindex!(wvc :: WorldView{InvalidationTesterCacheView}, ci :: CodeInstance, mi :: MethodInstance)
- function CC.tmeet(L::AnyTaintLattice, @nospecialize(v), @nospecialize(t::Type))
+ function CC.tmeet(L :: AnyTaintLattice, v, t :: Type)
- function CC.tmerge(L::AnyTaintLattice, @nospecialize(typea), @nospecialize(typeb))
+ function CC.tmerge(L :: AnyTaintLattice, typea, typeb)
- function CC.widenreturn(L::InferenceLattice{<:InterTaintLattice}, @nospecialize(rt), @nospecialize(bestguess), nargs::Int, slottypes::Vector{Any}, changes::CC.VarTable)
+ function CC.widenreturn(L :: InferenceLattice{??? <: InterTaintLattice}, rt, bestguess, nargs :: Int, slottypes :: Vector{Any}, changes :: CC.VarTable)
- function CFGInliningState(ir::IRCode)
+ function CFGInliningState(ir :: IRCode)
- function CFGTransformState!(blocks::Vector{BasicBlock}, allow_cfg_transforms::Bool=false)
+ function CFGTransformState!(blocks :: Vector{BasicBlock}, allow_cfg_transforms :: Bool = false)
- function CacheFlags(f::UInt8)
+ function CacheFlags(f :: UInt8)
- function CachedTOMLDict(p::TOML.Parser, path::String)
+ function CachedTOMLDict(p :: TOML.Parser, path :: String)
- function CapturedException(ex, bt_raw::Vector)
+ function CapturedException(ex, bt_raw :: Vector)
- function CartesianIndices(inds::NTuple{N,OrdinalRange{<:Integer, <:Integer}}) where {N}
+ function CartesianIndices(inds :: NTuple{N, OrdinalRange{??? <: Integer, ??? <: Integer}}) where N
- function Channel(func::Function; ctype=nothing, csize=nothing, taskref=nothing, spawn=nothing, threadpool=nothing)
+ function Channel(func :: Function, ctype = nothing, csize = nothing, taskref = nothing, spawn = nothing, threadpool = nothing)
- function Channel{T}(func::Function, size=0; taskref=nothing, spawn=false, threadpool=nothing) where T
+ function Channel{T}(func :: Function, size = 0, taskref = nothing, spawn = false, threadpool = nothing) where T
- function Channel{T}(sz::Float64) where T
+ function Channel{T}(sz :: Float64) where T
- function Channel{T}(sz::Integer = 0) where T
+ function Channel{T}(sz :: Integer = 0) where T
- function CharPoly()
+ function CharPoly
- function CholeskyPivoted{T,S,P}(factors, uplo, piv, rank, tol, info) where {T,S<:AbstractMatrix,P<:AbstractVector}
+ function CholeskyPivoted{T,S,P}(factors, uplo, piv, rank, tol, info) where T, S <: AbstractMatrix, P <: AbstractVector
- function Cholesky{T,S}(factors, uplo, info) where {T,S<:AbstractMatrix}
+ function Cholesky{T,S}(factors, uplo, info) where T, S <: AbstractMatrix
- function Cholesky{T}(C::Cholesky) where T
+ function Cholesky{T}(C :: Cholesky) where T
- function CompactPeekIterator(compact::IncrementalCompact, start_idx::Int)
+ function CompactPeekIterator(compact :: IncrementalCompact, start_idx :: Int)
- function CompoundPeriod(p::Vector{Period})
+ function CompoundPeriod(p :: Vector{Period})
- function Conditional(slot::Int, @nospecialize(thentype), @nospecialize(elsetype))
+ function Conditional(slot :: Int, thentype, elsetype)
- function Consts.OBJECT(ptr::Ptr{Cvoid})
+ function Consts.OBJECT(ptr :: Ptr{Cvoid})
- function ContextTestSet(name::Union{Symbol, Expr}, @nospecialize(context))
+ function ContextTestSet(name :: Union{Symbol, Expr}, context)
- function Core.OpaqueClosure(src::CodeInfo, @nospecialize env...)
+ function Core.OpaqueClosure(src :: CodeInfo, env...)
- function Core._hasmethod(@nospecialize(f), @nospecialize(t))
+ function Core._hasmethod(f, t)
- function Core.kwcall(kwargs::NamedTuple, ::typeof(applicable), @nospecialize(args...))
+ function Core.kwcall(kwargs :: NamedTuple, ??? :: typeof(applicable), args...)
- function Core.kwcall(kwargs::NamedTuple, ::typeof(hasmethod), @nospecialize(f), @nospecialize(t))
+ function Core.kwcall(kwargs :: NamedTuple, ??? :: typeof(hasmethod), f, t)
- function Core.kwcall(kwargs::NamedTuple, ::typeof(invoke), f, T, args...)
+ function Core.kwcall(kwargs :: NamedTuple, ??? :: typeof(invoke), f, T, args...)
- function CredentialPayload(cache::CachedCredentials; kwargs...)
+ function CredentialPayload(cache :: CachedCredentials, kwargs...)
- function CredentialPayload(credential::AbstractCredential; kwargs...)
+ function CredentialPayload(credential :: AbstractCredential, kwargs...)
- function CyclePadding(T::DataType)
+ function CyclePadding(T :: DataType)
- function DFS!(D::DFSTree, blocks::Vector{BasicBlock}, is_post_dominator::Bool)
+ function DFS!(D :: DFSTree, blocks :: Vector{BasicBlock}, is_post_dominator :: Bool)
- function DFSTree(n_blocks::Int)
+ function DFSTree(n_blocks :: Int)
- function DILineInfoPrinter(linetable::Vector, showtypes::Bool=false)
+ function DILineInfoPrinter(linetable :: Vector, showtypes :: Bool = false)
- function DSFMT_state(val::Vector{Int32} = zeros(Int32, JN32))
+ function DSFMT_state(val :: Vector{Int32} = zeros(Int32,JN32))
- function DataTypeFieldDesc(dt::DataType)
+ function DataTypeFieldDesc(dt :: DataType)
- function Date(d::AbstractString, format::AbstractString; locale::Locale=ENGLISH)
+ function Date(d :: AbstractString, format :: AbstractString, locale :: Locale = ENGLISH)
- function Date(func::Function, y, m=1, d=1; step::Period=Day(1), limit::Int=10000)
+ function Date(func :: Function, y, m = 1, d = 1, step :: Period = Day(1), limit :: Int = 10000)
- function Date(period::Period, periods::Period...)
+ function Date(period :: Period, periods :: Period...)
- function Date(y::Int64, m::Int64=1, d::Int64=1)
+ function Date(y :: Int64, m :: Int64 = 1, d :: Int64 = 1)
- function DateFormat(f::AbstractString, locale::AbstractString)
+ function DateFormat(f :: AbstractString, locale :: AbstractString)
- function DateFormat(f::AbstractString, locale::DateLocale=ENGLISH)
+ function DateFormat(f :: AbstractString, locale :: DateLocale = ENGLISH)
- function DateFunction(@nospecialize(f), dt::TimeType)
+ function DateFunction(f, dt :: TimeType)
- function DateTime(dt::AbstractString, format::AbstractString; locale::Locale=ENGLISH)
+ function DateTime(dt :: AbstractString, format :: AbstractString, locale :: Locale = ENGLISH)
- function DateTime(dt::Date, t::Time)
+ function DateTime(dt :: Date, t :: Time)
- function DateTime(func::Function, y, m, d, h, mi, s; step::Period=Millisecond(1), limit::Int=10000)
+ function DateTime(func :: Function, y, m, d, h, mi, s, step :: Period = Millisecond(1), limit :: Int = 10000)
- function DateTime(func::Function, y, m, d, h, mi; step::Period=Second(1), limit::Int=10000)
+ function DateTime(func :: Function, y, m, d, h, mi, step :: Period = Second(1), limit :: Int = 10000)
- function DateTime(func::Function, y, m, d, h; step::Period=Minute(1), limit::Int=10000)
+ function DateTime(func :: Function, y, m, d, h, step :: Period = Minute(1), limit :: Int = 10000)
- function DateTime(func::Function, y, m, d; step::Period=Hour(1), limit::Int=10000)
+ function DateTime(func :: Function, y, m, d, step :: Period = Hour(1), limit :: Int = 10000)
- function DateTime(func::Function, y, m=1; step::Period=Day(1), limit::Int=10000)
+ function DateTime(func :: Function, y, m = 1, step :: Period = Day(1), limit :: Int = 10000)
- function DateTime(period::Period, periods::Period...)
+ function DateTime(period :: Period, periods :: Period...)
- function Dates.tryparsenext(d::Dates.DatePart{'Z'}, str, i, len)
+ function Dates.tryparsenext(d :: Dates.DatePart{'Z'}, str, i, len)
- function DefaultTestSet(desc::AbstractString; verbose::Bool = false, showtiming::Bool = true, failfast::Union{Nothing,Bool} = nothing, source = nothing)
+ function DefaultTestSet(desc :: AbstractString, verbose :: Bool = false, showtiming :: Bool = true, failfast :: Union{Nothing, Bool} = nothing, source = nothing)
- function Demo_20254(arr::AbstractArray=Any[])
+ function Demo_20254(arr :: AbstractArray = Any[])
- function Diagonal{T,V}(diag) where {T,V<:AbstractVector{T}}
+ function Diagonal{T,V}(diag) where T, V <: AbstractVector{T}
- function Dict(kv)
+ function Dict(kv)
- function Dict{K, V}(slots::Memory{UInt8}, keys::Memory{K}, vals::Memory{V}, ndel::Int, count::Int, age::UInt, idxfloor::Int, maxprobe::Int) where {K, V}
+ function Dict{K,V}(slots :: Memory{UInt8}, keys :: Memory{K}, vals :: Memory{V}, ndel :: Int, count :: Int, age :: UInt, idxfloor :: Int, maxprobe :: Int) where K, V
- function Dict{K,V}() where V where K
+ function Dict{K,V} where V where K
- function Dict{K,V}(d::Dict{K,V}) where V where K
+ function Dict{K,V}(d :: Dict{K, V}) where V where K
- function Dict{K,V}(kv) where V where K
+ function Dict{K,V}(kv) where V where K
- function Dict{K,V}(ps::Pair...) where V where K
+ function Dict{K,V}(ps :: Pair...) where V where K
- function DoAllocConst()
+ function DoAllocConst
- function DoAllocFinalizerThrows()
+ function DoAllocFinalizerThrows
- function DoAllocNoEscape()
+ function DoAllocNoEscape
- function DoAllocNoEscapeBranch(val::Int)
+ function DoAllocNoEscapeBranch(val :: Int)
- function DoAllocNoEscapeNoInline()
+ function DoAllocNoEscapeNoInline
- function DoAllocWithField(x::Int)
+ function DoAllocWithField(x :: Int)
- function Docs.formatdoc(buffer, docstr, ::Type{__FIELDS__})
+ function Docs.formatdoc(buffer, docstr, ??? :: Type{__FIELDS__})
- function Documenter.Writers.HTMLWriter.expand_versions(dir::String, v::Versions)
+ function Documenter.Writers.HTMLWriter.expand_versions(dir :: String, v :: Versions)
- function Documenter.deploy_folder(::BuildBotConfig; devurl, repo, branch, kwargs...)
+ function Documenter.deploy_folder(??? :: BuildBotConfig, devurl, repo, branch, kwargs...)
- function Drop(xs::I, n::Integer) where {I}
+ function Drop(xs :: I, n :: Integer) where I
- function EmissionParams(; emit_metadata::Bool=true)
+ function EmissionParams(emit_metadata :: Bool = true)
- function Error(test_type::Symbol, orig_expr, value, bt, source::LineNumberNode)
+ function Error(test_type :: Symbol, orig_expr, value, bt, source :: LineNumberNode)
- function EscapeState(nargs::Int, nstmts::Int, arrayinfo::Union{Nothing,ArrayInfo})
+ function EscapeState(nargs :: Int, nstmts :: Int, arrayinfo :: Union{Nothing, ArrayInfo})
- function ExponentialBackOff(n, first_delay, max_delay, factor, jitter)
+ function ExponentialBackOff(n, first_delay, max_delay, factor, jitter)
- function F48394(a, b, i)
+ function F48394(a, b, i)
- function FDWatcher(fd::RawFD, mask::FDEvent)
+ function FDWatcher(fd :: RawFD, mask :: FDEvent)
- function FDWatcher(fd::RawFD, readable::Bool, writable::Bool)
+ function FDWatcher(fd :: RawFD, readable :: Bool, writable :: Bool)
- function FILE(fd::RawFD, mode)
+ function FILE(fd :: RawFD, mode)
- function FILE(s::IO)
+ function FILE(s :: IO)
- function FOO_19322(Y::AbstractMatrix; frac::Float64=0.3, nbins::Int=100, n_sims::Int=100)
+ function FOO_19322(Y :: AbstractMatrix, frac :: Float64 = 0.3, nbins :: Int = 100, n_sims :: Int = 100)
- function Fail(test_type::Symbol, orig_expr, data, value, context, source::LineNumberNode, message_only::Bool, backtrace=nothing)
+ function Fail(test_type :: Symbol, orig_expr, data, value, context, source :: LineNumberNode, message_only :: Bool, backtrace = nothing)
- function FileMonitor(file::String)
+ function FileMonitor(file :: String)
- function FileRedirect(filename::String, append::Bool)
+ function FileRedirect(filename :: String, append :: Bool)
- function FinalizerEscapeTest()
+ function FinalizerEscapeTest
- function Float16(x::BigInt, ::RoundingMode{:Nearest})
+ function Float16(x :: BigInt, ??? :: RoundingMode{:, Nearest})
- function Float32(x::BigInt, ::RoundingMode{:Nearest})
+ function Float32(x :: BigInt, ??? :: RoundingMode{:, Nearest})
- function Float32(x::Int128)
+ function Float32(x :: Int128)
- function Float32(x::UInt128)
+ function Float32(x :: UInt128)
- function Float64(x::BigInt, ::RoundingMode{:Nearest})
+ function Float64(x :: BigInt, ??? :: RoundingMode{:, Nearest})
- function Float64(x::Int128)
+ function Float64(x :: Int128)
- function Float64(x::UInt128)
+ function Float64(x :: UInt128)
- function FolderMonitor(folder::String)
+ function FolderMonitor(folder :: String)
- function Foo4974(f; kwargs...)
+ function Foo4974(f, kwargs...)
- function Format(f::AbstractString)
+ function Format(f :: AbstractString)
- function FormatMessage(e::UInt32=GetLastError())
+ function FormatMessage(e :: UInt32 = GetLastError())
- function GC_Diff(new::GC_Num, old::GC_Num)
+ function GC_Diff(new :: GC_Num, old :: GC_Num)
- function GeneralizedSVD{T,S,Tr,C}(U, V, Q, a, b, k, l, R) where {T,S<:AbstractMatrix{T},Tr,C<:AbstractVector{Tr}}
+ function GeneralizedSVD{T,S,Tr,C}(U, V, Q, a, b, k, l, R) where T, S <: AbstractMatrix{T}, Tr, C <: AbstractVector{Tr}
- function GitAnnotated(repo::GitRepo, commit_id::GitHash)
+ function GitAnnotated(repo :: GitRepo, commit_id :: GitHash)
- function GitAnnotated(repo::GitRepo, committish::AbstractString)
+ function GitAnnotated(repo :: GitRepo, committish :: AbstractString)
- function GitAnnotated(repo::GitRepo, fh::FetchHead)
+ function GitAnnotated(repo :: GitRepo, fh :: FetchHead)
- function GitAnnotated(repo::GitRepo, ref::GitReference)
+ function GitAnnotated(repo :: GitRepo, ref :: GitReference)
- function GitBlame(repo::GitRepo, path::AbstractString; options::BlameOptions=BlameOptions())
+ function GitBlame(repo :: GitRepo, path :: AbstractString, options :: BlameOptions = BlameOptions())
- function GitBranchIter(repo::GitRepo, flags::Cint=Cint(Consts.BRANCH_LOCAL))
+ function GitBranchIter(repo :: GitRepo, flags :: Cint = Cint(Consts.BRANCH_LOCAL))
- function GitConfig(level::Consts.GIT_CONFIG = Consts.CONFIG_LEVEL_DEFAULT)
+ function GitConfig(level :: Consts.GIT_CONFIG = Consts.CONFIG_LEVEL_DEFAULT)
- function GitConfig(repo::GitRepo)
+ function GitConfig(repo :: GitRepo)
- function GitConfigIter(cfg::GitConfig)
+ function GitConfigIter(cfg :: GitConfig)
- function GitConfigIter(cfg::GitConfig, name::AbstractString)
+ function GitConfigIter(cfg :: GitConfig, name :: AbstractString)
- function GitConfigIter(cfg::GitConfig, name::AbstractString, value::Regex)
+ function GitConfigIter(cfg :: GitConfig, name :: AbstractString, value :: Regex)
- function GitConfigIter(cfg::GitConfig, name::Regex)
+ function GitConfigIter(cfg :: GitConfig, name :: Regex)
- function GitCredential(cfg::GitConfig, url::AbstractString)
+ function GitCredential(cfg :: GitConfig, url :: AbstractString)
- function GitCredential(user_pass_cred::UserPasswordCredential, url::AbstractString)
+ function GitCredential(user_pass_cred :: UserPasswordCredential, url :: AbstractString)
- function GitDescribeResult(repo::GitRepo; options::DescribeOptions=DescribeOptions())
+ function GitDescribeResult(repo :: GitRepo, options :: DescribeOptions = DescribeOptions())
- function GitDiffStats(diff::GitDiff)
+ function GitDiffStats(diff :: GitDiff)
- function GitError(err_code::Code)
+ function GitError(err_code :: Code)
- function GitHash(ann::GitAnnotated)
+ function GitHash(ann :: GitAnnotated)
- function GitHash(id::AbstractString)
+ function GitHash(id :: AbstractString)
- function GitHash(id::Array{UInt8,1})
+ function GitHash(id :: Array{UInt8, DependentType@85ede7b})
- function GitHash(obj::GitObject)
+ function GitHash(obj :: GitObject)
- function GitHash(ptr::Ptr{UInt8})
+ function GitHash(ptr :: Ptr{UInt8})
- function GitHash(ref::GitReference)
+ function GitHash(ref :: GitReference)
- function GitHash(repo::GitRepo, ref_name::AbstractString)
+ function GitHash(repo :: GitRepo, ref_name :: AbstractString)
- function GitIndex(repo::GitRepo)
+ function GitIndex(repo :: GitRepo)
- function GitObject(repo::GitRepo, ptr::Ptr{Cvoid})
+ function GitObject(repo :: GitRepo, ptr :: Ptr{Cvoid})
- function GitReference(repo::GitRepo, refname::AbstractString)
+ function GitReference(repo :: GitRepo, refname :: AbstractString)
- function GitRemote(repo::GitRepo, rmt_name::AbstractString, rmt_url::AbstractString)
+ function GitRemote(repo :: GitRepo, rmt_name :: AbstractString, rmt_url :: AbstractString)
- function GitRemote(repo::GitRepo, rmt_name::AbstractString, rmt_url::AbstractString, fetch_spec::AbstractString)
+ function GitRemote(repo :: GitRepo, rmt_name :: AbstractString, rmt_url :: AbstractString, fetch_spec :: AbstractString)
- function GitRemoteAnon(repo::GitRepo, url::AbstractString)
+ function GitRemoteAnon(repo :: GitRepo, url :: AbstractString)
- function GitRemoteDetached(url::AbstractString)
+ function GitRemoteDetached(url :: AbstractString)
- function GitRemoteHead(head::_GitRemoteHead)
+ function GitRemoteHead(head :: _GitRemoteHead)
- function GitRepo(path::AbstractString)
+ function GitRepo(path :: AbstractString)
- function GitRepoExt(path::AbstractString, flags::Cuint = Cuint(Consts.REPOSITORY_OPEN_DEFAULT))
+ function GitRepoExt(path :: AbstractString, flags :: Cuint = Cuint(Consts.REPOSITORY_OPEN_DEFAULT))
- function GitRevWalker(repo::GitRepo)
+ function GitRevWalker(repo :: GitRepo)
- function GitShortHash(buf::Buffer)
+ function GitShortHash(buf :: Buffer)
- function GitShortHash(id::AbstractString)
+ function GitShortHash(id :: AbstractString)
- function GitShortHash(obj::GitObject)
+ function GitShortHash(obj :: GitObject)
- function GitSignature(ptr::Ptr{SignatureStruct})
+ function GitSignature(ptr :: Ptr{SignatureStruct})
- function GitStatus(repo::GitRepo; status_opts=StatusOptions())
+ function GitStatus(repo :: GitRepo, status_opts = StatusOptions())
- function GitTree(c::GitCommit)
+ function GitTree(c :: GitCommit)
- function HAMT{K,V}(k::K, v) where {K, V}
+ function HAMT{K,V}(k :: K, v) where K, V
- function HTML(xs...)
+ function HTML(xs...)
- function Hermitian(A::AbstractMatrix, uplo::Symbol=:U)
+ function Hermitian(A :: AbstractMatrix, uplo :: Symbol = :U)
- function Hermitian{T,S}(data, uplo::Char) where {T,S<:AbstractMatrix{<:T}}
+ function Hermitian{T,S}(data, uplo :: Char) where T, S <: AbstractMatrix{??? <: T}
- function HessenbergQ{T,S,W,sym}(uplo::AbstractChar, factors, τ) where {T,S<:AbstractMatrix,W<:AbstractVector,sym}
+ function HessenbergQ{T,S,W,sym}(uplo :: AbstractChar, factors, τ) where T, S <: AbstractMatrix, W <: AbstractVector, sym
- function HostPlatform()
+ function HostPlatform
- function HostPlatform(p::AbstractPlatform)
+ function HostPlatform(p :: AbstractPlatform)
- function I13636.foo(y::Int;k::Int=1)
+ function I13636.foo(y :: Int, k :: Int = 1)
- function IOContext(io::IO, KV::Pair)
+ function IOContext(io :: IO, KV :: Pair)
- function IOContext(io::IO, dict::ImmutableDict)
+ function IOContext(io :: IO, dict :: ImmutableDict)
- function IOContext{IO_t}(io::IO_t, dict::ImmutableDict{Symbol, Any}) where IO_t<:IO
+ function IOContext{IO_t}(io :: IO_t, dict :: ImmutableDict{Symbol, Any}) where IO_t <: IO
- function IOStream(name::AbstractString, finalize::Bool)
+ function IOStream(name :: AbstractString, finalize :: Bool)
- function IPv4(a::Integer,b::Integer,c::Integer,d::Integer)
+ function IPv4(a :: Integer, b :: Integer, c :: Integer, d :: Integer)
- function IPv4(host::Integer)
+ function IPv4(host :: Integer)
- function IPv6(host::Integer)
+ function IPv6(host :: Integer)
- function IRCode()
+ function IRCode
- function IRCode(ir::IRCode, stmts::InstructionStream, cfg::CFG, new_nodes::NewNodeStream)
+ function IRCode(ir :: IRCode, stmts :: InstructionStream, cfg :: CFG, new_nodes :: NewNodeStream)
- function IRCode(stmts::InstructionStream, cfg::CFG, linetable::Vector{LineInfoNode}, argtypes::Vector{Any}, meta::Vector{Expr}, sptypes::Vector{VarState})
+ function IRCode(stmts :: InstructionStream, cfg :: CFG, linetable :: Vector{LineInfoNode}, argtypes :: Vector{Any}, meta :: Vector{Expr}, sptypes :: Vector{VarState})
- function IdDict(kv)
+ function IdDict(kv)
- function IdDict{K,V}(itr) where {K, V}
+ function IdDict{K,V}(itr) where K, V
- function IdDict{K,V}(pairs::Pair...) where {K, V}
+ function IdDict{K,V}(pairs :: Pair...) where K, V
- function IdOffsetRange(; values::AbstractUnitRange{<:Integer}, indices::AbstractUnitRange{<:Integer})
+ function IdOffsetRange(values :: AbstractUnitRange{??? <: Integer}, indices :: AbstractUnitRange{??? <: Integer})
- function IdOffsetRange{T,IdOffsetRange{T,I}}(r::IdOffsetRange{T,I}, offset::T) where {T<:Integer,I<:AbstractUnitRange{T}}
+ function IdOffsetRange{T,IdOffsetRange{T,I}}(r :: IdOffsetRange{T, I}, offset :: T) where T <: Integer, I <: AbstractUnitRange{T}
- function IdOffsetRange{T,I}(r::AbstractUnitRange, offset::Integer = 0) where {T<:Integer,I<:AbstractUnitRange{T}}
+ function IdOffsetRange{T,I}(r :: AbstractUnitRange, offset :: Integer = 0) where T <: Integer, I <: AbstractUnitRange{T}
- function IdOffsetRange{T,I}(r::I, offset::T) where {T<:Integer,I<:AbstractUnitRange{T}}
+ function IdOffsetRange{T,I}(r :: I, offset :: T) where T <: Integer, I <: AbstractUnitRange{T}
- function IdOffsetRange{T,I}(r::IdOffsetRange, offset::Integer = 0) where {T<:Integer,I<:AbstractUnitRange{T}}
+ function IdOffsetRange{T,I}(r :: IdOffsetRange, offset :: Integer = 0) where T <: Integer, I <: AbstractUnitRange{T}
- function IdOffsetRange{T}(r::AbstractUnitRange, offset::Integer = 0) where T<:Integer
+ function IdOffsetRange{T}(r :: AbstractUnitRange, offset :: Integer = 0) where T <: Integer
- function IdOffsetRange{T}(r::IdOffsetRange, offset::Integer = 0) where T<:Integer
+ function IdOffsetRange{T}(r :: IdOffsetRange, offset :: Integer = 0) where T <: Integer
- function IncrementalCompact(code::IRCode, allow_cfg_transforms::Bool=false)
+ function IncrementalCompact(code :: IRCode, allow_cfg_transforms :: Bool = false)
- function IncrementalCompact(code::IRCode, cfg_transform::CFGTransformState)
+ function IncrementalCompact(code :: IRCode, cfg_transform :: CFGTransformState)
- function IncrementalCompact(parent::IncrementalCompact, code::IRCode, result_offset)
+ function IncrementalCompact(parent :: IncrementalCompact, code :: IRCode, result_offset)
- function IndexStyle(::Type{ReinterpretArray{T,N,S,A,true}}) where {T,N,S,A<:AbstractArray{S}}
+ function IndexStyle(??? :: Type{ReinterpretArray{T, N, S, A, true}}) where T, N, S, A <: AbstractArray{S}
- function InferenceLoopState(@nospecialize(sig), @nospecialize(rt), effects::Effects)
+ function InferenceLoopState(sig, rt, effects :: Effects)
- function InferenceResult(linfo::MethodInstance, cache_argtypes::Vector{Any}, overridden_by_const::BitVector)
+ function InferenceResult(linfo :: MethodInstance, cache_argtypes :: Vector{Any}, overridden_by_const :: BitVector)
- function InferenceState(result::InferenceResult, cache_mode::UInt8, interp::AbstractInterpreter)
+ function InferenceState(result :: InferenceResult, cache_mode :: UInt8, interp :: AbstractInterpreter)
- function InliningCase(@nospecialize(sig), @nospecialize(item))
+ function InliningCase(sig, item)
- function InliningState(interp::AbstractInterpreter)
+ function InliningState(interp :: AbstractInterpreter)
- function InliningState(sv::InferenceState, interp::AbstractInterpreter)
+ function InliningState(sv :: InferenceState, interp :: AbstractInterpreter)
- function InliningTodo(mi::MethodInstance, ir::IRCode, effects::Effects)
+ function InliningTodo(mi :: MethodInstance, ir :: IRCode, effects :: Effects)
- function InstructionStream(len::Int)
+ function InstructionStream(len :: Int)
- function InterMustAlias(slot::Int, @nospecialize(vartyp), fldidx::Int, @nospecialize(fldtyp))
+ function InterMustAlias(slot :: Int, vartyp, fldidx :: Int, fldtyp)
- function InterTaint(@nospecialize(typ), slots::BitSet)
+ function InterTaint(typ, slots :: BitSet)
- function Issue51499CompletionDict(inner::Dict, leaf_func=identity)
+ function Issue51499CompletionDict(inner :: Dict, leaf_func = identity)
- function IteratorEltype(::Type{ProductIterator{T}}) where {T<:Tuple}
+ function IteratorEltype(??? :: Type{ProductIterator{T}}) where T <: Tuple
- function IteratorSize(::Type{PartitionIterator{T}}) where {T}
+ function IteratorSize(??? :: Type{PartitionIterator{T}}) where T
- function JLD2_hash(k::Ptr{UInt8}, n::Integer=length(k), initval::UInt32=UInt32(0))
+ function JLD2_hash(k :: Ptr{UInt8}, n :: Integer = length(k), initval :: UInt32 = UInt32(0))
- function JLJITGetJuliaOJIT()
+ function JLJITGetJuliaOJIT
- function JLJITGetTripleString(JIT)
+ function JLJITGetTripleString(JIT)
- function LBTConfig(config::lbt_config_t)
+ function LBTConfig(config :: lbt_config_t)
- function LBTLibraryInfo(lib_info::lbt_library_info_t, num_exported_symbols::UInt32)
+ function LBTLibraryInfo(lib_info :: lbt_library_info_t, num_exported_symbols :: UInt32)
- function LDLt{T,S}(data) where {T,S<:AbstractMatrix{T}}
+ function LDLt{T,S}(data) where T, S <: AbstractMatrix{T}
- function LQ{T,S,C}(factors, τ) where {T,S<:AbstractMatrix{T},C<:AbstractVector{T}}
+ function LQ{T,S,C}(factors, τ) where T, S <: AbstractMatrix{T}, C <: AbstractVector{T}
- function LU{T,S,P}(factors, ipiv, info) where {T, S<:AbstractMatrix{T}, P<:AbstractVector{<:Integer}}
+ function LU{T,S,P}(factors, ipiv, info) where T, S <: AbstractMatrix{T}, P <: AbstractVector{??? <: Integer}
- function LU{T}(F::LU) where T
+ function LU{T}(F :: LU) where T
- function Libc.getpid(p::Process)
+ function Libc.getpid(p :: Process)
- function LimitedAccuracy(@nospecialize(typ), causes::IdSet{InferenceState})
+ function LimitedAccuracy(typ, causes :: IdSet{InferenceState})
- function LinRange(start, stop, len::Integer)
+ function LinRange(start, stop, len :: Integer)
- function LinRange{T,L}(start, stop, len::Integer) where {T,L}
+ function LinRange{T,L}(start, stop, len :: Integer) where T, L
- function LinRange{T,L}(start::T, stop::T, len::L) where {T,L<:Integer}
+ function LinRange{T,L}(start :: T, stop :: T, len :: L) where T, L <: Integer
- function LinRange{T}(start, stop, len::Integer) where T
+ function LinRange{T}(start, stop, len :: Integer) where T
- function LineEdit.accept_result_newmode(hist::REPLHistoryProvider)
+ function LineEdit.accept_result_newmode(hist :: REPLHistoryProvider)
- function LineEditREPL(t,hascolor,prompt_color,input_color,answer_color,shell_color,help_color,history_file,in_shell,in_help,envcolors)
+ function LineEditREPL(t, hascolor, prompt_color, input_color, answer_color, shell_color, help_color, history_file, in_shell, in_help, envcolors)
- function LineNumberNode(l::Int, @nospecialize(f))
+ function LineNumberNode(l :: Int, f)
- function LinearAlgebra.rdiv!(B::AbstractMatrix, C::CholeskyPivoted)
+ function LinearAlgebra.rdiv!(B :: AbstractMatrix, C :: CholeskyPivoted)
- function Logging.shouldlog(logger::TestLogger, level, _module, group, id)
+ function Logging.shouldlog(logger :: TestLogger, level, _module, group, id)
- function MD(cfg::Config, xs...)
+ function MD(cfg :: Config, xs...)
- function Markdown.term(io::IO, msg::Message, columns)
+ function Markdown.term(io :: IO, msg :: Message, columns)
- function Matrix(A::Hermitian)
+ function Matrix(A :: Hermitian)
- function Matrix(A::Symmetric)
+ function Matrix(A :: Symmetric)
- function Matrix{T}(A::Bidiagonal) where T
+ function Matrix{T}(A :: Bidiagonal) where T
- function Matrix{T}(A::LowerTriangular) where T
+ function Matrix{T}(A :: LowerTriangular) where T
- function Matrix{T}(A::UnitLowerTriangular) where T
+ function Matrix{T}(A :: UnitLowerTriangular) where T
- function Matrix{T}(A::UnitUpperTriangular) where T
+ function Matrix{T}(A :: UnitUpperTriangular) where T
- function Matrix{T}(A::UpperTriangular) where T
+ function Matrix{T}(A :: UpperTriangular) where T
- function Matrix{T}(D::Diagonal) where {T}
+ function Matrix{T}(D :: Diagonal) where T
- function Matrix{T}(H::UpperHessenberg) where T
+ function Matrix{T}(H :: UpperHessenberg) where T
- function Matrix{T}(M::SymTridiagonal) where T
+ function Matrix{T}(M :: SymTridiagonal) where T
- function Matrix{T}(M::Tridiagonal) where {T}
+ function Matrix{T}(M :: Tridiagonal) where T
- function Matrix{T}(s::UniformScaling, dims::Dims{2}) where {T}
+ function Matrix{T}(s :: UniformScaling, dims :: Dims{DependentType@5674cd4d}) where T
- function MethodList(mt::Core.MethodTable)
+ function MethodList(mt :: Core.MethodTable)
- function MultiSelectMenu(options::Array{String,1}; pagesize::Int=10, selected=Int[], warn::Bool=true, kwargs...)
+ function MultiSelectMenu(options :: Array{String, DependentType@63961c42}, pagesize :: Int = 10, selected = Int[], warn :: Bool = true, kwargs...)
- function MustAlias(slot::Int, @nospecialize(vartyp), fldidx::Int, @nospecialize(fldtyp))
+ function MustAlias(slot :: Int, vartyp, fldidx :: Int, fldtyp)
- function MyMutableStruct(bar)
+ function MyMutableStruct(bar)
- function NamedTuple{names, T}(nt::NamedTuple) where {names, T <: Tuple}
+ function NamedTuple{names,T}(nt :: NamedTuple) where names, T <: Tuple
- function NamedTuple{names}(nt::NamedTuple) where {names}
+ function NamedTuple{names}(nt :: NamedTuple) where names
- function NewEntity(components::Type{T}...) where T<:Component
+ function NewEntity(components :: Type{T}...) where T <: Component
- function NewInstruction(@nospecialize(stmt), @nospecialize(type), line::Union{Int32,Nothing}=nothing)
+ function NewInstruction(stmt, type, line :: Union{Int32, Nothing} = nothing)
- function OneTo{T}(r::AbstractRange) where {T<:Integer}
+ function OneTo{T}(r :: AbstractRange) where T <: Integer
- function OneTo{T}(stop) where {T<:Integer}
+ function OneTo{T}(stop) where T <: Integer
- function OpaqueClosureCreateInfo(unspec::CallMeta)
+ function OpaqueClosureCreateInfo(unspec :: CallMeta)
- function OptimizationState(linfo::MethodInstance, interp::AbstractInterpreter)
+ function OptimizationState(linfo :: MethodInstance, interp :: AbstractInterpreter)
- function OptimizationState(linfo::MethodInstance, src::CodeInfo, interp::AbstractInterpreter)
+ function OptimizationState(linfo :: MethodInstance, src :: CodeInfo, interp :: AbstractInterpreter)
- function OptimizationState(sv::InferenceState, interp::AbstractInterpreter)
+ function OptimizationState(sv :: InferenceState, interp :: AbstractInterpreter)
- function Pager(text::AbstractString; pagesize::Int=10, kwargs...)
+ function Pager(text :: AbstractString, pagesize :: Int = 10, kwargs...)
- function Pair{A, B}(@nospecialize(a), @nospecialize(b)) where {A, B}
+ function Pair{A,B}(a, b) where A, B
- function Parser(str::String; filepath=nothing)
+ function Parser(str :: String, filepath = nothing)
- function PartialStruct(@nospecialize(typ), fields::Vector{Any})
+ function PartialStruct(typ, fields :: Vector{Any})
- function Pass(test_type::Symbol, orig_expr, data, thrown, source::Union{Nothing,LineNumberNode}=nothing, message_only::Bool=false)
+ function Pass(test_type :: Symbol, orig_expr, data, thrown, source :: Union{Nothing, LineNumberNode} = nothing, message_only :: Bool = false)
- function PermutedDimsArray(data::AbstractArray{T,N}, perm) where {T,N}
+ function PermutedDimsArray(data :: AbstractArray{T, N}, perm) where T, N
- function PermutedDimsArray{T,N,perm,iperm,AA}(data::AA) where {T,N,perm,iperm,AA<:AbstractArray}
+ function PermutedDimsArray{T,N,perm,iperm,AA}(data :: AA) where T, N, perm, iperm, AA <: AbstractArray
- function PersistentDict(dict::PersistentDict{K,V}, key, val) where {K,V}
+ function PersistentDict(dict :: PersistentDict{K, V}, key, val) where K, V
- function PersistentDict(kv::Pair, rest::Pair...)
+ function PersistentDict(kv :: Pair, rest :: Pair...)
- function PipeEndpoint()
+ function PipeEndpoint
- function PipeEndpoint(fd::OS_HANDLE)
+ function PipeEndpoint(fd :: OS_HANDLE)
- function PipeEndpoint(handle::Ptr{Cvoid}, status)
+ function PipeEndpoint(handle :: Ptr{Cvoid}, status)
- function PipeServer()
+ function PipeServer
- function PipeServer(handle::Ptr{Cvoid}, status)
+ function PipeServer(handle :: Ptr{Cvoid}, status)
- function PkgId(m::Module, name::String = String(nameof(moduleroot(m))))
+ function PkgId(m :: Module, name :: String = String(nameof(moduleroot(m))))
- function PollingFileWatcher(file::String, interval::Float64=5.007)
+ function PollingFileWatcher(file :: String, interval :: Float64 = 5.007)
- function PostOptAnalysisState(result::InferenceResult, ir::IRCode)
+ function PostOptAnalysisState(result :: InferenceResult, ir :: IRCode)
- function Process(cmd::Cmd, handle::Ptr{Cvoid})
+ function Process(cmd :: Cmd, handle :: Ptr{Cvoid})
- function ProcessChain()
+ function ProcessChain
- function Profile.print(io::IO, data::AllocResults, fmt::ProfileFormat, format::Symbol)
+ function Profile.print(io :: IO, data :: AllocResults, fmt :: ProfileFormat, format :: Symbol)
- function QRCompactWYQ{S,M,C}(factors, T) where {S,M<:AbstractMatrix{S},C<:AbstractMatrix{S}}
+ function QRCompactWYQ{S,M,C}(factors, T) where S, M <: AbstractMatrix{S}, C <: AbstractMatrix{S}
- function QRCompactWY{S,M,C}(factors, T) where {S,M<:AbstractMatrix{S},C<:AbstractMatrix{S}}
+ function QRCompactWY{S,M,C}(factors, T) where S, M <: AbstractMatrix{S}, C <: AbstractMatrix{S}
- function QRPackedQ{T,S,C}(factors, τ) where {T,S<:AbstractMatrix{T},C<:AbstractVector{T}}
+ function QRPackedQ{T,S,C}(factors, τ) where T, S <: AbstractMatrix{T}, C <: AbstractVector{T}
- function QRPivoted{T,S,C,P}(factors, τ, jpvt) where {T,S<:AbstractMatrix{T},C<:AbstractVector{T},P<:AbstractVector{<:Integer}}
+ function QRPivoted{T,S,C,P}(factors, τ, jpvt) where T, S <: AbstractMatrix{T}, C <: AbstractVector{T}, P <: AbstractVector{??? <: Integer}
- function QR{T,S,C}(factors, τ) where {T,S<:AbstractMatrix{T},C<:AbstractVector{T}}
+ function QR{T,S,C}(factors, τ) where T, S <: AbstractMatrix{T}, C <: AbstractVector{T}
- function RLEIterator(roots, blocks, defaultid)
+ function RLEIterator(roots, blocks, defaultid)
- function RadioMenu(options::Array{String,1}; pagesize::Int=10, warn::Bool=true, keybindings::Vector{Char}=Char[], kwargs...)
+ function RadioMenu(options :: Array{String, DependentType@65b54208}, pagesize :: Int = 10, warn :: Bool = true, keybindings :: Vector{Char} = Char[], kwargs...)
- function Random.rand!(S::SharedArray{T}) where T
+ function Random.rand!(S :: SharedArray{T}) where T
- function Random.randn!(S::SharedArray)
+ function Random.randn!(S :: SharedArray)
- function Rational{BigInt}(num::BigInt, den::BigInt)
+ function Rational{BigInt}(num :: BigInt, den :: BigInt)
- function Rational{BigInt}(x::AbstractFloat)
+ function Rational{BigInt}(x :: AbstractFloat)
- function Rational{T}(num::Integer, den::Integer) where T<:Integer
+ function Rational{T}(num :: Integer, den :: Integer) where T <: Integer
- function Rational{T}(x::AbstractFloat) where T<:Integer
+ function Rational{T}(x :: AbstractFloat) where T <: Integer
- function Rational{T}(x::Integer) where T<:Integer
+ function Rational{T}(x :: Integer) where T <: Integer
- function Rational{T}(x::Rational) where T<:Integer
+ function Rational{T}(x :: Rational) where T <: Integer
- function RawBigIntRoundingIncrementHelper(n::RawBigInt{T}, len::Int) where {T<:Unsigned}
+ function RawBigIntRoundingIncrementHelper(n :: RawBigInt{T}, len :: Int) where T <: Unsigned
- function RawBigIntRoundingIncrementHelper{T}(n::RawBigInt{T}, len::Int) where {T<:Unsigned}
+ function RawBigIntRoundingIncrementHelper{T}(n :: RawBigInt{T}, len :: Int) where T <: Unsigned
- function RawBigInt{T}(d::String, word_count::Int) where {T<:Unsigned}
+ function RawBigInt{T}(d :: String, word_count :: Int) where T <: Unsigned
- function Ref{P}(a::Array{T}) where P<:Union{Ptr,Cwstring,Cstring} where T
+ function Ref{P}(a :: Array{T}) where P <: Union{Ptr, Cwstring, Cstring} where T
- function Regex(pattern::AbstractString, flags::AbstractString)
+ function Regex(pattern :: AbstractString, flags :: AbstractString)
- function RemoteCallbacks(c::Callbacks)
+ function RemoteCallbacks(c :: Callbacks)
- function S29761_world(i)
+ function S29761_world(i)
- function SHA1(bytes::Vector{UInt8})
+ function SHA1(bytes :: Vector{UInt8})
- function SNCA!(domtree::GenericDomTree{IsPostDom}, blocks::Vector{BasicBlock}, max_pre::PreNumber) where {IsPostDom}
+ function SNCA!(domtree :: GenericDomTree{IsPostDom}, blocks :: Vector{BasicBlock}, max_pre :: PreNumber) where IsPostDom
- function SVD{T,Tr,M,C}(U, S, Vt) where {T,Tr,M<:AbstractArray{T},C<:AbstractVector{Tr}}
+ function SVD{T,Tr,M,C}(U, S, Vt) where T, Tr, M <: AbstractArray{T}, C <: AbstractVector{Tr}
- function Sampler(::Type{RNG}, ::Type{Pair{A, B}}, n::Repetition) where {RNG<:AbstractRNG, A, B}
+ function Sampler(??? :: Type{RNG}, ??? :: Type{Pair{A, B}}, n :: Repetition) where RNG <: AbstractRNG, A, B
- function Sampler(::Type{RNG}, ::Type{Tuple{Vararg{T, N}}}, n::Repetition) where {T, N, RNG<:AbstractRNG}
+ function Sampler(??? :: Type{RNG}, ??? :: Type{Tuple{Vararg{T, N}}}, n :: Repetition) where T, N, RNG <: AbstractRNG
- function Sampler(::Type{RNG}, ::Type{T}, n::Repetition) where {T<:Tuple, RNG<:AbstractRNG}
+ function Sampler(??? :: Type{RNG}, ??? :: Type{T}, n :: Repetition) where T <: Tuple, RNG <: AbstractRNG
- function Sampler(::Type{RNG}, t::Dict, ::Repetition) where RNG<:AbstractRNG
+ function Sampler(??? :: Type{RNG}, t :: Dict, ??? :: Repetition) where RNG <: AbstractRNG
- function Sampler(RNG::Type{<:AbstractRNG}, t::BitSet, n::Repetition)
+ function Sampler(RNG :: Type{??? <: AbstractRNG}, t :: BitSet, n :: Repetition)
- function Sampler11587()
+ function Sampler11587
- function SamplerBigFloat{I}(prec::Int) where I<:FloatInterval{BigFloat}
+ function SamplerBigFloat{I}(prec :: Int) where I <: FloatInterval{BigFloat}
- function SamplerRangeFast(r::AbstractUnitRange{T}, ::Type{U}) where {T,U}
+ function SamplerRangeFast(r :: AbstractUnitRange{T}, ??? :: Type{U}) where T, U
- function SamplerRangeInt(r::AbstractUnitRange{T}, ::Type{U}) where {T,U}
+ function SamplerRangeInt(r :: AbstractUnitRange{T}, ??? :: Type{U}) where T, U
- function SamplerRangeNDL(r::AbstractUnitRange{T}) where {T}
+ function SamplerRangeNDL(r :: AbstractUnitRange{T}) where T
- function Schur{CT}(S::Schur{<:Real}) where {CT<:Complex}
+ function Schur{CT}(S :: Schur{??? <: Real}) where CT <: Complex
- function Scope(parent::Union{Nothing, Scope}, key::ScopedValue{T}, value) where T
+ function Scope(parent :: Union{Nothing, Scope}, key :: ScopedValue{T}, value) where T
- function Scope(scope, pairs::Pair{<:ScopedValue}...)
+ function Scope(scope, pairs :: Pair{??? <: ScopedValue}...)
- function SecretBuffer!(d::AbstractVector{UInt8})
+ function SecretBuffer!(d :: AbstractVector{UInt8})
- function SecretBuffer(; sizehint=128)
+ function SecretBuffer(sizehint = 128)
- function SecretBuffer(str::String)
+ function SecretBuffer(str :: String)
- function Serialization.serialize(s::Serialization.AbstractSerializer, t::Broken)
+ function Serialization.serialize(s :: Serialization.AbstractSerializer, t :: Broken)
- function Serialization.serialize(s::Serialization.AbstractSerializer, t::Pass)
+ function Serialization.serialize(s :: Serialization.AbstractSerializer, t :: Pass)
- function Set{T}(s::KeySet{T, <:Dict{T}}) where {T}
+ function Set{T}(s :: KeySet{T, ??? <: Dict{T}}) where T
- function SharedArray(A::Array)
+ function SharedArray(A :: Array)
- function SharedArray{T,N}(d,p,r,sn,s) where {T,N}
+ function SharedArray{T,N}(d, p, r, sn, s) where T, N
- function SharedArray{T,N}(dims::Dims{N}; init=false, pids=Int[]) where {T,N}
+ function SharedArray{T,N}(dims :: Dims{N}, init = false, pids = Int[]) where T, N
- function SharedArray{TS,N}(A::Array{TA,N}) where {TS,TA,N}
+ function SharedArray{TS,N}(A :: Array{TA, N}) where TS, TA, N
- function SharedArray{T}(A::Array) where T
+ function SharedArray{T}(A :: Array) where T
- function Signature(name::AbstractString, email::AbstractString)
+ function Signature(name :: AbstractString, email :: AbstractString)
- function Signature(ptr::Ptr{SignatureStruct})
+ function Signature(ptr :: Ptr{SignatureStruct})
- function Signature(repo::GitRepo)
+ function Signature(repo :: GitRepo)
- function SignedMultiplicativeInverse{T}(d::T) where T<:Signed
+ function SignedMultiplicativeInverse{T}(d :: T) where T <: Signed
- function SizedArray{SZ,T,N,A}(data::AbstractArray{T,N}) where {SZ,T,N,A}
+ function SizedArray{SZ,T,N,A}(data :: AbstractArray{T, N}) where SZ, T, N, A
- function SizedArray{SZ}(data::AbstractArray{T,N}) where {SZ,T,N}
+ function SizedArray{SZ}(data :: AbstractArray{T, N}) where SZ, T, N
- function Slices(A::P, slicemap::SM, ax::AX) where {P,SM,AX}
+ function Slices(A :: P, slicemap :: SM, ax :: AX) where P, SM, AX
- function SometimesDefined()
+ function SometimesDefined
- function StepRangeLen{T,R,S,L}(ref::R, step::S, len::Integer, offset::Integer = 1) where {T,R,S,L}
+ function StepRangeLen{T,R,S,L}(ref :: R, step :: S, len :: Integer, offset :: Integer = 1) where T, R, S, L
- function StepRange{T,S}(start, step, stop) where {T,S}
+ function StepRange{T,S}(start, step, stop) where T, S
- function Strider(vec::AbstractArray{T}, strides::NTuple{N}, size::NTuple{N}) where {T,N}
+ function Strider(vec :: AbstractArray{T}, strides :: NTuple{N}, size :: NTuple{N}) where T, N
- function Strider{T}(strides::NTuple{N}, size::NTuple{N}) where {T,N}
+ function Strider{T}(strides :: NTuple{N}, size :: NTuple{N}) where T, N
- function String(a::AbstractVector{Char})
+ function String(a :: AbstractVector{Char})
- function String(chars::AbstractVector{<:AbstractChar})
+ function String(chars :: AbstractVector{??? <: AbstractChar})
- function String(l::LazyString)
+ function String(l :: LazyString)
- function String(s::SubString{String})
+ function String(s :: SubString{String})
- function SubArray(::IndexCartesian, parent::P, indices::I, ::NTuple{N,Any}) where {P,I,N}
+ function SubArray(??? :: IndexCartesian, parent :: P, indices :: I, ??? :: NTuple{N, Any}) where P, I, N
- function SubArray(::IndexLinear, parent::P, indices::I, ::NTuple{N,Any}) where {P,I,N}
+ function SubArray(??? :: IndexLinear, parent :: P, indices :: I, ??? :: NTuple{N, Any}) where P, I, N
- function SubArray(parent::AbstractArray, indices::Tuple)
+ function SubArray(parent :: AbstractArray, indices :: Tuple)
- function SubArray{T,N,P,I,L}(parent, indices, offset1, stride1) where {T,N,P,I,L}
+ function SubArray{T,N,P,I,L}(parent, indices, offset1, stride1) where T, N, P, I, L
- function SubString{T}(s::T, i::Int, j::Int) where T<:AbstractString
+ function SubString{T}(s :: T, i :: Int, j :: Int) where T <: AbstractString
- function SubString{T}(s::T, i::Int, j::Int, ::Val{:noshift}) where T<:AbstractString
+ function SubString{T}(s :: T, i :: Int, j :: Int, ??? :: Val{:, noshift}) where T <: AbstractString
- function SymTridiagonal(A::AbstractMatrix)
+ function SymTridiagonal(A :: AbstractMatrix)
- function SymTridiagonal(F::LDLt{<:Any, <:SymTridiagonal})
+ function SymTridiagonal(F :: LDLt{??? <: Any, ??? <: SymTridiagonal})
- function SymTridiagonal{T, V}(dv, ev) where {T, V<:AbstractVector{T}}
+ function SymTridiagonal{T,V}(dv, ev) where T, V <: AbstractVector{T}
- function SymTridiagonal{T}(M::Tridiagonal) where T
+ function SymTridiagonal{T}(M :: Tridiagonal) where T
- function SymTridiagonal{T}(dv::AbstractVector, ev::AbstractVector) where {T}
+ function SymTridiagonal{T}(dv :: AbstractVector, ev :: AbstractVector) where T
- function Symbol(a::Array{UInt8, 1})
+ function Symbol(a :: Array{UInt8, DependentType@1be6f5c3})
- function Symbol(s::String)
+ function Symbol(s :: String)
- function Symbol(s::SubString{String})
+ function Symbol(s :: SubString{String})
- function Symmetric(A::AbstractMatrix, uplo::Symbol=:U)
+ function Symmetric(A :: AbstractMatrix, uplo :: Symbol = :U)
- function Symmetric{T,S}(data, uplo::Char) where {T,S<:AbstractMatrix{<:T}}
+ function Symmetric{T,S}(data, uplo :: Char) where T, S <: AbstractMatrix{??? <: T}
- function T21972()
+ function T21972
- function T29145()
+ function T29145
- function TCPServer(; delay=true)
+ function TCPServer(delay = true)
- function TCPServer(handle::Ptr{Cvoid}, status)
+ function TCPServer(handle :: Ptr{Cvoid}, status)
- function TCPSocket(; delay=true)
+ function TCPSocket(delay = true)
- function TCPSocket(fd::OS_HANDLE)
+ function TCPSocket(fd :: OS_HANDLE)
- function TCPSocket(handle::Ptr{Cvoid}, status)
+ function TCPSocket(handle :: Ptr{Cvoid}, status)
- function TTY(fd::OS_HANDLE)
+ function TTY(fd :: OS_HANDLE)
- function TTY(handle::Ptr{Cvoid}, status)
+ function TTY(handle :: Ptr{Cvoid}, status)
- function Taint(@nospecialize(typ), slots::BitSet)
+ function Taint(typ, slots :: BitSet)
- function Take(xs::I, n::Integer) where {I}
+ function Take(xs :: I, n :: Integer) where I
- function TermInfo(raw::TermInfoRaw)
+ function TermInfo(raw :: TermInfoRaw)
- function TerminalMenus.keypress(menu::MultiSelectWithSkipMenu, key::UInt32)
+ function TerminalMenus.keypress(menu :: MultiSelectWithSkipMenu, key :: UInt32)
- function TerminalMenus.pick(menu::MultiSelectWithSkipMenu, cursor::Int)
+ function TerminalMenus.pick(menu :: MultiSelectWithSkipMenu, cursor :: Int)
- function TerminalMenus.writeLine(buf::IOBuffer, menu::MultiSelectMenu{<:Dict}, idx::Int, cursor::Bool)
+ function TerminalMenus.writeLine(buf :: IOBuffer, menu :: MultiSelectMenu{??? <: Dict}, idx :: Int, cursor :: Bool)
- function TerminalMenus.writeline(buf::IO, m::DynamicMenu, idx::Int, iscursor::Bool)
+ function TerminalMenus.writeline(buf :: IO, m :: DynamicMenu, idx :: Int, iscursor :: Bool)
- function TestDict(args...)
+ function TestDict(args...)
- function TestInnerConstructor(a::String)
+ function TestInnerConstructor(a :: String)
- function TestSet{T}() where T
+ function TestSet{T} where T
- function Threads.threadpool(t::Task)
+ function Threads.threadpool(t :: Task)
- function Time(func::Function, h, mi, s, ms, us; step::Period=Nanosecond(1), limit::Int=10000)
+ function Time(func :: Function, h, mi, s, ms, us, step :: Period = Nanosecond(1), limit :: Int = 10000)
- function Time(func::Function, h, mi, s, ms; step::Period=Microsecond(1), limit::Int=10000)
+ function Time(func :: Function, h, mi, s, ms, step :: Period = Microsecond(1), limit :: Int = 10000)
- function Time(func::Function, h, mi, s; step::Period=Millisecond(1), limit::Int=10000)
+ function Time(func :: Function, h, mi, s, step :: Period = Millisecond(1), limit :: Int = 10000)
- function Time(func::Function, h, mi=0; step::Period=Second(1), limit::Int=10000)
+ function Time(func :: Function, h, mi = 0, step :: Period = Second(1), limit :: Int = 10000)
- function Time(h::Int64, mi::Int64=0, s::Int64=0, ms::Int64=0, us::Int64=0, ns::Int64=0, ampm::AMPM=TWENTYFOURHOUR)
+ function Time(h :: Int64, mi :: Int64 = 0, s :: Int64 = 0, ms :: Int64 = 0, us :: Int64 = 0, ns :: Int64 = 0, ampm :: AMPM = TWENTYFOURHOUR)
- function Time(period::TimePeriod, periods::TimePeriod...)
+ function Time(period :: TimePeriod, periods :: TimePeriod...)
- function Time(t::AbstractString, format::AbstractString; locale::Locale=ENGLISH)
+ function Time(t :: AbstractString, format :: AbstractString, locale :: Locale = ENGLISH)
- function TimeVal()
+ function TimeVal
- function Timer(cb::Function, timeout; kwargs...)
+ function Timer(cb :: Function, timeout, kwargs...)
- function Timer(timeout::Real; interval::Real = 0.0)
+ function Timer(timeout :: Real, interval :: Real = 0.0)
- function TmStruct(t::Real)
+ function TmStruct(t :: Real)
- function Tridiagonal(F::LU{T,Tridiagonal{T,V}}) where {T,V}
+ function Tridiagonal(F :: LU{T, Tridiagonal{T, V}}) where T, V
- function Tridiagonal{T,V}(A::Tridiagonal) where {T,V<:AbstractVector{T}}
+ function Tridiagonal{T,V}(A :: Tridiagonal) where T, V <: AbstractVector{T}
- function Tridiagonal{T,V}(dl, d, du) where {T,V<:AbstractVector{T}}
+ function Tridiagonal{T,V}(dl, d, du) where T, V <: AbstractVector{T}
- function Tridiagonal{T,V}(dl, d, du, du2) where {T,V<:AbstractVector{T}}
+ function Tridiagonal{T,V}(dl, d, du, du2) where T, V <: AbstractVector{T}
- function Tridiagonal{T}(A::Bidiagonal) where T
+ function Tridiagonal{T}(A :: Bidiagonal) where T
- function Tridiagonal{T}(A::Tridiagonal) where {T}
+ function Tridiagonal{T}(A :: Tridiagonal) where T
- function Tridiagonal{T}(dl::AbstractVector, d::AbstractVector, du::AbstractVector) where {T}
+ function Tridiagonal{T}(dl :: AbstractVector, d :: AbstractVector, du :: AbstractVector) where T
- function Tridiagonal{T}(dl::AbstractVector, d::AbstractVector, du::AbstractVector, du2::AbstractVector) where {T}
+ function Tridiagonal{T}(dl :: AbstractVector, d :: AbstractVector, du :: AbstractVector, du2 :: AbstractVector) where T
- function TupleOrBottom(tt...)
+ function TupleOrBottom(tt...)
- function TwicePrecision{T}(nd::Tuple{Any,Any}) where {T}
+ function TwicePrecision{T}(nd :: Tuple{Any, Any}) where T
- function TwicePrecision{T}(nd::Tuple{I,I}, nb::Integer) where {T,I}
+ function TwicePrecision{T}(nd :: Tuple{I, I}, nb :: Integer) where T, I
- function TwicePrecision{T}(nd::Tuple{Integer,Integer}) where {T<:Union{Float16,Float32}}
+ function TwicePrecision{T}(nd :: Tuple{Integer, Integer}) where T <: Union{Float16, Float32}
- function TwicePrecision{T}(nd::Tuple{Integer,Integer}, nb::Integer) where T
+ function TwicePrecision{T}(nd :: Tuple{Integer, Integer}, nb :: Integer) where T
- function TwicePrecision{T}(x) where {T}
+ function TwicePrecision{T}(x) where T
- function TwoPhaseDefUseMap(nssas::Int)
+ function TwoPhaseDefUseMap(nssas :: Int)
- function UDPSocket()
+ function UDPSocket
- function UDPSocket(handle::Ptr{Cvoid}, status)
+ function UDPSocket(handle :: Ptr{Cvoid}, status)
- function UndefVarError_hint(io::IO, ex::UndefVarError)
+ function UndefVarError_hint(io :: IO, ex :: UndefVarError)
- function UnitRange(start, stop)
+ function UnitRange(start, stop)
- function UnsignedMultiplicativeInverse{T}(d::T) where T<:Unsigned
+ function UnsignedMultiplicativeInverse{T}(d :: T) where T <: Unsigned
- function UpperHessenberg{T,S}(data) where {T,S<:AbstractMatrix{T}}
+ function UpperHessenberg{T,S}(data) where T, S <: AbstractMatrix{T}
- function UserPasswordCredential(user::AbstractString="", pass::Union{AbstractString, Base.SecretBuffer}="")
+ function UserPasswordCredential(user :: AbstractString = "", pass :: Union{AbstractString, Base.SecretBuffer} = "")
- function UvTestIdle()
+ function UvTestIdle
- function V1()
+ function V1
- function VNorNothing(d::Dict, key)
+ function VNorNothing(d :: Dict, key)
- function WeVirtualProtectThisToRWX(x, y)
+ function WeVirtualProtectThisToRWX(x, y)
- function WeakKeyDict(kv)
+ function WeakKeyDict(kv)
- function WeakKeyDict{K,V}() where V where K
+ function WeakKeyDict{K,V} where V where K
- function WeakKeyDict{K,V}(kv) where V where K
+ function WeakKeyDict{K,V}(kv) where V where K
- function WeakKeyDict{K,V}(ps::Pair...) where V where K
+ function WeakKeyDict{K,V}(ps :: Pair...) where V where K
- function WithoutMissingVector(data; unsafe=false)
+ function WithoutMissingVector(data, unsafe = false)
- function \(B::Bidiagonal, D::Diagonal)
+ function \(B :: Bidiagonal, D :: Diagonal)
- function \(B::Bidiagonal, H::UpperHessenberg)
+ function \(B :: Bidiagonal, H :: UpperHessenberg)
- function \(D::Diagonal, B::AbstractVector)
+ function \(D :: Diagonal, B :: AbstractVector)
- function \(U::UnitUpperTriangular, H::UpperHessenberg)
+ function \(U :: UnitUpperTriangular, H :: UpperHessenberg)
- function \(U::UpperTriangular, H::UpperHessenberg)
+ function \(U :: UpperTriangular, H :: UpperHessenberg)
- function ^(A::Hermitian, p::Integer)
+ function ^(A :: Hermitian, p :: Integer)
- function ^(A::Hermitian{T}, p::Real) where T
+ function ^(A :: Hermitian{T}, p :: Real) where T
- function ^(A::Symmetric{<:Complex}, p::Real)
+ function ^(A :: Symmetric{??? <: Complex}, p :: Real)
- function ^(A::Symmetric{<:Real}, p::Real)
+ function ^(A :: Symmetric{??? <: Real}, p :: Real)
- function ^(x::BigFloat, y::BigFloat)
+ function ^(x :: BigFloat, y :: BigFloat)
- function ^(x::BigFloat, y::BigInt)
+ function ^(x :: BigFloat, y :: BigInt)
- function ^(x::BigFloat, y::ClongMax)
+ function ^(x :: BigFloat, y :: ClongMax)
- function ^(x::BigFloat, y::CulongMax)
+ function ^(x :: BigFloat, y :: CulongMax)
- function ^(x::Float32, n::Integer)
+ function ^(x :: Float32, n :: Integer)
- function ^(x::Rational, n::Integer)
+ function ^(x :: Rational, n :: Integer)
- function ^(z::Complex{<:Rational}, n::Integer)
+ function ^(z :: Complex{??? <: Rational}, n :: Integer)
- function ^(z::Complex{T}, p::S) where {T<:Real,S<:Real}
+ function ^(z :: Complex{T}, p :: S) where T <: Real, S <: Real
- function ^(z::T, p::Complex{S}) where {T<:Real,S<:Real}
+ function ^(z :: T, p :: Complex{S}) where T <: Real, S <: Real
- function _CaptureInCtor(list_file::AbstractString="")
+ function _CaptureInCtor(list_file :: AbstractString = "")
- function _FDWatcher(fd::RawFD, readable::Bool, writable::Bool)
+ function _FDWatcher(fd :: RawFD, readable :: Bool, writable :: Bool)
- function _Set(itr, ::EltypeUnknown)
+ function _Set(itr, ??? :: EltypeUnknown)
- function _Task(@nospecialize(f), reserved_stack::Int, completion_future)
+ function _Task(f, reserved_stack :: Int, completion_future)
- function _UVError(pfx::AbstractString, code::Integer)
+ function _UVError(pfx :: AbstractString, code :: Integer)
- function _UVError(pfx::AbstractString, code::Integer, sfxs::AbstractString...)
+ function _UVError(pfx :: AbstractString, code :: Integer, sfxs :: AbstractString...)
- function __atreplinit(repl)
+ function __atreplinit(repl)
- function __binrepr(m::MIME, x, context)
+ function __binrepr(m :: MIME, x, context)
- function __cat_offset!(A, shape, catdims, offsets, x, X...)
+ function __cat_offset!(A, shape, catdims, offsets, x, X...)
- function __cat_offset1!(A, shape, catdims, offsets, x)
+ function __cat_offset1!(A, shape, catdims, offsets, x)
- function __convertSRL(::Type{StepRangeLen{T,R,S,L}}, r::AbstractRange{U}) where {T,R,S,L,U}
+ function __convertSRL(??? :: Type{StepRangeLen{T, R, S, L}}, r :: AbstractRange{U}) where T, R, S, L, U
- function __convertSRL(::Type{StepRangeLen{T,R,S,L}}, r::StepRangeLen{U}) where {T,R,S,L,U}
+ function __convertSRL(??? :: Type{StepRangeLen{T, R, S, L}}, r :: StepRangeLen{U}) where T, R, S, L, U
- function __current_ast_transforms(backend)
+ function __current_ast_transforms(backend)
- function __doc__!(source, mod, meta, def, define::Bool)
+ function __doc__!(source, mod, meta, def, define :: Bool)
- function __dot__(x::Expr)
+ function __dot__(x :: Expr)
- function __f_isa_arg_1()
+ function __f_isa_arg_1
- function __inbounds_setindex!(A::Array{T}, x, i1::Int, i2::Int, I::Int...) where {T}
+ function __inbounds_setindex!(A :: Array{T}, x, i1 :: Int, i2 :: Int, I :: Int...) where T
- function __inbounds_setindex!(A::Array{T}, x, i::Int) where {T}
+ function __inbounds_setindex!(A :: Array{T}, x, i :: Int) where T
- function __inbounds_setindex!(A::Memory{T}, x, i1::Int) where {T}
+ function __inbounds_setindex!(A :: Memory{T}, x, i1 :: Int) where T
- function __inbounds_setindex!(A::Memory{T}, x, i1::Int, i2::Int, I::Int...) where {T}
+ function __inbounds_setindex!(A :: Memory{T}, x, i1 :: Int, i2 :: Int, I :: Int...) where T
- function __init__()
+ function __init__
- function __init_build()
+ function __init_build
- function __init_dsymutil_path()
+ function __init_dsymutil_path
- function __init_lld_path()
+ function __init_lld_path
- function __limit_type_size(@nospecialize(t), @nospecialize(c), sources::SimpleVector, depth::Int, allowed_tuplelen::Int)
+ function __limit_type_size(t, c, sources :: SimpleVector, depth :: Int, allowed_tuplelen :: Int)
- function __muldiag!(out, A, D::Diagonal, _add::MulAddMul{ais1,bis0}) where {ais1,bis0}
+ function __muldiag!(out, A, D :: Diagonal, _add :: MulAddMul{ais1, bis0}) where ais1, bis0
- function __muldiag!(out, D1::Diagonal, D2::Diagonal, _add::MulAddMul{ais1,bis0}) where {ais1,bis0}
+ function __muldiag!(out, D1 :: Diagonal, D2 :: Diagonal, _add :: MulAddMul{ais1, bis0}) where ais1, bis0
- function __muldiag!(out, D::Diagonal, B, _add::MulAddMul{ais1,bis0}) where {ais1,bis0}
+ function __muldiag!(out, D :: Diagonal, B, _add :: MulAddMul{ais1, bis0}) where ais1, bis0
- function __muldiag!(out::Diagonal, D1::Diagonal, D2::Diagonal, _add::MulAddMul{ais1,bis0}) where {ais1,bis0}
+ function __muldiag!(out :: Diagonal, D1 :: Diagonal, D2 :: Diagonal, _add :: MulAddMul{ais1, bis0}) where ais1, bis0
- function __precompile__(isprecompilable::Bool=true)
+ function __precompile__(isprecompilable :: Bool = true)
- function __require(into::Module, mod::Symbol)
+ function __require(into :: Module, mod :: Symbol)
- function __require_prelocked(uuidkey::PkgId, env=nothing)
+ function __require_prelocked(uuidkey :: PkgId, env = nothing)
- function __reshape(p::Tuple{AbstractArray,IndexLinear}, dims::Dims)
+ function __reshape(p :: Tuple{AbstractArray, IndexLinear}, dims :: Dims)
- function __reshape(p::Tuple{AbstractArray,IndexStyle}, dims::Dims)
+ function __reshape(p :: Tuple{AbstractArray, IndexStyle}, dims :: Dims)
- function __reshape(p::Tuple{AbstractArray{<:Any,0},IndexCartesian}, dims::Dims)
+ function __reshape(p :: Tuple{AbstractArray{??? <: Any, DependentType@6b884d57}, IndexCartesian}, dims :: Dims)
- function _accumulate!(op, B, A, dims::Integer, init::Union{Nothing, Some})
+ function _accumulate!(op, B, A, dims :: Integer, init :: Union{Nothing, Some})
- function _accumulate!(op, B, A, dims::Nothing, init::Union{Nothing, Some})
+ function _accumulate!(op, B, A, dims :: Nothing, init :: Union{Nothing, Some})
- function _accumulate!(op, B, A::AbstractVector, dims::Nothing, init::Nothing)
+ function _accumulate!(op, B, A :: AbstractVector, dims :: Nothing, init :: Nothing)
- function _accumulate!(op, B, A::AbstractVector, dims::Nothing, init::Some)
+ function _accumulate!(op, B, A :: AbstractVector, dims :: Nothing, init :: Some)
- function _accumulate1!(op, B, v1, A::AbstractVector, dim::Integer)
+ function _accumulate1!(op, B, v1, A :: AbstractVector, dim :: Integer)
- function _accumulate_pairwise!(op::Op, c::AbstractVector{T}, v::AbstractVector, s, i1, n)::T where {T,Op}
+ function _accumulate_pairwise!(op :: Op, c :: AbstractVector{T}, v :: AbstractVector, s, i1, n) where T, Op
- function _accumulaten!(op, B, A, R1, ind, R2, init::Nothing)
+ function _accumulaten!(op, B, A, R1, ind, R2, init :: Nothing)
- function _accumulaten!(op, B, A, R1, ind, R2, init::Some)
+ function _accumulaten!(op, B, A, R1, ind, R2, init :: Some)
- function _advance(@nospecialize(stmt), op)
+ function _advance(stmt, op)
- function _advance_F!(r::MersenneTwister, adv_vals, idxF, work)
+ function _advance_F!(r :: MersenneTwister, adv_vals, idxF, work)
- function _advance_I!(r::MersenneTwister, adv_ints, idxI, work)
+ function _advance_I!(r :: MersenneTwister, adv_ints, idxI, work)
- function _advance_bsbmp!(bsbmp::BitSetBoundedMinPrioritySet)
+ function _advance_bsbmp!(bsbmp :: BitSetBoundedMinPrioritySet)
- function _advance_n!(r::MersenneTwister, n::Int64, work::Vector{Float64})
+ function _advance_n!(r :: MersenneTwister, n :: Int64, work :: Vector{Float64})
- function _advance_to!(r::MersenneTwister, adv::Int64, work)
+ function _advance_to!(r :: MersenneTwister, adv :: Int64, work)
- function _all(@nospecialize(f), a)
+ function _all(f, a)
- function _all_match_first(f::F, inds, A, B...) where F<:Function
+ function _all_match_first(f :: F, inds, A, B...) where F <: Function
- function _alloftype(ofdesiredtype, accumulated, ::Tuple{}, others...)
+ function _alloftype(ofdesiredtype, accumulated, ??? :: Tuple, others...)
- function _alloftype(ofdesiredtype, accumulated, d, others...)
+ function _alloftype(ofdesiredtype, accumulated, d, others...)
- function _alloftype(ofdesiredtype::Tuple{Vararg{D}}, accumulated, d::Tuple{D,Vararg}, others...) where D
+ function _alloftype(ofdesiredtype :: Tuple{Vararg{D}}, accumulated, d :: Tuple{D, Vararg}, others...) where D
- function _annotatedmatch(m::RegexMatch{S}, str::AnnotatedString{S}) where {S<:AbstractString}
+ function _annotatedmatch(m :: RegexMatch{S}, str :: AnnotatedString{S}) where S <: AbstractString
- function _any(@nospecialize(f), a)
+ function _any(f, a)
- function _append!(a::AbstractVector, ::IteratorSize, iter)
+ function _append!(a :: AbstractVector, ??? :: IteratorSize, iter)
- function _append!(a::AbstractVector, ::Union{HasLength,HasShape}, iter)
+ function _append!(a :: AbstractVector, ??? :: Union{HasLength, HasShape}, iter)
- function _apply_permutation!(F::QRPivoted, B::AbstractVecOrMat)
+ function _apply_permutation!(F :: QRPivoted, B :: AbstractVecOrMat)
- function _approx_iter_type(itrT::Type, vstate::Type)
+ function _approx_iter_type(itrT :: Type, vstate :: Type)
- function _artifact_str(__module__, artifacts_toml, name, path_tail, artifact_dict, hash, platform, @nospecialize(lazyartifacts))
+ function _artifact_str(__module__, artifacts_toml, name, path_tail, artifact_dict, hash, platform, lazyartifacts)
- function _assigns_and_captures_arg(a)
+ function _assigns_and_captures_arg(a)
- function _atexit(exitcode::Cint)
+ function _atexit(exitcode :: Cint)
- function _atexit_tests_gen_cmd_eval(expr::String)
+ function _atexit_tests_gen_cmd_eval(expr :: String)
- function _atexit_tests_gen_cmd_script(temp_dir::String, expr::String)
+ function _atexit_tests_gen_cmd_script(temp_dir :: String, expr :: String)
- function _atthreads_dynamic_dynamic_schedule()
+ function _atthreads_dynamic_dynamic_schedule
- function _atthreads_dynamic_schedule(n)
+ function _atthreads_dynamic_schedule(n)
- function _atthreads_dynamic_with_error(a)
+ function _atthreads_dynamic_with_error(a)
- function _atthreads_static_dynamic_schedule()
+ function _atthreads_static_dynamic_schedule
- function _atthreads_static_schedule(n)
+ function _atthreads_static_schedule(n)
- function _atthreads_with_error(a, err)
+ function _atthreads_with_error(a, err)
- function _base(base::Integer, x::Integer, pad::Int, neg::Bool)
+ function _base(base :: Integer, x :: Integer, pad :: Int, neg :: Bool)
- function _bcs(shape::Tuple, newshape::Tuple)
+ function _bcs(shape :: Tuple, newshape :: Tuple)
- function _bind(sock::UDPSocket, host::Union{IPv4, IPv6}, port::UInt16, flags::UInt32=UInt32(0))
+ function _bind(sock :: UDPSocket, host :: Union{IPv4, IPv6}, port :: UInt16, flags :: UInt32 = UInt32(0))
- function _bind(sock::Union{TCPServer, TCPSocket}, host::Union{IPv4, IPv6}, port::UInt16, flags::UInt32=UInt32(0))
+ function _bind(sock :: Union{TCPServer, TCPSocket}, host :: Union{IPv4, IPv6}, port :: UInt16, flags :: UInt32 = UInt32(0))
- function _bitreshape(B::BitArray, dims::NTuple{N,Int}) where N
+ function _bitreshape(B :: BitArray, dims :: NTuple{N, Int}) where N
- function _bits_findnext(b::Bits, start::Int)
+ function _bits_findnext(b :: Bits, start :: Int)
- function _bits_findprev(b::Bits, start::Int)
+ function _bits_findprev(b :: Bits, start :: Int)
- function _bits_getindex(b::Bits, n::Int, offset::Int)
+ function _bits_getindex(b :: Bits, n :: Int, offset :: Int)
- function _bool_check(::Type{Bool}, r, offset)
+ function _bool_check(??? :: Type{Bool}, r, offset)
- function _bufcmp(data1::Memory{UInt8}, data2::Memory{UInt8}, sz::Int)
+ function _bufcmp(data1 :: Memory{UInt8}, data2 :: Memory{UInt8}, sz :: Int)
- function _byte_string_classify_nonascii(bytes::AbstractVector{UInt8}, first::Int, last::Int)
+ function _byte_string_classify_nonascii(bytes :: AbstractVector{UInt8}, first :: Int, last :: Int)
- function _cat(dims::Int, X::Union{BitArray, Bool}...)
+ function _cat(dims :: Int, X :: Union{BitArray, Bool}...)
- function _ccallable(rt::Type, sigt::Type)
+ function _ccallable(rt :: Type, sigt :: Type)
- function _check0(a::Vector{UInt64}, b::Int, e::Int)
+ function _check0(a :: Vector{UInt64}, b :: Int, e :: Int)
- function _check_bitarray_consistency(B::BitArray{N}) where N
+ function _check_bitarray_consistency(B :: BitArray{N}) where N
- function _check_length_split_rest(len, n)
+ function _check_length_split_rest(len, n)
- function _check_mutable(@nospecialize(o)) @noinline
+ function _check_mutable(o)
- function _check_testset(testsettype, testsetname)
+ @@noinlinefunction _check_testset(testsettype, testsetname)
- function _checked_mul_dims(m::Int, d::Int...)
+ function _checked_mul_dims(m :: Int, d :: Int...)
- function _checked_mul_dims(m::Int, n::Int)
+ function _checked_mul_dims(m :: Int, n :: Int)
- function _checkindices(N::Integer, indices, label)
+ function _checkindices(N :: Integer, indices, label)
- function _chol!(A::AbstractMatrix, ::Type{LowerTriangular})
+ function _chol!(A :: AbstractMatrix, ??? :: Type{LowerTriangular})
- function _chol!(A::AbstractMatrix, ::Type{UpperTriangular})
+ function _chol!(A :: AbstractMatrix, ??? :: Type{UpperTriangular})
- function _chol!(A::StridedMatrix{<:BlasFloat}, ::Type{LowerTriangular})
+ function _chol!(A :: StridedMatrix{??? <: BlasFloat}, ??? :: Type{LowerTriangular})
- function _chol!(A::StridedMatrix{<:BlasFloat}, ::Type{UpperTriangular})
+ function _chol!(A :: StridedMatrix{??? <: BlasFloat}, ??? :: Type{UpperTriangular})
- function _chol!(x::Number, _)
+ function _chol!(x :: Number, _)
- function _circcopy!(dest, rdest, indsdest, src, rsrc, indssrc)
+ function _circcopy!(dest, rdest, indsdest, src, rsrc, indssrc)
- function _circshift!(dest, rdest, src, rsrc, inds, shiftamt)
+ function _circshift!(dest, rdest, src, rsrc, inds, shiftamt)
- function _circshift_int!(dest::BitVector, src::BitVector, i::Int)
+ function _circshift_int!(dest :: BitVector, src :: BitVector, i :: Int)
- function _cleanup_locked(h::WeakKeyDict)
+ function _cleanup_locked(h :: WeakKeyDict)
- function _clear_config_with(f)
+ function _clear_config_with(f)
- function _clear_input_area(terminal::AbstractTerminal, state::InputAreaState)
+ function _clear_input_area(terminal :: AbstractTerminal, state :: InputAreaState)
- function _cmp_(x::Union{Int64,UInt64}, y::Float64)
+ function _cmp_(x :: Union{Int64, UInt64}, y :: Float64)
- function _collapse_repeated_frames(trace)
+ function _collapse_repeated_frames(trace)
- function _collect(::Type{T}, itr, isz::SizeUnknown) where T
+ function _collect(??? :: Type{T}, itr, isz :: SizeUnknown) where T
- function _collect(c, itr, ::EltypeUnknown, isz::Union{HasLength,HasShape})
+ function _collect(c, itr, ??? :: EltypeUnknown, isz :: Union{HasLength, HasShape})
- function _collect(cont, itr, ::HasEltype, isz::SizeUnknown)
+ function _collect(cont, itr, ??? :: HasEltype, isz :: SizeUnknown)
- function _collect_indices(indsA, A)
+ function _collect_indices(indsA, A)
- function _colon(start::T, step, stop::T) where T
+ function _colon(start :: T, step, stop :: T) where T
- function _complete_methods(ex_org::Expr, context_module::Module, shift::Bool)
+ function _complete_methods(ex_org :: Expr, context_module :: Module, shift :: Bool)
- function _compute_eltype(@nospecialize t)
+ function _compute_eltype(t)
- function _console_mode()
+ function _console_mode
- function _const_sizeof(@nospecialize(x))
+ function _const_sizeof(x)
- function _convertSRL(::Type{StepRangeLen{T,R,S,L}}, r::AbstractRange{<:Integer}) where {T,R,S,L}
+ function _convertSRL(??? :: Type{StepRangeLen{T, R, S, L}}, r :: AbstractRange{??? <: Integer}) where T, R, S, L
- function _convertSRL(::Type{StepRangeLen{T,R,S,L}}, r::AbstractRange{U}) where {T,R,S,L,U}
+ function _convertSRL(??? :: Type{StepRangeLen{T, R, S, L}}, r :: AbstractRange{U}) where T, R, S, L, U
- function _convertSRL(::Type{StepRangeLen{T,R,S,L}}, r::StepRangeLen{<:Integer}) where {T,R,S,L}
+ function _convertSRL(??? :: Type{StepRangeLen{T, R, S, L}}, r :: StepRangeLen{??? <: Integer}) where T, R, S, L
- function _convert_rounding(::Type{T}, x::Real, r::RoundingMode{:Down}) where T<:AbstractFloat
+ function _convert_rounding(??? :: Type{T}, x :: Real, r :: RoundingMode{:, Down}) where T <: AbstractFloat
- function _convert_rounding(::Type{T}, x::Real, r::RoundingMode{:ToZero}) where T<:AbstractFloat
+ function _convert_rounding(??? :: Type{T}, x :: Real, r :: RoundingMode{:, ToZero}) where T <: AbstractFloat
- function _convert_rounding(::Type{T}, x::Real, r::RoundingMode{:Up}) where T<:AbstractFloat
+ function _convert_rounding(??? :: Type{T}, x :: Real, r :: RoundingMode{:, Up}) where T <: AbstractFloat
- function _copy!(P::PermutedDimsArray{T,N,perm}, src) where {T,N,perm}
+ function _copy!(P :: PermutedDimsArray{T, N, perm}, src) where T, N, perm
- function _copy_item!(a::Vector, p, q)
+ function _copy_item!(a :: Vector, p, q)
- function _copyfrompacked!(ptr_out::Ptr{Out}, ptr_in::Ptr{In}) where {Out, In}
+ function _copyfrompacked!(ptr_out :: Ptr{Out}, ptr_in :: Ptr{In}) where Out, In
- function _copyline(out::IO, io::GenericIOBuffer; keep::Bool=false)
+ function _copyline(out :: IO, io :: GenericIOBuffer, keep :: Bool = false)
- function _copyto_bitarray!(B::BitArray, A::AbstractArray)
+ function _copyto_bitarray!(B :: BitArray, A :: AbstractArray)
- function _copyto_impl!(dest::Union{Array,Memory}, doffs::Integer, src::Union{Array,Memory}, soffs::Integer, n::Integer)
+ function _copyto_impl!(dest :: Union{Array, Memory}, doffs :: Integer, src :: Union{Array, Memory}, soffs :: Integer, n :: Integer)
- function _copyto_int!(dest::BitArray, doffs::Int, src::Union{BitArray,Array}, soffs::Int, n::Int)
+ function _copyto_int!(dest :: BitArray, doffs :: Int, src :: Union{BitArray, Array}, soffs :: Int, n :: Int)
- function _copytopacked!(ptr_out::Ptr{Out}, ptr_in::Ptr{In}) where {Out, In}
+ function _copytopacked!(ptr_out :: Ptr{Out}, ptr_in :: Ptr{In}) where Out, In
- function _copyuntil(out, s::IO, delim::T, keep::Bool) where T
+ function _copyuntil(out, s :: IO, delim :: T, keep :: Bool) where T
- function _cosc(x::Number)
+ function _cosc(x :: Number)
- function _count_added_node!(compact::IncrementalCompact, @nospecialize(val))
+ function _count_added_node!(compact :: IncrementalCompact, val)
- function _cpow(z::Union{T,Complex{T}}, p::Union{T,Complex{T}}) where T
+ function _cpow(z :: Union{T, Complex{T}}, p :: Union{T, Complex{T}}) where T
- function _cpu_summary(io::IO, cpu::AbstractVector{CPUinfo}, i, j)
+ function _cpu_summary(io :: IO, cpu :: AbstractVector{CPUinfo}, i, j)
- function _crc32c(io::IO, nb::Integer, crc::UInt32=0x00000000)
+ function _crc32c(io :: IO, nb :: Integer, crc :: UInt32 = 0x00000000)
- function _crc32c(io::IOBuffer, nb::Integer, crc::UInt32=0x00000000)
+ function _crc32c(io :: IOBuffer, nb :: Integer, crc :: UInt32 = 0x00000000)
- function _crc32c(s::Union{String, SubString{String}}, crc::UInt32=0x00000000)
+ function _crc32c(s :: Union{String, SubString{String}}, crc :: UInt32 = 0x00000000)
- function _cumsum!(out::AbstractArray, v, dim, ::ArithmeticUnknown)
+ function _cumsum!(out :: AbstractArray, v, dim, ??? :: ArithmeticUnknown)
- function _cumsum!(out::AbstractArray{T}, v, dim, ::ArithmeticRounds) where {T}
+ function _cumsum!(out :: AbstractArray{T}, v, dim, ??? :: ArithmeticRounds) where T
- function _cumsum!(out::AbstractArray{T}, v, dim, ::ArithmeticStyle) where {T}
+ function _cumsum!(out :: AbstractArray{T}, v, dim, ??? :: ArithmeticStyle) where T
- function _decompose_char!(codepoint::Union{Integer,Char}, dest::Vector{UInt32}, options::Integer)
+ function _decompose_char!(codepoint :: Union{Integer, Char}, dest :: Vector{UInt32}, options :: Integer)
- function _deepcopy_memory_t(@nospecialize(x::Memory), T, stackdict::IdDict)
+ function _deepcopy_memory_t(x :: Memory, T, stackdict :: IdDict)
- function _define_range_op(@nospecialize f)
+ function _define_range_op(f)
- function _delete!(h::Dict{K,V}, index) where {K,V}
+ function _delete!(h :: Dict{K, V}, index) where K, V
- function _deleteat!(B::BitVector, i::Int)
+ function _deleteat!(B :: BitVector, i :: Int)
- function _deleteat!(a::Vector, i::Integer, delta::Integer)
+ function _deleteat!(a :: Vector, i :: Integer, delta :: Integer)
- function _deleteat!(a::Vector, inds, dltd=Nowhere())
+ function _deleteat!(a :: Vector, inds, dltd = Nowhere())
- function _deletebeg!(a::Vector, delta::Integer)
+ function _deletebeg!(a :: Vector, delta :: Integer)
- function _deleteend!(a::Vector, delta::Integer)
+ function _deleteend!(a :: Vector, delta :: Integer)
- function _diag(A::Bidiagonal, k)
+ function _diag(A :: Bidiagonal, k)
- function _diagm(size, kv::Pair{<:Integer,<:AbstractVector}...)
+ function _diagm(size, kv :: Pair{??? <: Integer, ??? <: AbstractVector}...)
- function _diff_length(a, b, A, B)
+ function _diff_length(a, b, A, B)
- function _dim_stack!(::Val{dims}, B::AbstractArray, x1, xrest) where {dims}
+ function _dim_stack!(??? :: Val{dims}, B :: AbstractArray, x1, xrest) where dims
- function _dominates(domtree::GenericDomTree, bb1::BBNumber, bb2::BBNumber)
+ function _dominates(domtree :: GenericDomTree, bb1 :: BBNumber, bb2 :: BBNumber)
- function _dot_nonrecursive(u, v)
+ function _dot_nonrecursive(u, v)
- function _dropdims(A::AbstractArray, dims::Dims)
+ function _dropdims(A :: AbstractArray, dims :: Dims)
- function _duplicate(x::BigFloat)
+ function _duplicate(x :: BigFloat)
- function _eachmethod(f, m::Module, visited, vmt)
+ function _eachmethod(f, m :: Module, visited, vmt)
- function _eq(t1::Any32, t2::Any32)
+ function _eq(t1 :: Any32, t2 :: Any32)
- function _eq(t1::Tuple, t2::Tuple)
+ function _eq(t1 :: Tuple, t2 :: Tuple)
- function _eq_missing(t1::Tuple, t2::Tuple)
+ function _eq_missing(t1 :: Tuple, t2 :: Tuple)
- function _evalpoly(x, p)
+ function _evalpoly(x, p)
- function _evalpoly(z::Complex, p)
+ function _evalpoly(z :: Complex, p)
- function _exec(re, subject, offset, options, match_data)
+ function _exec(re, subject, offset, options, match_data)
- function _exponent_finite_nonzero(x::T) where T<:IEEEFloat
+ function _exponent_finite_nonzero(x :: T) where T <: IEEEFloat
- function _extrema_rf(x::NTuple{2,T}, y::NTuple{2,T}) where {T<:IEEEFloat}
+ function _extrema_rf(x :: NTuple{DependentType@38af3868, T}, y :: NTuple{DependentType@77459877, T}) where T <: IEEEFloat
- function _factorize(A::HermOrSym{T}; check::Bool=true) where T
+ function _factorize(A :: HermOrSym{T}, check :: Bool = true) where T
- function _fast(::typeof(max), x::AbstractFloat, y::AbstractFloat)
+ function _fast(??? :: typeof(max), x :: AbstractFloat, y :: AbstractFloat)
- function _fast(::typeof(min),x::AbstractFloat, y::AbstractFloat)
+ function _fast(??? :: typeof(min), x :: AbstractFloat, y :: AbstractFloat)
- function _fd(x::Union{LibuvStream, LibuvServer})
+ function _fd(x :: Union{LibuvStream, LibuvServer})
- function _fieldindex_maythrow(T::DataType, name::Symbol)
+ function _fieldindex_maythrow(T :: DataType, name :: Symbol)
- function _fieldindex_nothrow(T::DataType, name::Symbol)
+ function _fieldindex_nothrow(T :: DataType, name :: Symbol)
- function _fieldnames(@nospecialize t)
+ function _fieldnames(t)
- function _fieldtype_nothrow(@nospecialize(s), exact::Bool, name::Const)
+ function _fieldtype_nothrow(s, exact :: Bool, name :: Const)
- function _find_params_log_quasitriu!(A)
+ function _find_params_log_quasitriu!(A)
- function _find_root_impl!(parents::Vector{T}, x::Integer) where {T<:Integer}
+ function _find_root_impl!(parents :: Vector{T}, x :: Integer) where T <: Integer
- function _findall(@nospecialize(sig::Type), mt::Union{Nothing,MethodTable}, world::UInt, limit::Int)
+ function _findall(sig :: Type, mt :: Union{Nothing, MethodTable}, world :: UInt, limit :: Int)
- function _findfirst_loop(f::Function, t)
+ function _findfirst_loop(f :: Function, t)
- function _findin(a::Union{AbstractArray, Tuple}, b)
+ function _findin(a :: Union{AbstractArray, Tuple}, b)
- function _findin(r::AbstractRange{<:Integer}, span::AbstractUnitRange{<:Integer})
+ function _findin(r :: AbstractRange{??? <: Integer}, span :: AbstractUnitRange{??? <: Integer})
- function _findlast_loop(f::Function, t)
+ function _findlast_loop(f :: Function, t)
- function _findlast_rec(f::Function, x::Tuple)
+ function _findlast_rec(f :: Function, x :: Tuple)
- function _findmax(f, A, region)
+ function _findmax(f, A, region)
- function _findmin(f, A, region)
+ function _findmin(f, A, region)
- function _findminmax_inittype(f, A::AbstractArray)
+ function _findminmax_inittype(f, A :: AbstractArray)
- function _findnext_int(testf::Function, B::BitArray, start::Int)
+ function _findnext_int(testf :: Function, B :: BitArray, start :: Int)
- function _findnext_re(re::Regex, str, idx::Integer, match_data::Ptr{Cvoid})
+ function _findnext_re(re :: Regex, str, idx :: Integer, match_data :: Ptr{Cvoid})
- function _findprev_int(testf::Function, B::BitArray, start::Int)
+ function _findprev_int(testf :: Function, B :: BitArray, start :: Int)
- function _findsup(@nospecialize(sig::Type), mt::Union{Nothing,MethodTable}, world::UInt)
+ function _findsup(sig :: Type, mt :: Union{Nothing, MethodTable}, world :: UInt)
- function _foldable_objectid(@nospecialize(x))
+ function _foldable_objectid(x)
- function _foldl_impl(op, init, itr::Union{Tuple,NamedTuple})
+ function _foldl_impl(op, init, itr :: Union{Tuple, NamedTuple})
- function _foldl_impl(op::OP, init, itr) where {OP}
+ function _foldl_impl(op :: OP, init, itr) where OP
- function _foldl_iter(rf, val::T, iter, state) where {T}
+ function _foldl_iter(rf, val :: T, iter, state) where T
- function _front(v, t...)
+ function _front(v, t...)
- function _g_ifelse_isa_()
+ function _g_ifelse_isa_
- function _generate_unsafe_getindex!_body(N::Int)
+ function _generate_unsafe_getindex!_body(N :: Int)
- function _generate_unsafe_setindex!_body(N::Int)
+ function _generate_unsafe_setindex!_body(N :: Int)
- function _generated_stub(gen::Symbol, args::Core.SimpleVector, params::Core.SimpleVector, expand_early::Bool)
+ function _generated_stub(gen :: Symbol, args :: Core.SimpleVector, params :: Core.SimpleVector, expand_early :: Bool)
- function _getch()
+ function _getch
- function _getfield_fieldindex(s::DataType, name::Const)
+ function _getfield_fieldindex(s :: DataType, name :: Const)
- function _getfield_tfunc_const(@nospecialize(sv), name::Const)
+ function _getfield_tfunc_const(sv, name :: Const)
- function _getindex(::IndexCartesian, A::AbstractArray, I::Vararg{Int,M}) where M
+ function _getindex(??? :: IndexCartesian, A :: AbstractArray, I :: Vararg{Int, M}) where M
- function _getindex(::IndexCartesian, A::AbstractArray{T,N}, I::Vararg{Int, N}) where {T,N}
+ function _getindex(??? :: IndexCartesian, A :: AbstractArray{T, N}, I :: Vararg{Int, N}) where T, N
- function _getindex(::IndexLinear, A::AbstractArray, I::Vararg{Int,M}) where M
+ function _getindex(??? :: IndexLinear, A :: AbstractArray, I :: Vararg{Int, M}) where M
- function _getindex(::IndexSCartesian2, A::AbstractArray{T,N}, I::Vararg{Int, N}) where {T,N}
+ function _getindex(??? :: IndexSCartesian2, A :: AbstractArray{T, N}, I :: Vararg{Int, N}) where T, N
- function _getindex(::IndexSCartesian2, A::AbstractArray{T,N}, ind::SCartesianIndex2) where {T,N}
+ function _getindex(??? :: IndexSCartesian2, A :: AbstractArray{T, N}, ind :: SCartesianIndex2) where T, N
- function _getindex(tree::GitTree, target::AbstractString)
+ function _getindex(tree :: GitTree, target :: AbstractString)
- function _getindex(v::AbstractRange, i::Integer)
+ function _getindex(v :: AbstractRange, i :: Integer)
- function _getindex(v::UnitRange{T}, i::Integer) where T
+ function _getindex(v :: UnitRange{T}, i :: Integer) where T
- function _getindex(v::UnitRange{T}, i::Integer) where {T<:OverflowSafe}
+ function _getindex(v :: UnitRange{T}, i :: Integer) where T <: OverflowSafe
- function _getindex_hiprec(r::StepRangeLen, i::Integer)
+ function _getindex_hiprec(r :: StepRangeLen, i :: Integer)
- function _getindex_hiprec(r::StepRangeLen{<:Any,<:TwicePrecision,<:TwicePrecision}, i::Integer)
+ function _getindex_hiprec(r :: StepRangeLen{??? <: Any, ??? <: TwicePrecision, ??? <: TwicePrecision}, i :: Integer)
- function _getmeta(body::Array{Any,1}, sym::Symbol, delete::Bool)
+ function _getmeta(body :: Array{Any, DependentType@5b2133b1}, sym :: Symbol, delete :: Bool)
- function _getmeta(body::Expr, sym::Symbol, delete::Bool)
+ function _getmeta(body :: Expr, sym :: Symbol, delete :: Bool)
- function _global_julia_startup_file()
+ function _global_julia_startup_file
- function _groupedunique!(A::AbstractVector)
+ function _groupedunique!(A :: AbstractVector)
- function _grow!(pred!, v::AbstractVector, itrs)
+ function _grow!(pred!, v :: AbstractVector, itrs)
- function _growat!(a::Vector, i::Integer, delta::Integer)
+ function _growat!(a :: Vector, i :: Integer, delta :: Integer)
- function _growbeg!(a::Vector, delta::Integer)
+ function _growbeg!(a :: Vector, delta :: Integer)
- function _growend!(a::Vector, delta::Integer)
+ function _growend!(a :: Vector, delta :: Integer)
- function _handle_message_test()
+ function _handle_message_test
- function _hashed_allunique(C)
+ function _hashed_allunique(C)
- function _hasmethod(@nospecialize(tt))
+ function _hasmethod(tt)
- function _hasmethod_tfunc(interp::AbstractInterpreter, argtypes::Vector{Any}, sv::AbsIntState)
+ function _hasmethod_tfunc(interp :: AbstractInterpreter, argtypes :: Vector{Any}, sv :: AbsIntState)
- function _helpmode(io::IO, line::AbstractString, mod::Module=Main, internal_accesses::Union{Nothing, Set{Pair{Module,Symbol}}}=nothing)
+ function _helpmode(io :: IO, line :: AbstractString, mod :: Module = Main, internal_accesses :: Union{Nothing, Set{Pair{Module, Symbol}}} = nothing)
- function _hermitianpart!(A::AbstractMatrix)
+ function _hermitianpart!(A :: AbstractMatrix)
- function _hvcat(rows::Tuple{Vararg{Int}}, A::Union{AbstractArray,AbstractQ,UniformScaling,Number}...; array_type = promote_to_array_type(A))
+ function _hvcat(rows :: Tuple{Vararg{Int}}, A :: Union{AbstractArray, AbstractQ, UniformScaling, Number}..., array_type = promote_to_array_type(A))
- function _hypot(x, y)
+ function _hypot(x, y)
- function _hypot(x::NTuple{N,<:IEEEFloat}) where {N}
+ function _hypot(x :: NTuple{N, ??? <: IEEEFloat}) where N
- function _hypot(x::NTuple{N,<:Number}) where {N}
+ function _hypot(x :: NTuple{N, ??? <: Number}) where N
- function _in_range(x, r::AbstractRange)
+ function _in_range(x, r :: AbstractRange)
- function _include(mapexpr::Function, mod::Module, _path::AbstractString)
+ function _include(mapexpr :: Function, mod :: Module, _path :: AbstractString)
- function _include_dependency(mod::Module, _path::AbstractString; track_content=true)
+ function _include_dependency(mod :: Module, _path :: AbstractString, track_content = true)
- function _include_from_serialized(pkg::PkgId, path::String, ocachepath::Union{Nothing, String}, depmods::Vector{Any})
+ function _include_from_serialized(pkg :: PkgId, path :: String, ocachepath :: Union{Nothing, String}, depmods :: Vector{Any})
- function _increment_n_avail(c, inc)
+ function _increment_n_avail(c, inc)
- function _ind2sub(A::AbstractArray, ind)
+ function _ind2sub(A :: AbstractArray, ind)
- function _ind2sub(inds::Union{DimsInteger{N},Indices{N}}, ind::AbstractVector{<:Integer}) where N
+ function _ind2sub(inds :: Union{DimsInteger{N}, Indices{N}}, ind :: AbstractVector{??? <: Integer}) where N
- function _ind2sub_recurse(inds, ind)
+ function _ind2sub_recurse(inds, ind)
- function _ind2sub_recurse(indslast::NTuple{1}, ind)
+ function _ind2sub_recurse(indslast :: NTuple{DependentType@72ea2f77}, ind)
- function _indexed_allunique(A)
+ function _indexed_allunique(A)
- function _indices_sub(i1::AbstractArray, I...)
+ function _indices_sub(i1 :: AbstractArray, I...)
- function _inferred(ex, mod, allow = :(Union{}))
+ function _inferred(ex, mod, allow = :(Union{}))
- function _inner_mapslices!(R, indices, f, A, dim_mask, Aslice, safe_for_reuse)
+ function _inner_mapslices!(R, indices, f, A, dim_mask, Aslice, safe_for_reuse)
- function _insert_extension_triggers(parent::PkgId, extensions::Dict{String, Any}, weakdeps::Dict{String, Any})
+ function _insert_extension_triggers(parent :: PkgId, extensions :: Dict{String, Any}, weakdeps :: Dict{String, Any})
- function _insert_int!(B::BitVector, i::Int, item)
+ function _insert_int!(B :: BitVector, i :: Int, item)
- function _inv(A::HermOrSym)
+ function _inv(A :: HermOrSym)
- function _invoked_catch_exceptions(@nospecialize(logger))
+ function _invoked_catch_exceptions(logger)
- function _invoked_min_enabled_level(@nospecialize(logger))
+ function _invoked_min_enabled_level(logger)
- function _ipiv2perm_bk(v::AbstractVector{T}, maxi::Integer, uplo::AbstractChar, rook::Bool) where T
+ function _ipiv2perm_bk(v :: AbstractVector{T}, maxi :: Integer, uplo :: AbstractChar, rook :: Bool) where T
- function _ipiv_cols!(A::LU, order::OrdinalRange, B::AbstractVecOrMat)
+ function _ipiv_cols!(A :: LU, order :: OrdinalRange, B :: AbstractVecOrMat)
- function _ipiv_rows!(A::LU, order::OrdinalRange, B::AbstractVecOrMat)
+ function _ipiv_rows!(A :: LU, order :: OrdinalRange, B :: AbstractVecOrMat)
- function _is_declared_inline(method::Method, inline::Bool)
+ function _is_declared_inline(method :: Method, inline :: Bool)
- function _is_immutable_type(@nospecialize ty)
+ function _is_immutable_type(ty)
- function _is_internal(__module__)
+ function _is_internal(__module__)
- function _is_link(s::AbstractString)
+ function _is_link(s :: AbstractString)
- function _is_mailto(s::AbstractString)
+ function _is_mailto(s :: AbstractString)
- function _isdisjoint(a, b)
+ function _isdisjoint(a, b)
- function _isequal(t1::Any32, t2::Any32)
+ function _isequal(t1 :: Any32, t2 :: Any32)
- function _isequal(t1::Tuple{Any,Vararg{Any}}, t2::Tuple{Any,Vararg{Any}})
+ function _isequal(t1 :: Tuple{Any, Vararg{Any}}, t2 :: Tuple{Any, Vararg{Any}})
- function _isperm(A)
+ function _isperm(A)
- function _isself(ft::DataType)
+ function _isself(ft :: DataType)
- function _issorted(v::AbstractVector, lo::Integer, hi::Integer, o::Ordering)
+ function _issorted(v :: AbstractVector, lo :: Integer, hi :: Integer, o :: Ordering)
- function _iterator_upper_bound(itr)
+ function _iterator_upper_bound(itr)
- function _join_maybe_annotated(args...)
+ function _join_maybe_annotated(args...)
- function _keepat!(a::AbstractVector, inds)
+ function _keepat!(a :: AbstractVector, inds)
- function _keepat!(a::AbstractVector, m::AbstractVector{Bool})
+ function _keepat!(a :: AbstractVector, m :: AbstractVector{Bool})
- function _kron!(C, A::AbstractMatrix, B::AbstractMatrix)
+ function _kron!(C, A :: AbstractMatrix, B :: AbstractMatrix)
- function _kron!(C, A::AbstractMatrix, b::AbstractVector)
+ function _kron!(C, A :: AbstractMatrix, b :: AbstractVector)
- function _kron!(C, a::AbstractVector, B::AbstractMatrix)
+ function _kron!(C, a :: AbstractVector, B :: AbstractMatrix)
- function _kwdef!(blk, params_args, call_args)
+ function _kwdef!(blk, params_args, call_args)
- function _lift_one_interp!(e)
+ function _lift_one_interp!(e)
- function _lift_one_interp_helper(expr::Expr, in_quote_context, letargs)
+ function _lift_one_interp_helper(expr :: Expr, in_quote_context, letargs)
- function _limit_type_size(@nospecialize(t), @nospecialize(c), sources::SimpleVector, depth::Int, allowed_tuplelen::Int)
+ function _limit_type_size(t, c, sources :: SimpleVector, depth :: Int, allowed_tuplelen :: Int)
- function _linspace(::Type{T}, start_n::Integer, stop_n::Integer, len::Integer, den::Integer) where T<:IEEEFloat
+ function _linspace(??? :: Type{T}, start_n :: Integer, stop_n :: Integer, len :: Integer, den :: Integer) where T <: IEEEFloat
- function _linspace(start::T, stop::T, len::Integer) where {T<:IEEEFloat}
+ function _linspace(start :: T, stop :: T, len :: Integer) where T <: IEEEFloat
- function _linspace1(::Type{T}, start, stop, len::Integer) where T<:IEEEFloat
+ function _linspace1(??? :: Type{T}, start, stop, len :: Integer) where T <: IEEEFloat
- function _local_julia_startup_file()
+ function _local_julia_startup_file
- function _log_diag_quasitriu!(A, A0)
+ function _log_diag_quasitriu!(A, A0)
- function _log_ext(xu)
+ function _log_ext(xu)
- function _log_quasitriu!(A0, A)
+ function _log_quasitriu!(A0, A)
- function _lookup_corrected(ip::UInt)
+ function _lookup_corrected(ip :: UInt)
- function _lucopy(A::SymTridiagonal, T)
+ function _lucopy(A :: SymTridiagonal, T)
- function _mapreduce(f, op, ::IndexLinear, A::AbstractArrayOrBroadcasted)
+ function _mapreduce(f, op, ??? :: IndexLinear, A :: AbstractArrayOrBroadcasted)
- function _mapreduce(f, op, ::IndexLinear, itr::SkipMissing{<:AbstractArray})
+ function _mapreduce(f, op, ??? :: IndexLinear, itr :: SkipMissing{??? <: AbstractArray})
- function _mapreduce(f::F, op::OP, style::IndexSCartesian2{K}, A::AbstractArrayOrBroadcasted) where {F,OP,K}
+ function _mapreduce(f :: F, op :: OP, style :: IndexSCartesian2{K}, A :: AbstractArrayOrBroadcasted) where F, OP, K
- function _mapreduce_prod(f, x, D::Diagonal, y)
+ function _mapreduce_prod(f, x, D :: Diagonal, y)
- function _mapreducedim!(f, op, R::AbstractArray, A::AbstractArrayOrBroadcasted)
+ function _mapreducedim!(f, op, R :: AbstractArray, A :: AbstractArrayOrBroadcasted)
- function _mat_mat_scalar(A, B, γ)
+ function _mat_mat_scalar(A, B, γ)
- function _mat_vec_scalar(A, x, γ)
+ function _mat_vec_scalar(A, x, γ)
- function _matched_map!(f, s1::BitSet, s2::BitSet)
+ function _matched_map!(f, s1 :: BitSet, s2 :: BitSet)
- function _maxlength(t::Tuple, t2::Tuple, t3::Tuple...)
+ function _maxlength(t :: Tuple, t2 :: Tuple, t3 :: Tuple...)
- function _maxndims(::Type{<:Tuple{T, S}}) where {T, S}
+ function _maxndims(??? :: Type{??? <: Tuple{T, S}}) where T, S
- function _maybe_reindex(V, I, ::Tuple{})
+ function _maybe_reindex(V, I, ??? :: Tuple)
- function _memcmp(a::Union{Ptr{UInt8},AbstractString}, b::Union{Ptr{UInt8},AbstractString}, len::Int)
+ function _memcmp(a :: Union{Ptr{UInt8}, AbstractString}, b :: Union{Ptr{UInt8}, AbstractString}, len :: Int)
- function _memory_offset(x::AbstractArray, I::Vararg{Any,N}) where {N}
+ function _memory_offset(x :: AbstractArray, I :: Vararg{Any, N}) where N
- function _merge(f, res, d, others...)
+ function _merge(f, res, d, others...)
- function _methods(@nospecialize(f), @nospecialize(t), lim::Int, world::UInt)
+ function _methods(f, t, lim :: Int, world :: UInt)
- function _methods_by_ftype(@nospecialize(t), lim::Int, world::UInt)
+ function _methods_by_ftype(t, lim :: Int, world :: UInt)
- function _methods_by_ftype(@nospecialize(t), mt::Union{Core.MethodTable, Nothing}, lim::Int, world::UInt)
+ function _methods_by_ftype(t, mt :: Union{Core.MethodTable, Nothing}, lim :: Int, world :: UInt)
- function _methods_by_ftype(@nospecialize(t), mt::Union{Core.MethodTable, Nothing}, lim::Int, world::UInt, ambig::Bool, min::Ref{UInt}, max::Ref{UInt}, has_ambig::Ref{Int32})
+ function _methods_by_ftype(t, mt :: Union{Core.MethodTable, Nothing}, lim :: Int, world :: UInt, ambig :: Bool, min :: Ref{UInt}, max :: Ref{UInt}, has_ambig :: Ref{Int32})
- function _methodsstr(@nospecialize f)
+ function _methodsstr(f)
- function _methodswith(@nospecialize(t::Type), m::Module, supertypes::Bool)
+ function _methodswith(t :: Type, m :: Module, supertypes :: Bool)
- function _mul!(C::AbstractMatrix, A::AbstractMatrix, B::BiTriSym, _add::MulAddMul = MulAddMul())
+ function _mul!(C :: AbstractMatrix, A :: AbstractMatrix, B :: BiTriSym, _add :: MulAddMul = MulAddMul())
- function _mul!(C::AbstractMatrix, A::BiTriSym, B::BiTriSym, _add::MulAddMul = MulAddMul())
+ function _mul!(C :: AbstractMatrix, A :: BiTriSym, B :: BiTriSym, _add :: MulAddMul = MulAddMul())
- function _mul!(C::AbstractMatrix, A::BiTriSym, B::Diagonal, _add::MulAddMul = MulAddMul())
+ function _mul!(C :: AbstractMatrix, A :: BiTriSym, B :: Diagonal, _add :: MulAddMul = MulAddMul())
- function _mul!(C::AbstractMatrix, A::Diagonal, B::BiTriSym, _add::MulAddMul = MulAddMul())
+ function _mul!(C :: AbstractMatrix, A :: Diagonal, B :: BiTriSym, _add :: MulAddMul = MulAddMul())
- function _mul!(C::AbstractVecOrMat, A::BiTriSym, B::AbstractVecOrMat, _add::MulAddMul = MulAddMul())
+ function _mul!(C :: AbstractVecOrMat, A :: BiTriSym, B :: AbstractVecOrMat, _add :: MulAddMul = MulAddMul())
- function _mul_diag!(out, A, B, _add)
+ function _mul_diag!(out, A, B, _add)
- function _mul_high(a::Int128, b::Int128)
+ function _mul_high(a :: Int128, b :: Int128)
- function _mul_high(a::T, b::T) where {T<:Union{Signed, Unsigned}}
+ function _mul_high(a :: T, b :: T) where T <: Union{Signed, Unsigned}
- function _mul_high(a::UInt128, b::UInt128)
+ function _mul_high(a :: UInt128, b :: UInt128)
- function _muldiag_size_check(A, B)
+ function _muldiag_size_check(A, B)
- function _muldiag_size_check(C, A, B)
+ function _muldiag_size_check(C, A, B)
- function _mutability_errorcheck(@nospecialize objt0)
+ function _mutability_errorcheck(objt0)
- function _new_nodes_iter(stmts, new_nodes, new_nodes_info, new_nodes_idx)
+ function _new_nodes_iter(stmts, new_nodes, new_nodes_info, new_nodes_idx)
- function _nloops(N::Int, itersym::Symbol, arraysym::Symbol, args::Expr...)
+ function _nloops(N :: Int, itersym :: Symbol, arraysym :: Symbol, args :: Expr...)
- function _nloops(N::Int, itersym::Symbol, rangeexpr::Expr, args::Expr...)
+ function _nloops(N :: Int, itersym :: Symbol, rangeexpr :: Expr, args :: Expr...)
- function _nospec_some_args(@nospecialize(x), y, @nospecialize z::Int)
+ function _nospec_some_args(x, y, z :: Int)
- function _nospec_some_args2(x, y, z)
+ function _nospec_some_args2(x, y, z)
- function _nospec_with_default(@nospecialize x = 1)
+ function _nospec_with_default(x = 1)
- function _nthreads_in_pool(tpid::Int8)
+ function _nthreads_in_pool(tpid :: Int8)
- function _ntuple(f::F, n) where F
+ function _ntuple(f :: F, n) where F
- function _one(unit::T, x::AbstractMatrix) where T
+ function _one(unit :: T, x :: AbstractMatrix) where T
- function _oracle_check(compact::IncrementalCompact)
+ function _oracle_check(compact :: IncrementalCompact)
- function _overlapping_range_isdisjoint(a::AbstractRange{T}, b::AbstractRange{T}) where T<:Integer
+ function _overlapping_range_isdisjoint(a :: AbstractRange{T}, b :: AbstractRange{T}) where T <: Integer
- function _parse(stream::IO; greedy::Bool = true, raise::Bool = true)
+ function _parse(stream :: IO, greedy :: Bool = true, raise :: Bool = true)
- function _parse_input_line_core(s::String, filename::String)
+ function _parse_input_line_core(s :: String, filename :: String)
- function _parse_key(l::Parser)
+ function _parse_key(l :: Parser)
- function _parse_local_time(l::Parser, skip_hour=false)::Err{NTuple{4, Int64}}
+ function _parse_local_time(l :: Parser, skip_hour = false)
- function _peek_report()
+ function _peek_report
- function _permutedims!(P::PermutedDimsArray, src, R1, R2, R3, ds, dp)
+ function _permutedims!(P :: PermutedDimsArray, src, R1, R2, R3, ds, dp)
- function _permutedims!(P::PermutedDimsArray, src, R1::CartesianIndices{0}, R2, R3, ds, dp)
+ function _permutedims!(P :: PermutedDimsArray, src, R1 :: CartesianIndices{DependentType@33c7353a}, R2, R3, ds, dp)
- function _pop!(h::Dict, index)
+ function _pop!(h :: Dict, index)
- function _postoutput()
+ function _postoutput
- function _pow_superdiag_quasitriu!(A, A0, p)
+ function _pow_superdiag_quasitriu!(A, A0, p)
- function _precision(x, base::Integer=2)
+ function _precision(x, base :: Integer = 2)
- function _precision(x::BigFloat)
+ function _precision(x :: BigFloat)
- function _prepend!(a::Vector, ::IteratorSize, iter)
+ function _prepend!(a :: Vector, ??? :: IteratorSize, iter)
- function _prepend!(a::Vector, ::Union{HasLength,HasShape}, iter)
+ function _prepend!(a :: Vector, ??? :: Union{HasLength, HasShape}, iter)
- function _prettify_bigfloat(s::String)::String
+ function _prettify_bigfloat(s :: String)
- function _print_matrix(io, @nospecialize(X::AbstractVecOrMat), pre, sep, post, hdots, vdots, ddots, hmod, vmod, rowsA, colsA)
+ function _print_matrix(io, X :: AbstractVecOrMat, pre, sep, post, hdots, vdots, ddots, hmod, vmod, rowsA, colsA)
- function _prof_expr(expr, opts)
+ function _prof_expr(expr, opts)
- function _promote(x, y, z)
+ function _promote(x, y, z)
- function _promote(x, y, zs...)
+ function _promote(x, y, zs...)
- function _promote(x::T, y::S) where {T,S}
+ function _promote(x :: T, y :: S) where T, S
- function _push_deleted!(dltd, a::Vector, ind)
+ function _push_deleted!(dltd, a :: Vector, ind)
- function _quad_matmul(A,B,C,D)
+ function _quad_matmul(A, B, C, D)
- function _rand!(r::MersenneTwister, A::Array{T}, n64::Int, I::FloatInterval_64) where T
+ function _rand!(r :: MersenneTwister, A :: Array{T}, n64 :: Int, I :: FloatInterval_64) where T
- function _rand!(rng::AbstractRNG, z::BigFloat, sp::SamplerBigFloat)
+ function _rand!(rng :: AbstractRNG, z :: BigFloat, sp :: SamplerBigFloat)
- function _rand!(rng::AbstractRNG, z::BigFloat, sp::SamplerBigFloat, ::CloseOpen01{BigFloat})
+ function _rand!(rng :: AbstractRNG, z :: BigFloat, sp :: SamplerBigFloat, ??? :: CloseOpen01{BigFloat})
- function _rand!(rng::AbstractRNG, z::BigFloat, sp::SamplerBigFloat, ::CloseOpen12{BigFloat})
+ function _rand!(rng :: AbstractRNG, z :: BigFloat, sp :: SamplerBigFloat, ??? :: CloseOpen12{BigFloat})
- function _rand(A::Type{<: AbstractArray}, shape)
+ function _rand(A :: Type{??? <: AbstractArray}, shape)
- function _rand(A::Type{<:Array}, shape)
+ function _rand(A :: Type{??? <: Array}, shape)
- function _rand128(r::AbstractRNG, ::Type{Float64})
+ function _rand128(r :: AbstractRNG, ??? :: Type{Float64})
- function _rand_filename(len = 10)
+ function _rand_filename(len = 10)
- function _rand_filename(len::Int=4)
+ function _rand_filename(len :: Int = 4)
- function _rand_max383!(r::MersenneTwister, A::UnsafeView{Float64}, I::FloatInterval_64)
+ function _rand_max383!(r :: MersenneTwister, A :: UnsafeView{Float64}, I :: FloatInterval_64)
- function _randexp(rng::AbstractRNG, ri::UInt64)
+ function _randexp(rng :: AbstractRNG, ri :: UInt64)
- function _randjump(r::MersenneTwister, jumppoly::DSFMT.GF2X)
+ function _randjump(r :: MersenneTwister, jumppoly :: DSFMT.GF2X)
- function _rdiv!(B::AbstractVecOrMat, A::AbstractVecOrMat, D::Diagonal)
+ function _rdiv!(B :: AbstractVecOrMat, A :: AbstractVecOrMat, D :: Diagonal)
- function _rdiv!(C::AbstractMatrix, A::AbstractMatrix, B::Bidiagonal)
+ function _rdiv!(C :: AbstractMatrix, A :: AbstractMatrix, B :: Bidiagonal)
- function _rdiv!(Dc::Diagonal, Db::Diagonal, Da::Diagonal)
+ function _rdiv!(Dc :: Diagonal, Db :: Diagonal, Da :: Diagonal)
- function _rdiv!(T::Tridiagonal, S::Union{SymTridiagonal,Tridiagonal}, D::Diagonal)
+ function _rdiv!(T :: Tridiagonal, S :: Union{SymTridiagonal, Tridiagonal}, D :: Diagonal)
- function _read_dependency_src(io::IO, filename::AbstractString, includes::Vector{CacheHeaderIncludes}=CacheHeaderIncludes[])
+ function _read_dependency_src(io :: IO, filename :: AbstractString, includes :: Vector{CacheHeaderIncludes} = CacheHeaderIncludes[])
- function _readkey(stream::IO=stdin)
+ function _readkey(stream :: IO = stdin)
- function _redirect_io_global(io, unix_fd::Int)
+ function _redirect_io_global(io, unix_fd :: Int)
- function _redirect_io_libc(stream, unix_fd::Int)
+ function _redirect_io_libc(stream, unix_fd :: Int)
- function _reducedim_init(f, op, fv, fop, A, region)
+ function _reducedim_init(f, op, fv, fop, A, region)
- function _reformat_bt(bt::Array{Ptr{Cvoid},1}, bt2::Array{Any,1})
+ function _reformat_bt(bt :: Array{Ptr{Cvoid}, DependentType@681a9515}, bt2 :: Array{Any, DependentType@3af49f1c})
- function _repl(x, brief::Bool=true, mod::Module=Main, internal_accesses::Union{Nothing, Set{Pair{Module,Symbol}}}=nothing)
+ function _repl(x, brief :: Bool = true, mod :: Module = Main, internal_accesses :: Union{Nothing, Set{Pair{Module, Symbol}}} = nothing)
- function _replace!(new::Callable, res::AbstractArray, A::AbstractArray, count::Int)
+ function _replace!(new :: Callable, res :: AbstractArray, A :: AbstractArray, count :: Int)
- function _replace!(new::Callable, t::Dict{K,V}, A::AbstractDict, count::Int) where {K,V}
+ function _replace!(new :: Callable, t :: Dict{K, V}, A :: AbstractDict, count :: Int) where K, V
- function _replace!(new::Callable, t::Set{T}, ::AbstractSet, count::Int) where {T}
+ function _replace!(new :: Callable, t :: Set{T}, ??? :: AbstractSet, count :: Int) where T
- function _replace(f::Callable, t::Tuple, count::Int)
+ function _replace(f :: Callable, t :: Tuple, count :: Int)
- function _replace(io, repl_s::SubstitutionString, str, r, re)
+ function _replace(io, repl_s :: SubstitutionString, str, r, re)
- function _replace(t::Tuple, count::Int, old_new::Tuple{Vararg{Pair}})
+ function _replace(t :: Tuple, count :: Int, old_new :: Tuple{Vararg{Pair}})
- function _replace_(io::IO, str, pat_repl::NTuple{N, Pair}, count::Int) where N
+ function _replace_(io :: IO, str, pat_repl :: NTuple{N, Pair}, count :: Int) where N
- function _replace_(str, pat_repl::NTuple{N, Pair}, count::Int) where N
+ function _replace_(str, pat_repl :: NTuple{N, Pair}, count :: Int) where N
- function _replace_init(str, pat_repl::NTuple{N, Pair}, count::Int) where N
+ function _replace_init(str, pat_repl :: NTuple{N, Pair}, count :: Int) where N
- function _require(pkg::PkgId, env=nothing)
+ function _require(pkg :: PkgId, env = nothing)
- function _require_from_serialized(uuidkey::PkgId, path::String, ocachepath::Union{String, Nothing})
+ function _require_from_serialized(uuidkey :: PkgId, path :: String, ocachepath :: Union{String, Nothing})
- function _require_prelocked(uuidkey::PkgId, env=nothing)
+ function _require_prelocked(uuidkey :: PkgId, env = nothing)
- function _reset_console_mode()
+ function _reset_console_mode
- function _reshape(A::AbstractVector, inds::Tuple{OffsetAxis})
+ function _reshape(A :: AbstractVector, inds :: Tuple{OffsetAxis})
- function _reshape(parent::AbstractArray, dims::Dims)
+ function _reshape(parent :: AbstractArray, dims :: Dims)
- function _reshape(v::AbstractVector, dims::Dims{1})
+ function _reshape(v :: AbstractVector, dims :: Dims{DependentType@19469ea2})
- function _reshaped_strides(::Dims{0}, reshaped::Int, msz::Int, ::Int, ::Int, ::Dims, ::Dims)
+ function _reshaped_strides(??? :: Dims{DependentType@13221655}, reshaped :: Int, msz :: Int, ??? :: Int, ??? :: Int, ??? :: Dims, ??? :: Dims)
- function _reshaped_strides(sz::Dims, reshaped::Int, msz::Int, mst::Int, n::Int, apsz::Dims, apst::Dims)
+ function _reshaped_strides(sz :: Dims, reshaped :: Int, msz :: Int, mst :: Int, n :: Int, apsz :: Dims, apst :: Dims)
- function _resize_int!(B::BitVector, n::Int)
+ function _resize_int!(B :: BitVector, n :: Int)
- function _return_type(interp::AbstractInterpreter, t::DataType)
+ function _return_type(interp :: AbstractInterpreter, t :: DataType)
- function _reverse!(A::AbstractArray{<:Any,N}, dims::NTuple{M,Int}) where {N,M}
+ function _reverse!(A :: AbstractArray{??? <: Any, N}, dims :: NTuple{M, Int}) where N, M
- function _reverse!(B::BitVector, ::Colon)
+ function _reverse!(B :: BitVector, ??? :: Colon)
- function _reverse(A::BitArray, d::Int)
+ function _reverse(A :: BitArray, d :: Int)
- function _reverse(r::StepRangeLen, ::Colon)
+ function _reverse(r :: StepRangeLen, ??? :: Colon)
- function _rm_strings_and_comments(code::Union{String,SubString{String}})
+ function _rm_strings_and_comments(code :: Union{String, SubString{String}})
- function _rot_mul_vecormat(R::AbstractRotation{T}, A::AbstractVecOrMat{S}) where {T,S}
+ function _rot_mul_vecormat(R :: AbstractRotation{T}, A :: AbstractVecOrMat{S}) where T, S
- function _round_digits(x, r::RoundingMode, digits::Integer, base)
+ function _round_digits(x, r :: RoundingMode, digits :: Integer, base)
- function _round_invstep(x, invstep, r::RoundingMode)
+ function _round_invstep(x, invstep, r :: RoundingMode)
- function _round_invstepsqrt(x, invstepsqrt, r::RoundingMode)
+ function _round_invstepsqrt(x, invstepsqrt, r :: RoundingMode)
- function _round_sigdigits(x, r::RoundingMode, sigdigits::Integer, base)
+ function _round_sigdigits(x, r :: RoundingMode, sigdigits :: Integer, base)
- function _round_step(x, step, r::RoundingMode)
+ function _round_step(x, step, r :: RoundingMode)
- function _rs_iterator(P, mi::NTuple{M}) where M
+ function _rs_iterator(P, mi :: NTuple{M}) where M
- function _rsearch(a::ByteArray, b::AbstractChar, i::Integer = length(a))
+ function _rsearch(a :: ByteArray, b :: AbstractChar, i :: Integer = length(a))
- function _rsearch(a::Union{String,ByteArray}, b::Union{Int8,UInt8}, i::Integer = sizeof(a))
+ function _rsearch(a :: Union{String, ByteArray}, b :: Union{Int8, UInt8}, i :: Integer = sizeof(a))
- function _rsearchindex(s::AbstractVector{<:Union{Int8,UInt8}}, t::AbstractVector{<:Union{Int8,UInt8}}, _k::Integer)
+ function _rsearchindex(s :: AbstractVector{??? <: Union{Int8, UInt8}}, t :: AbstractVector{??? <: Union{Int8, UInt8}}, _k :: Integer)
- function _rsearchindex(s::String, t::String, i::Integer)
+ function _rsearchindex(s :: String, t :: String, i :: Integer)
- function _safeindex(__module__, ex)
+ function _safeindex(__module__, ex)
- function _search(a::ByteArray, b::AbstractChar, i::Integer = 1)
+ function _search(a :: ByteArray, b :: AbstractChar, i :: Integer = 1)
- function _search(a::Union{String,ByteArray}, b::Union{Int8,UInt8}, i::Integer = 1)
+ function _search(a :: Union{String, ByteArray}, b :: Union{Int8, UInt8}, i :: Integer = 1)
- function _search_bloom_mask(c)
+ function _search_bloom_mask(c)
- function _searchindex(s::String, t::String, i::Integer)
+ function _searchindex(s :: String, t :: String, i :: Integer)
- function _selectdim(A, d, i, idxs)
+ function _selectdim(A, d, i, idxs)
- function _send_async(sock::UDPSocket, ipaddr::Union{IPv4, IPv6}, port::UInt16, buf)
+ function _send_async(sock :: UDPSocket, ipaddr :: Union{IPv4, IPv6}, port :: UInt16, buf)
- function _setbit(x::UInt128, i)
+ function _setbit(x :: UInt128, i)
- function _setenv(svar::AbstractString, sval::AbstractString, overwrite::Bool=true)
+ function _setenv(svar :: AbstractString, sval :: AbstractString, overwrite :: Bool = true)
- function _setenv(var::AbstractString, val::AbstractString, overwrite::Bool=true)
+ function _setenv(var :: AbstractString, val :: AbstractString, overwrite :: Bool = true)
- function _setindex!(::IndexCartesian, A::AbstractArray, v, I::Vararg{Int,M}) where M
+ function _setindex!(??? :: IndexCartesian, A :: AbstractArray, v, I :: Vararg{Int, M}) where M
- function _setindex!(::IndexCartesian, A::AbstractArray{T,N}, v, I::Vararg{Int, N}) where {T,N}
+ function _setindex!(??? :: IndexCartesian, A :: AbstractArray{T, N}, v, I :: Vararg{Int, N}) where T, N
- function _setindex!(::IndexLinear, A::AbstractArray, v, I::Vararg{Int,M}) where M
+ function _setindex!(??? :: IndexLinear, A :: AbstractArray, v, I :: Vararg{Int, M}) where M
- function _setindex!(::IndexSCartesian2, A::AbstractArray{T,N}, v, I::Vararg{Int, N}) where {T,N}
+ function _setindex!(??? :: IndexSCartesian2, A :: AbstractArray{T, N}, v, I :: Vararg{Int, N}) where T, N
- function _setindex!(::IndexSCartesian2, A::AbstractArray{T,N}, v, ind::SCartesianIndex2) where {T,N}
+ function _setindex!(??? :: IndexSCartesian2, A :: AbstractArray{T, N}, v, ind :: SCartesianIndex2) where T, N
- function _setindex!(l::IndexStyle, A::AbstractArray, x, I::Union{Real, AbstractArray}...)
+ function _setindex!(l :: IndexStyle, A :: AbstractArray, x, I :: Union{Real, AbstractArray}...)
- function _setindex(v, i::Integer, args::Vararg{Any,N}) where {N}
+ function _setindex(v, i :: Integer, args :: Vararg{Any, N}) where N
- function _shm_mmap_array(T, dims, shm_seg_name, mode)
+ function _shm_mmap_array(T, dims, shm_seg_name, mode)
- function _show_content(io::IO, d::DatePart{c}) where c
+ function _show_content(io :: IO, d :: DatePart{c}) where c
- function _show_content(io::IO, d::Delim)
+ function _show_content(io :: IO, d :: Delim)
- function _show_content(io::IO, d::Delim{<:AbstractChar, N}) where N
+ function _show_content(io :: IO, d :: Delim{??? <: AbstractChar, N}) where N
- function _show_cpuinfo(io::IO, info::Sys.CPUinfo, header::Bool=true, prefix::AbstractString=" ")
+ function _show_cpuinfo(io :: IO, info :: Sys.CPUinfo, header :: Bool = true, prefix :: AbstractString = " ")
- function _show_default(io::IO, @nospecialize(x))
+ function _show_default(io :: IO, x)
- function _show_empty(io::IO, X::Array)
+ function _show_empty(io :: IO, X :: Array)
- function _show_nd(io::IO, @nospecialize(a::AbstractArray), print_matrix::Function, show_full::Bool, axs::Tuple{Vararg{AbstractUnitRange}})
+ function _show_nd(io :: IO, a :: AbstractArray, print_matrix :: Function, show_full :: Bool, axs :: Tuple{Vararg{AbstractUnitRange}})
- function _show_nd_label(io::IO, a::AbstractArray, idxs)
+ function _show_nd_label(io :: IO, a :: AbstractArray, idxs)
- function _show_nonempty(io::IO, @nospecialize(X::AbstractMatrix), prefix::String, drop_brackets::Bool, axs::Tuple{AbstractUnitRange,AbstractUnitRange})
+ function _show_nonempty(io :: IO, X :: AbstractMatrix, prefix :: String, drop_brackets :: Bool, axs :: Tuple{AbstractUnitRange, AbstractUnitRange})
- function _show_nonempty(io::IO, X::AbstractArray, prefix::String)
+ function _show_nonempty(io :: IO, X :: AbstractArray, prefix :: String)
- function _show_type(io::IO, @nospecialize(x::Type))
+ function _show_type(io :: IO, x :: Type)
- function _shrink!(shrinker!::F, v::AbstractVector, itrs) where F
+ function _shrink!(shrinker! :: F, v :: AbstractVector, itrs) where F
- function _shrink(shrinker!::F, itr, itrs) where F
+ function _shrink(shrinker! :: F, itr, itrs) where F
- function _simple_count(::typeof(identity), x::Array{Bool}, init::T=0) where {T}
+ function _simple_count(??? :: typeof(identity), x :: Array{Bool}, init :: T = 0) where T
- function _simplify_include_frames(trace)
+ function _simplify_include_frames(trace)
- function _size_check_out(C, A)
+ function _size_check_out(C, A)
- function _slice_check_dims(N, dim, dims...)
+ function _slice_check_dims(N, dim, dims...)
- function _sockname(sock, self=true)
+ function _sockname(sock, self = true)
- function _sort!(v::AbstractVector, ::InsertionSortAlg, o::Ordering, kw)
+ function _sort!(v :: AbstractVector, ??? :: InsertionSortAlg, o :: Ordering, kw)
- function _sort!(v::AbstractVector, a::Algorithm, o::Ordering, kw)
+ function _sort!(v :: AbstractVector, a :: Algorithm, o :: Ordering, kw)
- function _sort!(v::AbstractVector, a::CheckSorted, o::Ordering, kw)
+ function _sort!(v :: AbstractVector, a :: CheckSorted, o :: Ordering, kw)
- function _sort!(v::AbstractVector, a::ComputeExtrema, o::Ordering, kw)
+ function _sort!(v :: AbstractVector, a :: ComputeExtrema, o :: Ordering, kw)
- function _sort!(v::AbstractVector, a::ConsiderRadixSort, o::DirectOrdering, kw)
+ function _sort!(v :: AbstractVector, a :: ConsiderRadixSort, o :: DirectOrdering, kw)
- function _sort!(v::AbstractVector, a::IEEEFloatOptimization, o::Ordering, kw)
+ function _sort!(v :: AbstractVector, a :: IEEEFloatOptimization, o :: Ordering, kw)
- function _sort!(v::AbstractVector, a::IsUIntMappable, o::Ordering, kw)
+ function _sort!(v :: AbstractVector, a :: IsUIntMappable, o :: Ordering, kw)
- function _sort!(v::AbstractVector, a::MissingOptimization, o::Ordering, kw)
+ function _sort!(v :: AbstractVector, a :: MissingOptimization, o :: Ordering, kw)
- function _sort!(v::AbstractVector, a::RadixSort, o::DirectOrdering, kw)
+ function _sort!(v :: AbstractVector, a :: RadixSort, o :: DirectOrdering, kw)
- function _sort!(v::AbstractVector, a::Small{N}, o::Ordering, kw) where N
+ function _sort!(v :: AbstractVector, a :: Small{N}, o :: Ordering, kw) where N
- function _sort!(v::AbstractVector, a::StableCheckSorted, o::Ordering, kw)
+ function _sort!(v :: AbstractVector, a :: StableCheckSorted, o :: Ordering, kw)
- function _sort!(v::AbstractVector{<:Integer}, ::CountingSort, o::DirectOrdering, kw)
+ function _sort!(v :: AbstractVector{??? <: Integer}, ??? :: CountingSort, o :: DirectOrdering, kw)
- function _sort!(v::AbstractVector{<:Integer}, a::ConsiderCountingSort, o::DirectOrdering, kw)
+ function _sort!(v :: AbstractVector{??? <: Integer}, a :: ConsiderCountingSort, o :: DirectOrdering, kw)
- function _sort!(v::AbstractVector{Bool}, ::BoolOptimization, o::Ordering, kw)
+ function _sort!(v :: AbstractVector{Bool}, ??? :: BoolOptimization, o :: Ordering, kw)
- function _sort(x::NTuple, o::Ordering)
+ function _sort(x :: NTuple, o :: Ordering)
- function _sortedfindin(v::Union{AbstractArray, Tuple}, w)
+ function _sortedfindin(v :: Union{AbstractArray, Tuple}, w)
- function _sortperm(A::AbstractArray; alg, order, scratch, dims...)
+ function _sortperm(A :: AbstractArray, alg, order, scratch, dims...)
- function _sortslices(A::AbstractArray, d::Val{dims}; kws...) where dims
+ function _sortslices(A :: AbstractArray, d :: Val{dims}, kws...) where dims
- function _spawn(cmd::Cmd, stdios::SpawnIOs)
+ function _spawn(cmd :: Cmd, stdios :: SpawnIOs)
- function _spawn(cmd::Cmd, stdios::SpawnIOs, chain::ProcessChain)
+ function _spawn(cmd :: Cmd, stdios :: SpawnIOs, chain :: ProcessChain)
- function _spawn(cmds::AbstractCmd, stdios::SpawnIOs)
+ function _spawn(cmds :: AbstractCmd, stdios :: SpawnIOs)
- function _spawn(cmds::AndCmds, stdios::SpawnIOs, chain::ProcessChain)
+ function _spawn(cmds :: AndCmds, stdios :: SpawnIOs, chain :: ProcessChain)
- function _spawn(cmds::ErrOrCmds, stdios::SpawnIOs, chain::ProcessChain)
+ function _spawn(cmds :: ErrOrCmds, stdios :: SpawnIOs, chain :: ProcessChain)
- function _spawn(cmds::OrCmds, stdios::SpawnIOs, chain::ProcessChain)
+ function _spawn(cmds :: OrCmds, stdios :: SpawnIOs, chain :: ProcessChain)
- function _spawn(redirect::CmdRedirect, stdios::SpawnIOs, args...)
+ function _spawn(redirect :: CmdRedirect, stdios :: SpawnIOs, args...)
- function _spawn_primitive(file, cmd::Cmd, stdio::SpawnIOs)
+ function _spawn_primitive(file, cmd :: Cmd, stdio :: SpawnIOs)
- function _spawn_set_thrpool(t::Task, tp::Symbol)
+ function _spawn_set_thrpool(t :: Task, tp :: Symbol)
- function _splice_int!(B::BitVector, r, ins)
+ function _splice_int!(B :: BitVector, r, ins)
- function _split_rest(a::Union{AbstractArray, Core.SimpleVector}, n::Int)
+ function _split_rest(a :: Union{AbstractArray, Core.SimpleVector}, n :: Int)
- function _split_rest(a::Union{Vector, BitVector}, n::Int)
+ function _split_rest(a :: Union{Vector, BitVector}, n :: Int)
- function _split_rest(s::AbstractString, n::Int)
+ function _split_rest(s :: AbstractString, n :: Int)
- function _splitdir_nodrive(a::String, b::String)
+ function _splitdir_nodrive(a :: String, b :: String)
- function _sqrt_pow(a::Number, s)
+ function _sqrt_pow(a :: Number, s)
- function _sqrt_pow_diag_quasitriu!(A, A0, s)
+ function _sqrt_pow_diag_quasitriu!(A, A0, s)
- function _sqrt_quasitriu!(R, A; blockwidth=64, n=checksquare(A))
+ function _sqrt_quasitriu!(R, A, blockwidth = 64, n = checksquare(A))
- function _sqrt_quasitriu_block!(R, A)
+ function _sqrt_quasitriu_block!(R, A)
- function _sqrt_quasitriu_diag_block!(R, A)
+ function _sqrt_quasitriu_diag_block!(R, A)
- function _sqrt_quasitriu_offdiag_block!(R, A)
+ function _sqrt_quasitriu_offdiag_block!(R, A)
- function _stack(dims, ::Union{HasShape, HasLength}, iter)
+ function _stack(dims, ??? :: Union{HasShape, HasLength}, iter)
- function _start()
+ function _start
- function _stdio_copy(stdios::SpawnIOs, fd::Int, @nospecialize replace)
+ function _stdio_copy(stdios :: SpawnIOs, fd :: Int, replace)
- function _stmt(code::CodeInfo, idx::Int)
+ function _stmt(code :: CodeInfo, idx :: Int)
- function _stmt(code::IRCode, idx::Int)
+ function _stmt(code :: IRCode, idx :: Int)
- function _stmt(compact::IncrementalCompact, idx::Int)
+ function _stmt(compact :: IncrementalCompact, idx :: Int)
- function _str_sizehint(x)
+ function _str_sizehint(x)
- function _string(a::Union{Char, String, SubString{String}, Symbol}...)
+ function _string(a :: Union{Char, String, SubString{String}, Symbol}...)
- function _string(x::BigFloat, fmt::String)::String
+ function _string(x :: BigFloat, fmt :: String)
- function _stripnewline(keep, pos, data)
+ function _stripnewline(keep, pos, data)
- function _sub2ind!(Iout, inds, Iinds, I)
+ function _sub2ind!(Iout, inds, Iinds, I)
- function _sub2ind(A::AbstractArray, I...)
+ function _sub2ind(A :: AbstractArray, I...)
- function _sub2ind(inds::Indices{1}, I1::AbstractVector{T}, I::AbstractVector{T}...) where T<:Integer
+ function _sub2ind(inds :: Indices{DependentType@2f2c9b19}, I1 :: AbstractVector{T}, I :: AbstractVector{T}...) where T <: Integer
- function _sub2ind_recurse(::Tuple{}, L, ind, i::Integer, I::Integer...)
+ function _sub2ind_recurse(??? :: Tuple, L, ind, i :: Integer, I :: Integer...)
- function _sub2ind_recurse(inds, L, ind, i::Integer, I::Integer...)
+ function _sub2ind_recurse(inds, L, ind, i :: Integer, I :: Integer...)
- function _sub2ind_vecs(inds, I::AbstractVector...)
+ function _sub2ind_vecs(inds, I :: AbstractVector...)
- function _subtypes_in!(mods::Array, x::Type)
+ function _subtypes_in!(mods :: Array, x :: Type)
- function _summarize_exception(kws, io::IO, @nospecialize(exc))
+ function _summarize_exception(kws, io :: IO, exc)
- function _summarize_exception(kws, io::IO, e::TaskFailedException)
+ function _summarize_exception(kws, io :: IO, e :: TaskFailedException)
- function _summarize_task_exceptions(io::IO, exc, prefix = nothing)
+ function _summarize_task_exceptions(io :: IO, exc, prefix = nothing)
- function _summarysize(ss::SummarySize, @nospecialize obj)
+ function _summarysize(ss :: SummarySize, obj)
- function _svd!(A::StridedMatrix{T}, full::Bool, alg::QRIteration) where {T<:BlasFloat}
+ function _svd!(A :: StridedMatrix{T}, full :: Bool, alg :: QRIteration) where T <: BlasFloat
- function _swap_cols!(B::AbstractMatrix, i::Integer, j::Integer)
+ function _swap_cols!(B :: AbstractMatrix, i :: Integer, j :: Integer)
- function _swap_cols!(B::AbstractVector, i::Integer, j::Integer)
+ function _swap_cols!(B :: AbstractVector, i :: Integer, j :: Integer)
- function _swap_rows!(B::AbstractMatrix, i::Integer, j::Integer)
+ function _swap_rows!(B :: AbstractMatrix, i :: Integer, j :: Integer)
- function _swap_rows!(B::AbstractVector, i::Integer, j::Integer)
+ function _swap_rows!(B :: AbstractVector, i :: Integer, j :: Integer)
- function _switchtupleunion(L::AbstractLattice, t::Vector{Any}, i::Int, tunion::Vector{Any}, @nospecialize(origt))
+ function _switchtupleunion(L :: AbstractLattice, t :: Vector{Any}, i :: Int, tunion :: Vector{Any}, origt)
- function _sylvester_2x2!(A, B, C)
+ function _sylvester_2x2!(A, B, C)
- function _sylvester_quasitriu!(A, B, C; blockwidth=64, nA=checksquare(A), nB=checksquare(B), raise=true)
+ function _sylvester_quasitriu!(A, B, C, blockwidth = 64, nA = checksquare(A), nB = checksquare(B), raise = true)
- function _sylvester_quasitriu_base!(A, B, C; raise=true)
+ function _sylvester_quasitriu_base!(A, B, C, raise = true)
- function _sylvester_quasitriu_split1!(A, B, C; nA=checksquare(A), kwargs...)
+ function _sylvester_quasitriu_split1!(A, B, C, nA = checksquare(A), kwargs...)
- function _sylvester_quasitriu_split2!(A, B, C; nB=checksquare(B), kwargs...)
+ function _sylvester_quasitriu_split2!(A, B, C, nB = checksquare(B), kwargs...)
- function _sylvester_quasitriu_splitall!(A, B, C; nA=checksquare(A), nB=checksquare(B), kwargs...)
+ function _sylvester_quasitriu_splitall!(A, B, C, nA = checksquare(A), nB = checksquare(B), kwargs...)
- function _sym_to_tpid(tp::Symbol)
+ function _sym_to_tpid(tp :: Symbol)
- function _symbol(x::Enum)
+ function _symbol(x :: Enum)
- function _term_header(io::IO, md, char, columns)
+ function _term_header(io :: IO, md, char, columns)
- function _test_27632(A)
+ function _test_27632(A)
- function _test_at_locals1(::Any, ::Any)
+ function _test_at_locals1(??? :: Any, ??? :: Any)
- function _test_at_locals2(a::Any, ::Any, c::T) where T
+ function _test_at_locals2(a :: Any, ??? :: Any, c :: T) where T
- function _test_field_operators(r)
+ function _test_field_operators(r)
- function _test_field_orderings(r, x, y)
+ function _test_field_orderings(r, x, y)
- function _test_field_undef(r)
+ function _test_field_undef(r)
- function _test_flags(val, vflag::AbstractString, fmt::AbstractString, res::AbstractString, prefix::AbstractString)
+ function _test_flags(val, vflag :: AbstractString, fmt :: AbstractString, res :: AbstractString, prefix :: AbstractString)
- function _test_matrix(type)
+ function _test_matrix(type)
- function _test_mixed(@nospecialize(A), @nospecialize(B))
+ function _test_mixed(A, B)
- function _test_userefs(@nospecialize stmt)
+ function _test_userefs(stmt)
- function _threadsfor(iter, lbody, schedule)
+ function _threadsfor(iter, lbody, schedule)
- function _throw_dmrs(n, str, dims)
+ function _throw_dmrs(n, str, dims)
- function _throw_not_readable()
+ function _throw_not_readable
- function _to_float(number::U, ep) where {U<:Unsigned}
+ function _to_float(number :: U, ep) where U <: Unsigned
- function _to_subscript_indices(A::AbstractArray{T,N}, I::Integer...) where {T,N}
+ function _to_subscript_indices(A :: AbstractArray{T, N}, I :: Integer...) where T, N
- function _totuple(::Type{T}, itr, s::Vararg{Any,N}) where {T,N}
+ function _totuple(??? :: Type{T}, itr, s :: Vararg{Any, N}) where T, N
- function _totuple(T::Type{All32{E,N}}, itr) where {E,N}
+ function _totuple(T :: Type{All32{E, N}}, itr) where E, N
- function _totuple_err(@nospecialize T)
+ function _totuple_err(T)
- function _tp_prod(t::TwicePrecision, x, y...)
+ function _tp_prod(t :: TwicePrecision, x, y...)
- function _tpid_to_sym(tpid::Int8)
+ function _tpid_to_sym(tpid :: Int8)
- function _tri_matmul(A,B,C,δ=nothing)
+ function _tri_matmul(A, B, C, δ = nothing)
- function _trimdocs(md::Markdown.MD, brief::Bool)
+ function _trimdocs(md :: Markdown.MD, brief :: Bool)
- function _triscale!(A::LowerOrUnitLowerTriangular, B::UnitLowerTriangular, c::Number, _add)
+ function _triscale!(A :: LowerOrUnitLowerTriangular, B :: UnitLowerTriangular, c :: Number, _add)
- function _triscale!(A::LowerOrUnitLowerTriangular, c::Number, B::UnitLowerTriangular, _add)
+ function _triscale!(A :: LowerOrUnitLowerTriangular, c :: Number, B :: UnitLowerTriangular, _add)
- function _triscale!(A::LowerTriangular, B::LowerTriangular, c::Number, _add)
+ function _triscale!(A :: LowerTriangular, B :: LowerTriangular, c :: Number, _add)
- function _triscale!(A::LowerTriangular, c::Number, B::LowerTriangular, _add)
+ function _triscale!(A :: LowerTriangular, c :: Number, B :: LowerTriangular, _add)
- function _triscale!(A::UpperOrUnitUpperTriangular, B::UnitUpperTriangular, c::Number, _add)
+ function _triscale!(A :: UpperOrUnitUpperTriangular, B :: UnitUpperTriangular, c :: Number, _add)
- function _triscale!(A::UpperOrUnitUpperTriangular, c::Number, B::UnitUpperTriangular, _add)
+ function _triscale!(A :: UpperOrUnitUpperTriangular, c :: Number, B :: UnitUpperTriangular, _add)
- function _triscale!(A::UpperTriangular, B::UpperTriangular, c::Number, _add)
+ function _triscale!(A :: UpperTriangular, B :: UpperTriangular, c :: Number, _add)
- function _triscale!(A::UpperTriangular, c::Number, B::UpperTriangular, _add)
+ function _triscale!(A :: UpperTriangular, c :: Number, B :: UpperTriangular, _add)
- function _triuppers_qr(T)
+ function _triuppers_qr(T)
- function _truncate_at_width_or_chars(ignore_ANSI::Bool, str, width, rpad=false, chars="\r\n", truncmark="…")
+ function _truncate_at_width_or_chars(ignore_ANSI :: Bool, str, width, rpad = false, chars = "\r\n", truncmark = "…")
- function _trylock(rl::ReentrantLock, ct::Task)
+ function _trylock(rl :: ReentrantLock, ct :: Task)
- function _tryonce_download_from_cache(desired_url::AbstractString)
+ function _tryonce_download_from_cache(desired_url :: AbstractString)
- function _tryrequire_from_serialized(modkey::PkgId, build_id::UInt128)
+ function _tryrequire_from_serialized(modkey :: PkgId, build_id :: UInt128)
- function _tryrequire_from_serialized(modkey::PkgId, path::String, ocachepath::Union{Nothing, String}, sourcepath::String, depmods::Vector{Any})
+ function _tryrequire_from_serialized(modkey :: PkgId, path :: String, ocachepath :: Union{Nothing, String}, sourcepath :: String, depmods :: Vector{Any})
- function _tryrequire_from_serialized(pkg::PkgId, path::String, ocachepath::Union{Nothing, String})
+ function _tryrequire_from_serialized(pkg :: PkgId, path :: String, ocachepath :: Union{Nothing, String})
- function _trywait(t::Union{Timer, AsyncCondition})
+ function _trywait(t :: Union{Timer, AsyncCondition})
- function _two_finally(n)
+ function _two_finally(n)
- function _type(code::CodeInfo, idx::Int)
+ function _type(code :: CodeInfo, idx :: Int)
- function _type(code::IRCode, idx::Int)
+ function _type(code :: IRCode, idx :: Int)
- function _type(compact::IncrementalCompact, idx::Int)
+ function _type(compact :: IncrementalCompact, idx :: Int)
- function _typed_hcat(::Type{T}, A::AbstractVecOrTuple{AbstractVecOrMat}) where T
+ function _typed_hcat(??? :: Type{T}, A :: AbstractVecOrTuple{AbstractVecOrMat}) where T
- function _typed_hvncat(::Type{T}, ::Val{N}) where {T, N}
+ function _typed_hvncat(??? :: Type{T}, ??? :: Val{N}) where T, N
- function _typed_hvncat(::Type{T}, ::Val{N}, as...) where {T, N}
+ function _typed_hvncat(??? :: Type{T}, ??? :: Val{N}, as...) where T, N
- function _typed_hvncat(::Type{T}, ::Val{N}, as::AbstractArray...) where {T, N}
+ function _typed_hvncat(??? :: Type{T}, ??? :: Val{N}, as :: AbstractArray...) where T, N
- function _typed_hvncat(::Type{T}, dims::NTuple{N, Int}, row_first::Bool, xs::Number...) where {T, N}
+ function _typed_hvncat(??? :: Type{T}, dims :: NTuple{N, Int}, row_first :: Bool, xs :: Number...) where T, N
- function _typed_hvncat(T::Type, ::Val{N}, xs::Number...) where N
+ function _typed_hvncat(T :: Type, ??? :: Val{N}, xs :: Number...) where N
- function _typed_hvncat(T::Type, dims::NTuple{N, Int}, row_first::Bool, as...) where {N}
+ function _typed_hvncat(T :: Type, dims :: NTuple{N, Int}, row_first :: Bool, as...) where N
- function _typed_hvncat(T::Type, shape::NTuple{N, Tuple}, row_first::Bool, as...) where {N}
+ function _typed_hvncat(T :: Type, shape :: NTuple{N, Tuple}, row_first :: Bool, as...) where N
- function _typed_hvncat(T::Type, shape::Tuple{Tuple}, row_first::Bool, xs...)
+ function _typed_hvncat(T :: Type, shape :: Tuple{Tuple}, row_first :: Bool, xs...)
- function _typed_hvncat_1d(::Type{T}, ds::Int, ::Val{row_first}, as...) where {T, row_first}
+ function _typed_hvncat_1d(??? :: Type{T}, ds :: Int, ??? :: Val{row_first}, as...) where T, row_first
- function _typed_hvncat_dims(::Type{T}, dims::NTuple{N, Int}, row_first::Bool, as::Tuple) where {T, N}
+ function _typed_hvncat_dims(??? :: Type{T}, dims :: NTuple{N, Int}, row_first :: Bool, as :: Tuple) where T, N
- function _typed_hvncat_shape(::Type{T}, shape::NTuple{N, Tuple}, row_first, as::Tuple) where {T, N}
+ function _typed_hvncat_shape(??? :: Type{T}, shape :: NTuple{N, Tuple}, row_first, as :: Tuple) where T, N
- function _typed_stack(::Colon, ::Type{T}, ::Type{S}, A, Aax=_iterator_axes(A)) where {T, S}
+ function _typed_stack(??? :: Colon, ??? :: Type{T}, ??? :: Type{S}, A, Aax = _iterator_axes(A)) where T, S
- function _typed_stack(dims::Integer, ::Type{T}, ::Type{S}, ::HasShape{N}, A) where {T,S,N}
+ function _typed_stack(dims :: Integer, ??? :: Type{T}, ??? :: Type{S}, ??? :: HasShape{N}, A) where T, S, N
- function _typed_vcat!(a::AbstractVector{T}, V::AbstractVecOrTuple{AbstractVector}) where T
+ function _typed_vcat!(a :: AbstractVector{T}, V :: AbstractVecOrTuple{AbstractVector}) where T
- function _typed_vcat(::Type{T}, A::AbstractVecOrTuple{AbstractVecOrMat}) where T
+ function _typed_vcat(??? :: Type{T}, A :: AbstractVecOrTuple{AbstractVecOrMat}) where T
- function _typeddict(d::AbstractDict, others::AbstractDict...)
+ function _typeddict(d :: AbstractDict, others :: AbstractDict...)
- function _typeinf(interp::AbstractInterpreter, frame::InferenceState)
+ function _typeinf(interp :: AbstractInterpreter, frame :: InferenceState)
- function _typeinf_identifier(frame::Core.Compiler.InferenceState)
+ function _typeinf_identifier(frame :: Core.Compiler.InferenceState)
- function _typename(a::Union)
+ function _typename(a :: Union)
- function _unchecked_cast(::Type{BigInt}, x::BigFloat, r::MPFRRoundingMode)
+ function _unchecked_cast(??? :: Type{BigInt}, x :: BigFloat, r :: MPFRRoundingMode)
- function _unchecked_cast(::Type{Int64}, x::BigFloat, r::MPFRRoundingMode)
+ function _unchecked_cast(??? :: Type{Int64}, x :: BigFloat, r :: MPFRRoundingMode)
- function _unchecked_cast(::Type{T}, x::BigFloat, r::MPFRRoundingMode) where T<:Union{Signed, Unsigned}
+ function _unchecked_cast(??? :: Type{T}, x :: BigFloat, r :: MPFRRoundingMode) where T <: Union{Signed, Unsigned}
- function _unchecked_cast(::Type{UInt64}, x::BigFloat, r::MPFRRoundingMode)
+ function _unchecked_cast(??? :: Type{UInt64}, x :: BigFloat, r :: MPFRRoundingMode)
- function _unioncomplexity(@nospecialize x)
+ function _unioncomplexity(x)
- function _unique!(f, A::AbstractVector, seen::Set, current::Integer, i::Integer)
+ function _unique!(f, A :: AbstractVector, seen :: Set, current :: Integer, i :: Integer)
- function _unique!(f, out::AbstractVector, C, seen::Set, i)
+ function _unique!(f, out :: AbstractVector, C, seen :: Set, i)
- function _unsafe_getindex(::IndexStyle, A::AbstractArray, I::Vararg{Union{Real, AbstractArray}, N}) where N
+ function _unsafe_getindex(??? :: IndexStyle, A :: AbstractArray, I :: Vararg{Union{Real, AbstractArray}, N}) where N
- function _unsafe_setindex!(B::BitArray, X::AbstractArray, I::BitArray)
+ function _unsafe_setindex!(B :: BitArray, X :: AbstractArray, I :: BitArray)
- function _unsetenv(svar::AbstractString)
+ function _unsetenv(svar :: AbstractString)
- function _unsetenv(var::AbstractString)
+ function _unsetenv(var :: AbstractString)
- function _unsetindex!(A::Array, i::Int)
+ function _unsetindex!(A :: Array, i :: Int)
- function _unsetindex!(A::MemoryRef{T}) where T
+ function _unsetindex!(A :: MemoryRef{T}) where T
- function _useref_getindex(@nospecialize(stmt), op::Int)
+ function _useref_getindex(stmt, op :: Int)
- function _useref_setindex!(@nospecialize(stmt), op::Int, @nospecialize(v))
+ function _useref_setindex!(stmt, op :: Int, v)
- function _uv_hook_close(proc::Process)
+ function _uv_hook_close(proc :: Process)
- function _uv_hook_close(sock::UDPSocket)
+ function _uv_hook_close(sock :: UDPSocket)
- function _uv_hook_close(t::Union{Timer, AsyncCondition})
+ function _uv_hook_close(t :: Union{Timer, AsyncCondition})
- function _uv_hook_close(uv::FileMonitor)
+ function _uv_hook_close(uv :: FileMonitor)
- function _uv_hook_close(uv::FolderMonitor)
+ function _uv_hook_close(uv :: FolderMonitor)
- function _uv_hook_close(uv::PollingFileWatcher)
+ function _uv_hook_close(uv :: PollingFileWatcher)
- function _uv_hook_close(uv::Union{LibuvStream, LibuvServer})
+ function _uv_hook_close(uv :: Union{LibuvStream, LibuvServer})
- function _uv_hook_close(uv::_FDWatcher)
+ function _uv_hook_close(uv :: _FDWatcher)
- function _validate_val!(@nospecialize(x), errors, ssavals::BitSet)
+ function _validate_val!(x, errors, ssavals :: BitSet)
- function _vecormat_mul_rot(A::AbstractVecOrMat{T}, R::AbstractRotation{S}) where {T,S}
+ function _vecormat_mul_rot(A :: AbstractVecOrMat{T}, R :: AbstractRotation{S}) where T, S
- function _vectorpinv(dualfn::Tf, v::AbstractVector{Tv}, tol) where {Tv,Tf}
+ function _vectorpinv(dualfn :: Tf, v :: AbstractVector{Tv}, tol) where Tv, Tf
- function _views(ex::Expr)
+ function _views(ex :: Expr)
- function _wait(fdw::_FDWatcher, mask::FDEvent)
+ function _wait(fdw :: _FDWatcher, mask :: FDEvent)
- function _wait(t::Task)
+ function _wait(t :: Task)
- function _wait2(c::GenericCondition, waiter::Task, first::Bool=false)
+ function _wait2(c :: GenericCondition, waiter :: Task, first :: Bool = false)
- function _wait2(t::Task, waiter::Task)
+ function _wait2(t :: Task, waiter :: Task)
- function _walkdir(chnl, root)
+ function _walkdir(chnl, root)
- function _wide_qr_ldiv!(A::QR{T}, B::AbstractMatrix{T}) where T
+ function _wide_qr_ldiv!(A :: QR{T}, B :: AbstractMatrix{T}) where T
- function _win_mkstemp(temppath::AbstractString)
+ function _win_mkstemp(temppath :: AbstractString)
- function _write_capture(io::IO, group::Int, str, r, re)
+ function _write_capture(io :: IO, group :: Int, str, r, re)
- function _write_capture(io::IO, group::Int, str, r, re::RegexAndMatchData)
+ function _write_capture(io :: IO, group :: Int, str, r, re :: RegexAndMatchData)
- function _xfadjoint(op, itr)
+ function _xfadjoint(op, itr)
- function _xfadjoint_unwrap(itr::Filter)
+ function _xfadjoint_unwrap(itr :: Filter)
- function _xfadjoint_unwrap(itr::Flatten)
+ function _xfadjoint_unwrap(itr :: Flatten)
- function _xfadjoint_unwrap(itr::Generator)
+ function _xfadjoint_unwrap(itr :: Generator)
- function _zip_isdone(is, ss)
+ function _zip_isdone(is, ss)
- function _zip_iterate_interleave(xs1, xs2, ds)
+ function _zip_iterate_interleave(xs1, xs2, ds)
- function _zip_iterate_interleave(xs1, xs2, ds::Tuple{Bool,Vararg{Any}})
+ function _zip_iterate_interleave(xs1, xs2, ds :: Tuple{Bool, Vararg{Any}})
- function _zip_lengths_finite_equal(is)
+ function _zip_lengths_finite_equal(is)
- function _zip_min_length(is)
+ function _zip_min_length(is)
- function a()
+ function a
- function a34752(c, d...)
+ function a34752(c, d...)
- function a47180(b; stdout )
+ function a47180(b, stdout)
- function abmult(r::Int, x0)
+ function abmult(r :: Int, x0)
- function abmult2(r0::Int, x0)
+ function abmult2(r0 :: Int, x0)
- function abort(rb::GitRebase)
+ function abort(rb :: GitRebase)
- function absdiff(x::T,y::T) where {T<:Signed}
+ function absdiff(x :: T, y :: T) where T <: Signed
- function absdiff(x::T,y::T) where {T<:Unsigned}
+ function absdiff(x :: T, y :: T) where T <: Unsigned
- function abspath(a::String)::String
+ function abspath(a :: String)
- function abspaths(A::Vector)
+ function abspaths(A :: Vector)
- function abstr_nt_22194()
+ function abstr_nt_22194
- function abstr_nt_22194_2()
+ function abstr_nt_22194_2
- function abstr_nt_22194_3()
+ function abstr_nt_22194_3
- function abstract_call(interp::AbstractInterpreter, arginfo::ArgInfo, irsv::IRInterpretationState)
+ function abstract_call(interp :: AbstractInterpreter, arginfo :: ArgInfo, irsv :: IRInterpretationState)
- function abstract_call(interp::AbstractInterpreter, arginfo::ArgInfo, sv::InferenceState)
+ function abstract_call(interp :: AbstractInterpreter, arginfo :: ArgInfo, sv :: InferenceState)
- function abstract_call_unionall(interp::AbstractInterpreter, argtypes::Vector{Any}, call::CallMeta)
+ function abstract_call_unionall(interp :: AbstractInterpreter, argtypes :: Vector{Any}, call :: CallMeta)
- function abstract_eval_cfunction(interp::AbstractInterpreter, e::Expr, vtypes::Union{VarTable,Nothing}, sv::AbsIntState)
+ function abstract_eval_cfunction(interp :: AbstractInterpreter, e :: Expr, vtypes :: Union{VarTable, Nothing}, sv :: AbsIntState)
- function abstract_eval_foreigncall(interp::AbstractInterpreter, e::Expr, vtypes::Union{VarTable,Nothing}, sv::AbsIntState)
+ function abstract_eval_foreigncall(interp :: AbstractInterpreter, e :: Expr, vtypes :: Union{VarTable, Nothing}, sv :: AbsIntState)
- function abstract_eval_globalref(interp::AbstractInterpreter, g::GlobalRef, sv::AbsIntState)
+ function abstract_eval_globalref(interp :: AbstractInterpreter, g :: GlobalRef, sv :: AbsIntState)
- function abstract_eval_globalref_type(g::GlobalRef)
+ function abstract_eval_globalref_type(g :: GlobalRef)
- function abstract_eval_phi(interp::AbstractInterpreter, phi::PhiNode, vtypes::Union{VarTable,Nothing}, sv::AbsIntState)
+ function abstract_eval_phi(interp :: AbstractInterpreter, phi :: PhiNode, vtypes :: Union{VarTable, Nothing}, sv :: AbsIntState)
- function abstract_eval_phi_stmt(interp::AbstractInterpreter, phi::PhiNode, ::Int, irsv::IRInterpretationState)
+ function abstract_eval_phi_stmt(interp :: AbstractInterpreter, phi :: PhiNode, ??? :: Int, irsv :: IRInterpretationState)
- function abstract_eval_special_value(interp::AbstractInterpreter, @nospecialize(e), vtypes::Union{VarTable,Nothing}, sv::AbsIntState)
+ function abstract_eval_special_value(interp :: AbstractInterpreter, e, vtypes :: Union{VarTable, Nothing}, sv :: AbsIntState)
- function abstract_eval_ssavalue(s::SSAValue, ssavaluetypes::Vector{Any})
+ function abstract_eval_ssavalue(s :: SSAValue, ssavaluetypes :: Vector{Any})
- function abstract_eval_statement(interp::AbstractInterpreter, @nospecialize(e), vtypes::VarTable, sv::InferenceState)
+ function abstract_eval_statement(interp :: AbstractInterpreter, e, vtypes :: VarTable, sv :: InferenceState)
- function abstract_eval_value(interp::AbstractInterpreter, @nospecialize(e), vtypes::Union{VarTable,Nothing}, sv::AbsIntState)
+ function abstract_eval_value(interp :: AbstractInterpreter, e, vtypes :: Union{VarTable, Nothing}, sv :: AbsIntState)
- function abstract_eval_value_expr(interp::AbstractInterpreter, e::Expr, vtypes::Union{VarTable,Nothing}, sv::AbsIntState)
+ function abstract_eval_value_expr(interp :: AbstractInterpreter, e :: Expr, vtypes :: Union{VarTable, Nothing}, sv :: AbsIntState)
- function abstract_finalizer(interp::AbstractInterpreter, argtypes::Vector{Any}, sv::AbsIntState)
+ function abstract_finalizer(interp :: AbstractInterpreter, argtypes :: Vector{Any}, sv :: AbsIntState)
- function abstract_invoke(interp::AbstractInterpreter, (; fargs, argtypes)::ArgInfo, si::StmtInfo, sv::AbsIntState)
+ function abstract_invoke(interp :: AbstractInterpreter, (;fargs,argtypes) :: ArgInfo, si :: StmtInfo, sv :: AbsIntState)
- function abstract_iteration(interp::AbstractInterpreter, @nospecialize(itft), @nospecialize(itertype), sv::AbsIntState)
+ function abstract_iteration(interp :: AbstractInterpreter, itft, itertype, sv :: AbsIntState)
- function abstract_modifyfield!(interp::AbstractInterpreter, argtypes::Vector{Any}, si::StmtInfo, sv::AbsIntState)
+ function abstract_modifyfield!(interp :: AbstractInterpreter, argtypes :: Vector{Any}, si :: StmtInfo, sv :: AbsIntState)
- function accept(callback, server::LibuvServer)
+ function accept(callback, server :: LibuvServer)
- function accept(server::LibuvServer, client::LibuvStream)
+ function accept(server :: LibuvServer, client :: LibuvStream)
- function accept_batch(l::Parser, f::F)::Bool where {F}
+ function accept_batch(l :: Parser, f :: F) where F
- function accept_batch_underscore(l::Parser, f::ValidSigs, fail_if_underscore=true)::Err{Tuple{Bool, Bool}}
+ function accept_batch_underscore(l :: Parser, f :: ValidSigs, fail_if_underscore = true)
- function accept_nonblock(server::PipeServer)
+ function accept_nonblock(server :: PipeServer)
- function accept_nonblock(server::PipeServer, client::PipeEndpoint)
+ function accept_nonblock(server :: PipeServer, client :: PipeEndpoint)
- function accept_nonblock(server::TCPServer)
+ function accept_nonblock(server :: TCPServer)
- function accept_nonblock(server::TCPServer, client::TCPSocket)
+ function accept_nonblock(server :: TCPServer, client :: TCPSocket)
- function accept_result(s::MIState, p::TextInterface)
+ function accept_result(s :: MIState, p :: TextInterface)
- function access_env(onError::Function, str::AbstractString)
+ function access_env(onError :: Function, str :: AbstractString)
- function access_env(onError::Function, var::AbstractString)
+ function access_env(onError :: Function, var :: AbstractString)
- function accumulate!(op, B, A; dims::Union{Integer, Nothing} = nothing, kw...)
+ function accumulate!(op, B, A, dims :: Union{Integer, Nothing} = nothing, kw...)
- function accumulate(op, A; dims::Union{Nothing,Integer}=nothing, kw...)
+ function accumulate(op, A, dims :: Union{Nothing, Integer} = nothing, kw...)
- function accumulate(op, xs::Tuple; init = _InitialValue())
+ function accumulate(op, xs :: Tuple, init = _InitialValue())
- function accumulate_pairwise!(op::Op, result::AbstractVector, v::AbstractVector) where Op
+ function accumulate_pairwise!(op :: Op, result :: AbstractVector, v :: AbstractVector) where Op
- function accumulate_pairwise(op, v::AbstractVector{T}) where T
+ function accumulate_pairwise(op, v :: AbstractVector{T}) where T
- function acos(A::AbstractMatrix)
+ function acos(A :: AbstractMatrix)
- function acos(x::T) where T <: Union{Float32, Float64}
+ function acos(x :: T) where T <: Union{Float32, Float64}
- function acos(z::Complex)
+ function acos(z :: Complex)
- function acosh(A::AbstractMatrix)
+ function acosh(A :: AbstractMatrix)
- function acosh(A::HermOrSym{<:Real})
+ function acosh(A :: HermOrSym{??? <: Real})
- function acosh(A::Hermitian{<:Complex})
+ function acosh(A :: Hermitian{??? <: Complex})
- function acosh(x::T) where T <: Union{Float32, Float64}
+ function acosh(x :: T) where T <: Union{Float32, Float64}
- function acosh(z::Complex)
+ function acosh(z :: Complex)
- function acquire(f, s::Semaphore)
+ function acquire(f, s :: Semaphore)
- function acquire(s::Semaphore)
+ function acquire(s :: Semaphore)
- function activate(mod::Module=Main)
+ function activate(mod :: Module = Main)
- function activate(p::TextInterface, s::MIState, termbuf::AbstractTerminal, term::TextTerminal)
+ function activate(p :: TextInterface, s :: MIState, termbuf :: AbstractTerminal, term :: TextTerminal)
- function activate(p::TextInterface, s::ModeState, termbuf::AbstractTerminal, term::TextTerminal)
+ function activate(p :: TextInterface, s :: ModeState, termbuf :: AbstractTerminal, term :: TextTerminal)
- function activate_module(s::MIState)
+ function activate_module(s :: MIState)
- function activate_region(s::PromptState, state::Symbol)
+ function activate_region(s :: PromptState, state :: Symbol)
- function active_module()
+ function active_module
- function active_module()
+ function active_module
- function active_project(search_load_path::Bool=true)
+ function active_project(search_load_path :: Bool = true)
- function adaptive_sort_test(v; trusted=InsertionSort, kw...)
+ function adaptive_sort_test(v, trusted = InsertionSort, kw...)
- function adce_erase!(phi_uses::Vector{Int}, extra_worklist::Vector{Int}, compact::IncrementalCompact, idx::Int, in_worklist::Bool)
+ function adce_erase!(phi_uses :: Vector{Int}, extra_worklist :: Vector{Int}, compact :: IncrementalCompact, idx :: Int, in_worklist :: Bool)
- function adce_pass!(ir::IRCode, inlining::Union{Nothing,InliningState}=nothing)
+ function adce_pass!(ir :: IRCode, inlining :: Union{Nothing, InliningState} = nothing)
- function add!(p::Foo30594, off::Foo30594)
+ function add!(p :: Foo30594, off :: Foo30594)
- function add!(z::Rational{BigInt}, x::Rational{BigInt}, y::Rational{BigInt})
+ function add!(z :: Rational{BigInt}, x :: Rational{BigInt}, y :: Rational{BigInt})
- function add(a, b)
+ function add(a, b)
- function add12(x::T, y::T) where {T}
+ function add12(x :: T, y :: T) where T
- function add1234(x::Tuple{Int32,Int32,Int32,Int32})
+ function add1234(x :: Tuple{Int32, Int32, Int32, Int32})
- function add22condh(xh::Float64, xl::Float64, yh::Float64, yl::Float64)
+ function add22condh(xh :: Float64, xl :: Float64, yh :: Float64, yl :: Float64)
- function add_alias_change!(astate::AnalysisState, @nospecialize(x), @nospecialize(y))
+ function add_alias_change!(astate :: AnalysisState, x, y)
- function add_alias_escapes!(astate::AnalysisState, @nospecialize(v), ainfo::AInfo)
+ function add_alias_escapes!(astate :: AnalysisState, v, ainfo :: AInfo)
- function add_and_commit_file(repo, filenm, filecontent)
+ function add_and_commit_file(repo, filenm, filecontent)
- function add_backedge!(caller::InferenceState, mi::MethodInstance)
+ function add_backedge!(caller :: InferenceState, mi :: MethodInstance)
- function add_backedge!(irsv::IRInterpretationState, mi::MethodInstance)
+ function add_backedge!(irsv :: IRInterpretationState, mi :: MethodInstance)
- function add_cycle_backedge!(caller::InferenceState, frame::InferenceState, currpc::Int)
+ function add_cycle_backedge!(caller :: InferenceState, frame :: InferenceState, currpc :: Int)
- function add_dependency!(ll::LazyLibrary, dep::LazyLibrary)
+ function add_dependency!(ll :: LazyLibrary, dep :: LazyLibrary)
- function add_fake_meta(data; threadid = 1, taskid = 0xf0f0f0f0)
+ function add_fake_meta(data, threadid = 1, taskid = 0xf0f0f0f0)
- function add_fetch!(repo::GitRepo, rmt::GitRemote, fetch_spec::String)
+ function add_fetch!(repo :: GitRepo, rmt :: GitRemote, fetch_spec :: String)
- function add_field_completions!(suggestions::Vector{Completion}, name::String, @nospecialize(t))
+ function add_field_completions!(suggestions :: Vector{Completion}, name :: String, t)
- function add_flag(newinst::NewInstruction, newflag::UInt32)
+ function add_flag(newinst :: NewInstruction, newflag :: UInt32)
- function add_history(hist::REPLHistoryProvider, s::PromptState)
+ function add_history(hist :: REPLHistoryProvider, s :: PromptState)
- function add_inlining_backedge!((; edges, invokesig)::InliningEdgeTracker, mi::MethodInstance)
+ function add_inlining_backedge!((;edges,invokesig) :: InliningEdgeTracker, mi :: MethodInstance)
- function add_inst!(new::NewNodeStream, pos::Int, attach_after::Bool)
+ function add_inst!(new :: NewNodeStream, pos :: Int, attach_after :: Bool)
- function add_invalidation_callback!(@nospecialize(callback), mi::MethodInstance)
+ function add_invalidation_callback!(callback, mi :: MethodInstance)
- function add_invoke_backedge!(caller::InferenceState, @nospecialize(invokesig::Type), mi::MethodInstance)
+ function add_invoke_backedge!(caller :: InferenceState, invokesig :: Type, mi :: MethodInstance)
- function add_invoke_backedge!(irsv::IRInterpretationState, @nospecialize(invokesig::Type), mi::MethodInstance)
+ function add_invoke_backedge!(irsv :: IRInterpretationState, invokesig :: Type, mi :: MethodInstance)
- function add_liveness_change!(astate::AnalysisState, @nospecialize(x), livepc::Int)
+ function add_liveness_change!(astate :: AnalysisState, x, livepc :: Int)
- function add_method_to_glob_fn!()
+ function add_method_to_glob_fn!
- function add_mt_backedge!(caller::InferenceState, mt::MethodTable, @nospecialize(typ))
+ function add_mt_backedge!(caller :: InferenceState, mt :: MethodTable, typ)
- function add_mt_backedge!(irsv::IRInterpretationState, mt::MethodTable, @nospecialize(typ))
+ function add_mt_backedge!(irsv :: IRInterpretationState, mt :: MethodTable, typ)
- function add_nested_key!(keymap::Dict{Char, Any}, key::Union{String, Char}, value; override::Bool = false)
+ function add_nested_key!(keymap :: Dict{Char, Any}, key :: Union{String, Char}, value, override :: Bool = false)
- function add_new_idx!(is::InstructionStream)
+ function add_new_idx!(is :: InstructionStream)
- function add_pending!(compact::IncrementalCompact, pos::Int, attach_after::Bool)
+ function add_pending!(compact :: IncrementalCompact, pos :: Int, attach_after :: Bool)
- function add_preds!(all_new_preds::Vector{Int32}, bbs::Vector{BasicBlock}, bb_rename_pred::Vector{Int}, old_edge::Int32)
+ function add_preds!(all_new_preds :: Vector{Int32}, bbs :: Vector{BasicBlock}, bb_rename_pred :: Vector{Int}, old_edge :: Int32)
- function add_push!(repo::GitRepo, rmt::GitRemote, push_spec::String)
+ function add_push!(repo :: GitRepo, rmt :: GitRemote, push_spec :: String)
- function add_specialisations(dict::Dict{Char,Any}, subdict::Dict{Char,Any}, level::Int)
+ function add_specialisations(dict :: Dict{Char, Any}, subdict :: Dict{Char, Any}, level :: Int)
- function add_tag!(tags::Dict{String,String}, tag::String, value::String)
+ function add_tag!(tags :: Dict{String, String}, tag :: String, value :: String)
- function add_tfunc(@nospecialize(f::Builtin), minarg::Int, maxarg::Int, @nospecialize(tfunc), cost::Int)
+ function add_tfunc(f :: Builtin, minarg :: Int, maxarg :: Int, tfunc, cost :: Int)
- function add_tfunc(f::IntrinsicFunction, minarg::Int, maxarg::Int, @nospecialize(tfunc), cost::Int)
+ function add_tfunc(f :: IntrinsicFunction, minarg :: Int, maxarg :: Int, tfunc, cost :: Int)
- function add_variants!(types)
+ function add_variants!(types)
- function add_with_overflow(x::T, y::T) where T<:BrokenSignedInt
+ function add_with_overflow(x :: T, y :: T) where T <: BrokenSignedInt
- function add_with_overflow(x::T, y::T) where T<:BrokenUnsignedInt
+ function add_with_overflow(x :: T, y :: T) where T <: BrokenUnsignedInt
- function addblob!(repo::GitRepo, path::AbstractString)
+ function addblob!(repo :: GitRepo, path :: AbstractString)
- function addenv(cmd::Cmd, env::Dict; inherit::Bool = true)
+ function addenv(cmd :: Cmd, env :: Dict, inherit :: Bool = true)
- function addenv(cmd::Cmd, env::Vector{<:AbstractString}; inherit::Bool = true)
+ function addenv(cmd :: Cmd, env :: Vector{??? <: AbstractString}, inherit :: Bool = true)
- function addenv(cmd::Cmd, pairs::Pair{<:AbstractString}...; inherit::Bool = true)
+ function addenv(cmd :: Cmd, pairs :: Pair{??? <: AbstractString}..., inherit :: Bool = true)
- function addmethod_48802()
+ function addmethod_48802
- function addprocs_with_testenv(X; rr_allowed=true, kwargs...)
+ function addprocs_with_testenv(X, rr_allowed = true, kwargs...)
- function adjoint!(B::AbstractMatrix, A::AbstractVector)
+ function adjoint!(B :: AbstractMatrix, A :: AbstractVector)
- function adjoint!(B::AbstractVector, A::AbstractMatrix)
+ function adjoint!(B :: AbstractVector, A :: AbstractMatrix)
- function adjoint(B::BunchKaufman)
+ function adjoint(B :: BunchKaufman)
- function adjoint(F::SVD)
+ function adjoint(F :: SVD)
- function adjust(df::DateFunction, start, step, limit)
+ function adjust(df :: DateFunction, start, step, limit)
- function adjust(func::Function, start; step::Period=Day(1), limit::Int=10000)
+ function adjust(func :: Function, start, step :: Period = Day(1), limit :: Int = 10000)
- function adjust_ENV!(env::Dict, PATH::String, LIBPATH::String, adjust_PATH::Bool, adjust_LIBPATH::Bool)
+ function adjust_ENV!(env :: Dict, PATH :: String, LIBPATH :: String, adjust_PATH :: Bool, adjust_LIBPATH :: Bool)
- function adjust_ENV!(env::Dict{keytype(Base.EnvDict),valtype(Base.EnvDict)}, PATH::String, LIBPATH::String, adjust_PATH::Bool, adjust_LIBPATH::Bool)
+ function adjust_ENV!(env :: Dict{keytype(Base.EnvDict), valtype, (, Base.EnvDict, )}, PATH :: String, LIBPATH :: String, adjust_PATH :: Bool, adjust_LIBPATH :: Bool)
- function adjust_boundscheck!(inline_compact, idx′, stmt, boundscheck)
+ function adjust_boundscheck!(inline_compact, idx′, stmt, boundscheck)
- function adjust_effects(ipo_effects::Effects, def::Method)
+ function adjust_effects(ipo_effects :: Effects, def :: Method)
- function adjust_effects(sv::InferenceState)
+ function adjust_effects(sv :: InferenceState)
- function adjusthour(h::Int64, ampm::AMPM)
+ function adjusthour(h :: Int64, ampm :: AMPM)
- function admonition(stream::IO, block::MD)
+ function admonition(stream :: IO, block :: MD)
- function advance!(r::MersenneTwister, adv_jump, adv, adv_vals, idxF, adv_ints, idxI)
+ function advance!(r :: MersenneTwister, adv_jump, adv, adv_vals, idxF, adv_ints, idxI)
- function afoldl(op, a, bs...)
+ function afoldl(op, a, bs...)
- function afterusing(string::String, startpos::Int)
+ function afterusing(string :: String, startpos :: Int)
- function aligned_sizeof(@nospecialize T::Type)
+ function aligned_sizeof(T :: Type)
- function alignment(io::IO, x::AbstractIrrational)
+ function alignment(io :: IO, x :: AbstractIrrational)
- function alignment(io::IO, x::Complex)
+ function alignment(io :: IO, x :: Complex)
- function alignment(io::IO, x::Pair)
+ function alignment(io :: IO, x :: Pair)
- function alignment(io::IO, x::Rational)
+ function alignment(io :: IO, x :: Rational)
- function alignment(io::IO, x::Real)
+ function alignment(io :: IO, x :: Real)
- function all(B::BitArray)
+ function all(B :: BitArray)
- function all(f, itr::Tuple)
+ function all(f, itr :: Tuple)
- function allflags(doframework)
+ function allflags(doframework)
- function allindices!(I, B::BitArray)
+ function allindices!(I, B :: BitArray)
- function allindices!(I, B::BitMatrix)
+ function allindices!(I, B :: BitMatrix)
- function allindices!(I, B::BitVector)
+ function allindices!(I, B :: BitVector)
- function alloc_buf_hook(stream::LibuvStream, size::UInt)
+ function alloc_buf_hook(stream :: LibuvStream, size :: UInt)
- function alloc_request(buffer::IOBuffer, recommended_size::UInt)
+ function alloc_request(buffer :: IOBuffer, recommended_size :: UInt)
- function allow_macroname(ex)
+ function allow_macroname(ex)
- function allsubtypes!(m::Module, x::DataType, sts::Set)
+ function allsubtypes!(m :: Module, x :: DataType, sts :: Set)
- function allunique(C)
+ function allunique(C)
- function allunique(t::Tuple)
+ function allunique(t :: Tuple)
- function already_inserted(compact::IncrementalCompact, old::OldSSAValue)
+ function already_inserted(compact :: IncrementalCompact, old :: OldSSAValue)
- function analyze_escapes(ir::IRCode, nargs::Int, get_escape_cache)
+ function analyze_escapes(ir :: IRCode, nargs :: Int, get_escape_cache)
- function analyze_fields(ir::IRCode, @nospecialize(typ), @nospecialize(fld))
+ function analyze_fields(ir :: IRCode, typ, fld)
- function annotate!(s::AnnotatedString, range::UnitRange{Int}, @nospecialize(labelval::Pair{Symbol, <:Any}))
+ function annotate!(s :: AnnotatedString, range :: UnitRange{Int}, labelval :: Pair{Symbol, ??? <: Any})
- function annotate_meta_def_or_block(@nospecialize(ex), meta::Symbol)
+ function annotate_meta_def_or_block(ex, meta :: Symbol)
- function annotatedstring(xs...)
+ function annotatedstring(xs...)
- function annotatedstring_optimize!(s::AnnotatedString)
+ function annotatedstring_optimize!(s :: AnnotatedString)
- function annotations(s::AnnotatedString, pos::UnitRange{<:Integer})
+ function annotations(s :: AnnotatedString, pos :: UnitRange{??? <: Integer})
- function ansi_length(s)
+ function ansi_length(s)
- function any(B::BitArray)
+ function any(B :: BitArray)
- function any(f, itr::Tuple)
+ function any(f, itr :: Tuple)
- function any_refinable(sv::PostOptAnalysisState)
+ function any_refinable(sv :: PostOptAnalysisState)
- function any_stmt_may_throw(ir::IRCode, bb::Int)
+ function any_stmt_may_throw(ir :: IRCode, bb :: Int)
- function append!(B::BitVector, items::BitVector)
+ function append!(B :: BitVector, items :: BitVector)
- function append!(a::Vector, items::AbstractVector)
+ function append!(a :: Vector, items :: AbstractVector)
- function append!(bsbmp::BitSetBoundedMinPrioritySet, itr)
+ function append!(bsbmp :: BitSetBoundedMinPrioritySet, itr)
- function append_2to1!(list, innerlist)
+ function append_2to1!(list, innerlist)
- function append_c_digits(olength::Int, digits::Unsigned, buf, pos::Int)
+ function append_c_digits(olength :: Int, digits :: Unsigned, buf, pos :: Int)
- function append_c_digits_fast(olength::Int, digits::Unsigned, buf, pos::Int)
+ function append_c_digits_fast(olength :: Int, digits :: Unsigned, buf, pos :: Int)
- function append_d_digits(olength::Int, digits::Unsigned, buf, pos::Int, decchar)
+ function append_d_digits(olength :: Int, digits :: Unsigned, buf, pos :: Int, decchar)
- function append_default_depot_path!(DEPOT_PATH)
+ function append_default_depot_path!(DEPOT_PATH)
- function append_nine_digits(digits::Unsigned, buf, pos::Int)
+ function append_nine_digits(digits :: Unsigned, buf, pos :: Int)
- function append_sign(x, plus::Bool, space::Bool, buf, pos::Int)
+ function append_sign(x, plus :: Bool, space :: Bool, buf, pos :: Int)
- function appendmacro!(syms, macros, needle, endchar)
+ function appendmacro!(syms, macros, needle, endchar)
- function apply_type_nothrow(L::AbstractLattice, argtypes::Vector{Any}, @nospecialize(rt))
+ function apply_type_nothrow(L :: AbstractLattice, argtypes :: Vector{Any}, rt)
- function approve(cache::CachedCredentials, cred::AbstractCredential, url::AbstractString)
+ function approve(cache :: CachedCredentials, cred :: AbstractCredential, url :: AbstractString)
- function approve(cfg::GitConfig, cred::UserPasswordCredential, url::AbstractString)
+ function approve(cfg :: GitConfig, cred :: UserPasswordCredential, url :: AbstractString)
- function approve(p::CredentialPayload; shred::Bool=true)
+ function approve(p :: CredentialPayload, shred :: Bool = true)
- function apropos(io::IO, needle::Regex)
+ function apropos(io :: IO, needle :: Regex)
- function arg_decl_parts(m::Method, html=false)
+ function arg_decl_parts(m :: Method, html = false)
- function arg_gen(cmd::Cmd)
+ function arg_gen(cmd :: Cmd)
- function arg_gen(head)
+ function arg_gen(head)
- function arg_gen(head, tail...)
+ function arg_gen(head, tail...)
- function argextype(@nospecialize(x), compact::IncrementalCompact, sptypes::Vector{VarState} = compact.ir.sptypes)
+ function argextype(x, compact :: IncrementalCompact, sptypes :: Vector{VarState} = compact.ir.sptypes)
- function argmax(r::AbstractRange)
+ function argmax(r :: AbstractRange)
- function argmin(r::AbstractRange)
+ function argmin(r :: AbstractRange)
- function args_morespecific(a, b)
+ function args_morespecific(a, b)
- function argtype(expr::Expr)
+ function argtype(expr :: Expr)
- function argtype_by_index(argtypes::Vector{Any}, i::Int)
+ function argtype_by_index(argtypes :: Vector{Any}, i :: Int)
- function argtype_decl(env, n, @nospecialize(sig::DataType), i::Int, nargs, isva::Bool)
+ function argtype_decl(env, n, sig :: DataType, i :: Int, nargs, isva :: Bool)
- function argtype_tail(argtypes::Vector{Any}, i::Int)
+ function argtype_tail(argtypes :: Vector{Any}, i :: Int)
- function argument_datatype(@nospecialize t)
+ function argument_datatype(t)
- function array_nd_index(astate::AnalysisState, @nospecialize(ary), args::Vector{Any}, nidxs::Int = length(args))
+ function array_nd_index(astate :: AnalysisState, ary, args :: Vector{Any}, nidxs :: Int = length(args))
- function array_new_memory(mem::Memory{UInt8}, newlen::Int)
+ function array_new_memory(mem :: Memory{UInt8}, newlen :: Int)
- function array_summary(io::IO, a, inds)
+ function array_summary(io :: IO, a, inds)
- function array_summary(io::IO, a, inds::Tuple{Vararg{OneTo}})
+ function array_summary(io :: IO, a, inds :: Tuple{Vararg{OneTo}})
- function array_type_undefable(@nospecialize(arytype))
+ function array_type_undefable(arytype)
- function arrayset_unknown_dim(::Type{T}, n) where T
+ function arrayset_unknown_dim(??? :: Type{T}, n) where T
- function artifact_exists(hash::SHA1; honor_overrides::Bool=true)
+ function artifact_exists(hash :: SHA1, honor_overrides :: Bool = true)
- function artifact_path(hash::SHA1; honor_overrides::Bool=true)
+ function artifact_path(hash :: SHA1, honor_overrides :: Bool = true)
- function artifact_paths(hash::SHA1; honor_overrides::Bool=true)
+ function artifact_paths(hash :: SHA1, honor_overrides :: Bool = true)
- function artifacts_dirs(args...)
+ function artifacts_dirs(args...)
- function as_cpumask(cpus::Vector{UInt16})
+ function as_cpumask(cpus :: Vector{UInt16})
- function as_sub(x::AbstractArray{T,3}) where T
+ function as_sub(x :: AbstractArray{T, DependentType@31befd9f}) where T
- function as_sub(x::AbstractMatrix)
+ function as_sub(x :: AbstractMatrix)
- function as_sub(x::AbstractVector)
+ function as_sub(x :: AbstractVector)
- function ascend_eliminated_preds(bbs::Vector{BasicBlock}, pred::Int)
+ function ascend_eliminated_preds(bbs :: Vector{BasicBlock}, pred :: Int)
- function ascii(s::String)
+ function ascii(s :: String)
- function asin(A::AbstractMatrix)
+ function asin(A :: AbstractMatrix)
- function asin(x::T) where T<:Union{Float32, Float64}
+ function asin(x :: T) where T <: Union{Float32, Float64}
- function asin(z::Complex)
+ function asin(z :: Complex)
- function asinh(A::AbstractMatrix)
+ function asinh(A :: AbstractMatrix)
- function asinh(x::T) where T <: Union{Float32, Float64}
+ function asinh(x :: T) where T <: Union{Float32, Float64}
- function asinh(z::Complex)
+ function asinh(z :: Complex)
- function assemble_inline_todo!(ir::IRCode, state::InliningState)
+ function assemble_inline_todo!(ir :: IRCode, state :: InliningState)
- function asterisk_bold(stream::IO, md::MD)
+ function asterisk_bold(stream :: IO, md :: MD)
- function asterisk_italic(stream::IO, md::MD)
+ function asterisk_italic(stream :: IO, md :: MD)
- function astname(x::Expr, ismacro::Bool)
+ function astname(x :: Expr, ismacro :: Bool)
- function asum(x::AbstractArray)
+ function asum(x :: AbstractArray)
- function async_usemap(f, c...; ntasks=0, batch_size=nothing)
+ function async_usemap(f, c..., ntasks = 0, batch_size = nothing)
- function asyncmap!(f, r, c1, c...; ntasks=0, batch_size=nothing)
+ function asyncmap!(f, r, c1, c..., ntasks = 0, batch_size = nothing)
- function asyncmap(f, b::BitArray; kwargs...)
+ function asyncmap(f, b :: BitArray, kwargs...)
- function asyncmap(f, c...; ntasks=0, batch_size=nothing)
+ function asyncmap(f, c..., ntasks = 0, batch_size = nothing)
- function asyncmap(f, s::AbstractString; kwargs...)
+ function asyncmap(f, s :: AbstractString, kwargs...)
- function at_disable_library_threading(f)
+ function at_disable_library_threading(f)
- function atan(A::AbstractMatrix)
+ function atan(A :: AbstractMatrix)
- function atan(x::T) where T<:Union{Float32, Float64}
+ function atan(x :: T) where T <: Union{Float32, Float64}
- function atan(y::BigFloat, x::BigFloat)
+ function atan(y :: BigFloat, x :: BigFloat)
- function atan(y::T, x::T) where T<:Union{Float32, Float64}
+ function atan(y :: T, x :: T) where T <: Union{Float32, Float64}
- function atan(z::Complex)
+ function atan(z :: Complex)
- function atand(y::BigFloat, x::BigFloat)
+ function atand(y :: BigFloat, x :: BigFloat)
- function atanh(A::AbstractMatrix)
+ function atanh(A :: AbstractMatrix)
- function atanh(x::T) where T <: Union{Float32, Float64}
+ function atanh(x :: T) where T <: Union{Float32, Float64}
- function atanh(z::Complex{T}) where T
+ function atanh(z :: Complex{T}) where T
- function atexit(f::Function)
+ function atexit(f :: Function)
- function authenticate_ssh(libgit2credptr::Ptr{Ptr{Cvoid}}, p::CredentialPayload, username_ptr)
+ function authenticate_ssh(libgit2credptr :: Ptr{Ptr{Cvoid}}, p :: CredentialPayload, username_ptr)
- function authenticate_userpass(libgit2credptr::Ptr{Ptr{Cvoid}}, p::CredentialPayload)
+ function authenticate_userpass(libgit2credptr :: Ptr{Ptr{Cvoid}}, p :: CredentialPayload)
- function author(c::GitCommit)
+ function author(c :: GitCommit)
- function authors(repo::GitRepo)
+ function authors(repo :: GitRepo)
- function autolink(stream::IO, md::MD)
+ function autolink(stream :: IO, md :: MD)
- function avisit(f, e::Memory{Any})
+ function avisit(f, e :: Memory{Any})
- function axes(A)
+ function axes(A)
- function axes(A::AbstractArray{T,N}, d) where {T,N}
+ function axes(A :: AbstractArray{T, N}, d) where T, N
- function axes(a::NonReshapedReinterpretArray{T,N,S} where {N}) where {T,S}
+ function axes(a :: NonReshapedReinterpretArray{T, N, S} where N) where T, S
- function axes(a::ReshapedReinterpretArray{T,N,S} where {N}) where {T,S}
+ function axes(a :: ReshapedReinterpretArray{T, N, S} where N) where T, S
- function axpby!(alpha::Number, x::AbstractArray{T}, beta::Number, y::AbstractArray{T}) where T<:BlasFloat
+ function axpby!(alpha :: Number, x :: AbstractArray{T}, beta :: Number, y :: AbstractArray{T}) where T <: BlasFloat
- function axpby!(alpha, x::AbstractArray, β, y::AbstractArray)
+ function axpby!(alpha, x :: AbstractArray, β, y :: AbstractArray)
- function axpy!(alpha::Number, x::AbstractArray{T}, y::AbstractArray{T}) where T<:BlasFloat
+ function axpy!(alpha :: Number, x :: AbstractArray{T}, y :: AbstractArray{T}) where T <: BlasFloat
- function axpy!(alpha, x::AbstractArray, rx::AbstractArray{<:Integer}, y::AbstractArray, ry::AbstractArray{<:Integer})
+ function axpy!(alpha, x :: AbstractArray, rx :: AbstractArray{??? <: Integer}, y :: AbstractArray, ry :: AbstractArray{??? <: Integer})
- function axpy!(alpha, x::AbstractArray, y::AbstractArray)
+ function axpy!(alpha, x :: AbstractArray, y :: AbstractArray)
- function b27964(x)
+ function b27964(x)
- function backtrace()
+ function backtrace
- function bail_out_const_call(interp::AbstractInterpreter, result::MethodCallResult, si::StmtInfo)
+ function bail_out_const_call(interp :: AbstractInterpreter, result :: MethodCallResult, si :: StmtInfo)
- function bam28102()
+ function bam28102
- function banner(io::IO = stdout; short = false)
+ function banner(io :: IO = stdout, short = false)
- function bar()
+ function bar
- function bar(x::T) where T
+ function bar(x :: T) where T
- function bar11874(x)
+ function bar11874(x)
- function bar12620()
+ function bar12620
- function bar16239()
+ function bar16239
- function bar28444()
+ function bar28444
- function bar32414(a)
+ function bar32414(a)
- function bar42190(r::Union{Nothing,Int}, n::Int)
+ function bar42190(r :: Union{Nothing, Int}, n :: Int)
- function bar51090(b)
+ function bar51090(b)
- function base64decode(s)
+ function base64decode(s)
- function base64encode(f::Function, args...; context=nothing)
+ function base64encode(f :: Function, args..., context = nothing)
- function batch_inline!(ir::IRCode, todo::Vector{Pair{Int,Any}}, propagate_inbounds::Bool, params::OptimizationParams)
+ function batch_inline!(ir :: IRCode, todo :: Vector{Pair{Int, Any}}, propagate_inbounds :: Bool, params :: OptimizationParams)
- function baz27365()
+ function baz27365
- function bb_ordering()
+ function bb_ordering
- function bestmime(val)
+ function bestmime(val)
- function bidiagzero(A::Bidiagonal{<:AbstractMatrix}, i, j)
+ function bidiagzero(A :: Bidiagonal{??? <: AbstractMatrix}, i, j)
- function big_ln2()
+ function big_ln2
- function bigfib(n)
+ function bigfib(n)
- function bigint_pow(x::BigInt, y::Integer)
+ function bigint_pow(x :: BigInt, y :: Integer)
- function bin(x::Unsigned, pad::Int, neg::Bool)
+ function bin(x :: Unsigned, pad :: Int, neg :: Bool)
- function binary_trees(io, n::Int)
+ function binary_trees(io, n :: Int)
- function bind(c::Channel, task::Task)
+ function bind(c :: Channel, task :: Task)
- function bind(server::PipeServer, name::AbstractString)
+ function bind(server :: PipeServer, name :: AbstractString)
- function bind(sock::Union{TCPServer, UDPSocket, TCPSocket}, host::IPAddr, port::Integer; ipv6only = false, reuseaddr = false, kws...)
+ function bind(sock :: Union{TCPServer, UDPSocket, TCPSocket}, host :: IPAddr, port :: Integer, ipv6only = false, reuseaddr = false, kws...)
- function binding_module(m::Module, s::Symbol)
+ function binding_module(m :: Module, s :: Symbol)
- function binomial(n::BigInt, k::Integer)
+ function binomial(n :: BigInt, k :: Integer)
- function binomial(x::Number, k::Integer)
+ function binomial(x :: Number, k :: Integer)
- function binpack(pkg::PkgId)
+ function binpack(pkg :: PkgId)
- function binunpack(s::String)
+ function binunpack(s :: String)
- function bit_map!(f::F, dest::BitArray, A::BitArray) where F
+ function bit_map!(f :: F, dest :: BitArray, A :: BitArray) where F
- function bit_map!(f::F, dest::BitArray, A::BitArray, B::BitArray) where F
+ function bit_map!(f :: F, dest :: BitArray, A :: BitArray, B :: BitArray) where F
- function bit_ndigits0z(x::Base.BitUnsigned64)
+ function bit_ndigits0z(x :: Base.BitUnsigned64)
- function bit_ndigits0z(x::UInt128)
+ function bit_ndigits0z(x :: UInt128)
- function bitcount(Bc::Vector{UInt64}; init::T=0) where {T}
+ function bitcount(Bc :: Vector{UInt64}, init :: T = 0) where T
- function bitreverse(x::BitInteger)
+ function bitreverse(x :: BitInteger)
- function bitshow(io::IO, B::BitArray)
+ function bitshow(io :: IO, B :: BitArray)
- function bitstring(x::T) where {T}
+ function bitstring(x :: T) where T
- function blob(stack :: Stack)
+ function blob(stack :: Stack)
- function block_for_inst(compact::IncrementalCompact, idx::NewSSAValue)
+ function block_for_inst(compact :: IncrementalCompact, idx :: NewSSAValue)
- function block_for_inst(compact::IncrementalCompact, idx::OldSSAValue)
+ function block_for_inst(compact :: IncrementalCompact, idx :: OldSSAValue)
- function block_for_inst(compact::IncrementalCompact, idx::SSAValue)
+ function block_for_inst(compact :: IncrementalCompact, idx :: SSAValue)
- function block_for_inst(index::Vector{BasicBlock}, inst::Int)
+ function block_for_inst(index :: Vector{BasicBlock}, inst :: Int)
- function block_for_inst(index::Vector{Int}, inst::Int)
+ function block_for_inst(index :: Vector{Int}, inst :: Int)
- function block_for_inst(ir::IRCode, inst::Int)
+ function block_for_inst(ir :: IRCode, inst :: Int)
- function blockinterp(stream::IO, md::MD)
+ function blockinterp(stream :: IO, md :: MD)
- function blockpower!(A::UpperTriangular, A0::UpperTriangular, p)
+ function blockpower!(A :: UpperTriangular, A0 :: UpperTriangular, p)
- function blockquote(stream::IO, block::MD)
+ function blockquote(stream :: IO, block :: MD)
- function blocktex(stream::IO, md::MD)
+ function blocktex(stream :: IO, md :: MD)
- function bodyfunction(basemethod::Method)
+ function bodyfunction(basemethod :: Method)
- function bracketed_paste(s::MIState; tabwidth::Int=options(s).tabwidth)
+ function bracketed_paste(s :: MIState, tabwidth :: Int = options(s).tabwidth)
- function branch(ref::GitReference)
+ function branch(ref :: GitReference)
- function branch(repo::GitRepo)
+ function branch(repo :: GitRepo)
- function break_21369()
+ function break_21369
- function broadcasted(::AndAnd, a, bc::Broadcasted)
+ function broadcasted(??? :: AndAnd, a, bc :: Broadcasted)
- function broadcasted(::OrOr, a, bc::Broadcasted)
+ function broadcasted(??? :: OrOr, a, bc :: Broadcasted)
- function broadcasted(::typeof(-), j::CartesianIndex{N}, I::CartesianIndices{N}) where N
+ function broadcasted(??? :: typeof(-), j :: CartesianIndex{N}, I :: CartesianIndices{N}) where N
- function bslash_completions(string::String, pos::Int)
+ function bslash_completions(string :: String, pos :: Int)
- function btmacro()
+ function btmacro
- function buffer_writes(s::LibuvStream, bufsize)
+ function buffer_writes(s :: LibuvStream, bufsize)
- function buffercontents(buf::IOBuffer)
+ function buffercontents(buf :: IOBuffer)
- function bug_15703(xs...)
+ function bug_15703(xs...)
- function buildarray()
+ function buildarray
- function builtin_effects(L::AbstractLattice, @nospecialize(f::Builtin), arginfo::ArgInfo, @nospecialize(rt))
+ function builtin_effects(L :: AbstractLattice, f :: Builtin, arginfo :: ArgInfo, rt)
- function builtin_nothrow(L::AbstractLattice, @nospecialize(f), argtypes::Vector{Any}, @nospecialize(rt))
+ function builtin_nothrow(L :: AbstractLattice, f, argtypes :: Vector{Any}, rt)
- function bunchkaufman!(A::StridedMatrix{<:BlasFloat}, rook::Bool = false; check::Bool = true)
+ function bunchkaufman!(A :: StridedMatrix{??? <: BlasFloat}, rook :: Bool = false, check :: Bool = true)
- function busted_hint(io, exc, notarg)
+ function busted_hint(io, exc, notarg)
- function busywait(t, n_tries)
+ function busywait(t, n_tries)
- function busywork(n::Int)
+ function busywork(n :: Int)
- function byte_string_classify(bytes::AbstractVector{UInt8})
+ function byte_string_classify(bytes :: AbstractVector{UInt8})
- function bytes2hex(io::IO, itr)
+ function bytes2hex(io :: IO, itr)
- function bytes2hex(itr)
+ function bytes2hex(itr)
- function c22307()
+ function c22307
- function c27964(x)
+ function c27964(x)
- function c37265(d)
+ function c37265(d)
- function c37265_2(d)
+ function c37265_2(d)
- function cache_dependencies(cachefile::String)
+ function cache_dependencies(cachefile :: String)
- function cache_dependencies(f::IO, cachefile::AbstractString)
+ function cache_dependencies(f :: IO, cachefile :: AbstractString)
- function cache_file_entry(pkg::PkgId)
+ function cache_file_entry(pkg :: PkgId)
- function cache_lookup(L::AbstractLattice, linfo::MethodInstance, given_argtypes::Vector{Any}, cache::Vector{InferenceResult})
+ function cache_lookup(L :: AbstractLattice, linfo :: MethodInstance, given_argtypes :: Vector{Any}, cache :: Vector{InferenceResult})
- function cache_result!(interp::AbstractInterpreter, result::InferenceResult)
+ function cache_result!(interp :: AbstractInterpreter, result :: InferenceResult)
- function cached_return_type(code::CodeInstance)
+ function cached_return_type(code :: CodeInstance)
- function call_abi_str(p::AbstractPlatform)
+ function call_abi_str(p :: AbstractPlatform)
- function call_big_dead_throw_catch()
+ function call_big_dead_throw_catch
- function call_func_itr(func, itr)
+ function call_func_itr(func, itr)
- function call_iota(n::Integer,t::DataType)
+ function call_iota(n :: Integer, t :: DataType)
- function call_jl_errno()
+ function call_jl_errno
- function call_sig(ir::IRCode, stmt::Expr)
+ function call_sig(ir :: IRCode, stmt :: Expr)
- function calldoc(__source__, __module__, str, def::Expr)
+ function calldoc(__source__, __module__, str, def :: Expr)
- function caller22734(ptr)
+ function caller22734(ptr)
- function callers(funcname::String, bt::Vector, lidict::LineInfoFlatDict; filename = nothing, linerange = nothing)
+ function callers(funcname :: String, bt :: Vector, lidict :: LineInfoFlatDict, filename = nothing, linerange = nothing)
- function callersf(matchfunc::Function, bt::Vector, lidict::LineInfoFlatDict)
+ function callersf(matchfunc :: Function, bt :: Vector, lidict :: LineInfoFlatDict)
- function callf(f)
+ function callf(f)
- function callthis_26607(args)
+ function callthis_26607(args)
- function cancel_beep(s::PromptState)
+ function cancel_beep(s :: PromptState)
- function cannot_export_nonsymbol()
+ function cannot_export_nonsymbol
- function canonicalize(x::CompoundPeriod)
+ function canonicalize(x :: CompoundPeriod)
- function canonicalize2(big, little)
+ function canonicalize2(big, little)
- function canonicalize_typeassert!(compact::IncrementalCompact, idx::Int, stmt::Expr)
+ function canonicalize_typeassert!(compact :: IncrementalCompact, idx :: Int, stmt :: Expr)
- function capt_before_def()
+ function capt_before_def
- function captsp(x::T, y::S) where {T, S}
+ function captsp(x :: T, y :: S) where T, S
- function capture_names(re)
+ function capture_names(re)
- function capture_result(n::Ref{Int}, @nospecialize(x))
+ function capture_result(n :: Ref{Int}, x)
- function capture_with_conditional_label()
+ function capture_with_conditional_label
- function captured_and_shadowed_sp(x::T) where T
+ function captured_and_shadowed_sp(x :: T) where T
- function cartesian_foo()
+ function cartesian_foo
- function cat10880(a, b)
+ function cat10880(a, b)
- function cat_shape(dims, shapes::Tuple)
+ function cat_shape(dims, shapes :: Tuple)
- function cat_t18399(X...)
+ function cat_t18399(X...)
- function catch_backtrace()
+ function catch_backtrace
- function catch_exception(f, args...)
+ function catch_exception(f, args...)
- function catch_inconsistent()
+ function catch_inconsistent
- function catch_inconsistent(x::T) where T
+ function catch_inconsistent(x :: T) where T
- function catdoc(xs::HTML...)
+ function catdoc(xs :: HTML...)
- function catdoc(xs::Text...)
+ function catdoc(xs :: Text...)
- function category_abbrev(c::AbstractChar)
+ function category_abbrev(c :: AbstractChar)
- function category_code(c::AbstractChar)
+ function category_code(c :: AbstractChar)
- function category_code(x::Integer)
+ function category_code(x :: Integer)
- function cb22734(ptr::Ptr{Cvoid})
+ function cb22734(ptr :: Ptr{Cvoid})
- function cbrt(a::Float16)
+ function cbrt(a :: Float16)
- function cbrt(x::Union{Float32,Float64})
+ function cbrt(x :: Union{Float32, Float64})
- function ccall27478()
+ function ccall27478
- function ccall_macro_lower(convention, func, rettype, types, args, nreq)
+ function ccall_macro_lower(convention, func, rettype, types, args, nreq)
- function ccall_macro_parse(expr::Expr)
+ function ccall_macro_parse(expr :: Expr)
- function ccall_reassigned_ptr(ptr::Ptr{Cvoid})
+ function ccall_reassigned_ptr(ptr :: Ptr{Cvoid})
- function cconvert(::Type{Cstring}, s::SecretBuffer)
+ function cconvert(??? :: Type{Cstring}, s :: SecretBuffer)
- function cconvert(::Type{Cwstring}, s::AbstractString)
+ function cconvert(??? :: Type{Cwstring}, s :: AbstractString)
- function cconvert(::Type{Cwstring}, v::Vector{Cwchar_t})
+ function cconvert(??? :: Type{Cwstring}, v :: Vector{Cwchar_t})
- function ccopy!(B, A)
+ function ccopy!(B, A)
- function cd(dir::AbstractString)
+ function cd(dir :: AbstractString)
- function cd(f::Function, dir::AbstractString)
+ function cd(f :: Function, dir :: AbstractString)
- function cdiv_test(a,b)
+ function cdiv_test(a, b)
- function ceilfloor(x::Float64)
+ function ceilfloor(x :: Float64)
- function center(A::AbstractArray, r::RoundingMode=RoundDown)
+ function center(A :: AbstractArray, r :: RoundingMode = RoundDown)
- function cfg_delete_edge!(cfg::CFG, from::Int, to::Int)
+ function cfg_delete_edge!(cfg :: CFG, from :: Int, to :: Int)
- function cfg_finalization1(io)
+ function cfg_finalization1(io)
- function cfg_finalization2(io)
+ function cfg_finalization2(io)
- function cfg_finalization3(io)
+ function cfg_finalization3(io)
- function cfg_finalization4(io)
+ function cfg_finalization4(io)
- function cfg_finalization5(io)
+ function cfg_finalization5(io)
- function cfg_finalization6(io)
+ function cfg_finalization6(io)
- function cfg_finalization7(io)
+ function cfg_finalization7(io)
- function cfg_inline_item!(ir::IRCode, idx::Int, todo::InliningTodo, state::CFGInliningState, from_unionsplit::Bool=false)
+ function cfg_inline_item!(ir :: IRCode, idx :: Int, todo :: InliningTodo, state :: CFGInliningState, from_unionsplit :: Bool = false)
- function cfg_insert_edge!(cfg::CFG, from::Int, to::Int)
+ function cfg_insert_edge!(cfg :: CFG, from :: Int, to :: Int)
- function cfg_simplify!(ir::IRCode)
+ function cfg_simplify!(ir :: IRCode)
- function cflags(doframework)
+ function cflags(doframework)
- function cglobal33413_literal()
+ function cglobal33413_literal
- function cglobal33413_literal_notype()
+ function cglobal33413_literal_notype
- function cglobal33413_ptrinline()
+ function cglobal33413_ptrinline
- function cglobal33413_ptrinline_notype()
+ function cglobal33413_ptrinline_notype
- function cglobal33413_ptrvar()
+ function cglobal33413_ptrvar
- function cglobal33413_ptrvar_notype()
+ function cglobal33413_ptrvar_notype
- function cglobal33413_tupleliteral()
+ function cglobal33413_tupleliteral
- function cglobal33413_tupleliteral_notype()
+ function cglobal33413_tupleliteral_notype
- function cglobal45187fn()
+ function cglobal45187fn
- function cglobal49142_nothing()
+ function cglobal49142_nothing
- function challenge_prompt(cmd::Cmd, challenges)
+ function challenge_prompt(cmd :: Cmd, challenges)
- function challenge_prompt(code::Expr, challenges)
+ function challenge_prompt(code :: Expr, challenges)
- function channeled_tasks(n::Int, funcs...; ctypes=fill(Any,n), csizes=fill(0,n))
+ function channeled_tasks(n :: Int, funcs..., ctypes = fill(Any,n), csizes = fill(0,n))
- function char_move_left(buf::IOBuffer)
+ function char_move_left(buf :: IOBuffer)
- function char_move_right(buf::IOBuffer)
+ function char_move_right(buf :: IOBuffer)
- function char_move_word_left(buf::IOBuffer, is_delimiter::Function=is_non_word_char)
+ function char_move_word_left(buf :: IOBuffer, is_delimiter :: Function = is_non_word_char)
- function char_move_word_right(buf::IOBuffer, is_delimiter::Function=is_non_word_char)
+ function char_move_word_right(buf :: IOBuffer, is_delimiter :: Function = is_non_word_char)
- function char_uplo(uplo::Symbol)
+ function char_uplo(uplo :: Symbol)
- function character_codes(directives::Core.SimpleVector)
+ function character_codes(directives :: Core.SimpleVector)
- function check()
+ function check
- function check(arr, inner, outer)
+ function check(arr, inner, outer)
- function check(desc, val)
+ function check(desc, val)
- function check(node::Node)
+ function check(node :: Node)
- function check(x::Herd{N,T}) where {N,T}
+ function check(x :: Herd{N, T}) where N, T
- function checkBadType!(@nospecialize x::Type)
+ function checkBadType!(x :: Type)
- function checkUserAccess(u::User)
+ function checkUserAccess(u :: User)
- function check_A_mul_B!_sizes(C, A, B)
+ function check_A_mul_B!_sizes(C, A, B)
- function check_allowed_add_key(l::Parser, d, check_defined=true)::Err{Nothing}
+ function check_allowed_add_key(l :: Parser, d, check_defined = true)
- function check_args(args)
+ function check_args(args)
- function check_array(x, size, capacity)
+ function check_array(x, size, capacity)
- function check_bitop_call(ret_type, func, args...; kwargs...)
+ function check_bitop_call(ret_type, func, args..., kwargs...)
- function check_body!(x::Expr)
+ function check_body!(x :: Expr)
- function check_broadcast_shape(::Tuple{}, Ashp::Tuple)
+ function check_broadcast_shape(??? :: Tuple, Ashp :: Tuple)
- function check_broadcast_shape(shp, Ashp::Tuple)
+ function check_broadcast_shape(shp, Ashp :: Tuple)
- function check_channel_state(c::Channel)
+ function check_channel_state(c :: Channel)
- function check_clone_targets(clone_targets)
+ function check_clone_targets(clone_targets)
- function check_code_trampoline(f, t, n::Int)
+ function check_code_trampoline(f, t, n :: Int)
- function check_count(count::Integer)
+ function check_count(count :: Integer)
- function check_cp(orig_path::AbstractString, copied_path::AbstractString, follow_symlinks::Bool)
+ function check_cp(orig_path :: AbstractString, copied_path :: AbstractString, follow_symlinks :: Bool)
- function check_cp_main(orig::AbstractString, copied::AbstractString, follow_symlinks::Bool)
+ function check_cp_main(orig :: AbstractString, copied :: AbstractString, follow_symlinks :: Bool)
- function check_defuse(x::Union{Int,SSAUse})
+ function check_defuse(x :: Union{Int, SSAUse})
- function check_dir(orig_path::AbstractString, copied_path::AbstractString, follow_symlinks::Bool)
+ function check_dir(orig_path :: AbstractString, copied_path :: AbstractString, follow_symlinks :: Bool)
- function check_effect_free!(ir::IRCode, idx::Int, @nospecialize(stmt), @nospecialize(rt), state::InliningState)
+ function check_effect_free!(ir :: IRCode, idx :: Int, stmt, rt, state :: InliningState)
- function check_effect_free!(ir::IRCode, idx::Int, @nospecialize(stmt), @nospecialize(rt), Lₒ::AbstractLattice)
+ function check_effect_free!(ir :: IRCode, idx :: Int, stmt, rt, Lₒ :: AbstractLattice)
- function check_flag(flag)
+ function check_flag(flag)
- function check_for_hint(s::MIState)
+ function check_for_hint(s :: MIState)
- function check_for_missing_packages_and_run_hooks(ast)
+ function check_for_missing_packages_and_run_hooks(ast)
- function check_framework_flag(args)
+ function check_framework_flag(args)
- function check_inconsistentcy!(sv::PostOptAnalysisState, scanner::BBScanner)
+ function check_inconsistentcy!(sv :: PostOptAnalysisState, scanner :: BBScanner)
- function check_init()
+ function check_init
- function check_invalid(f)
+ function check_invalid(f)
- function check_merge(i::Vector{<:Dict}, o)
+ function check_merge(i :: Vector{??? <: Dict}, o)
- function check_minmax_consistency(old::Array{T,1}, m::T, start::T, o::Base.Ordering) where T
+ function check_minmax_consistency(old :: Array{T, DependentType@1c20c684}, m :: T, start :: T, o :: Base.Ordering) where T
- function check_op(ir::IRCode, domtree::DomTree, @nospecialize(op), use_bb::Int, use_idx::Int, printed_use_idx::Int, print::Bool, isforeigncall::Bool, arg_idx::Int, allow_frontend_forms::Bool)
+ function check_op(ir :: IRCode, domtree :: DomTree, op, use_bb :: Int, use_idx :: Int, printed_use_idx :: Int, print :: Bool, isforeigncall :: Bool, arg_idx :: Int, allow_frontend_forms :: Bool)
- function check_open(f::File)
+ function check_open(f :: File)
- function check_open(x::Union{LibuvStream, LibuvServer})
+ function check_open(x :: Union{LibuvStream, LibuvServer})
- function check_pids_all(S::SharedArray)
+ function check_pids_all(S :: SharedArray)
- function check_pointer_strides(A::AbstractArray)
+ function check_pointer_strides(A :: AbstractArray)
- function check_ranges(rx, ry)
+ function check_ranges(rx, ry)
- function check_readable(a::ReinterpretArray{T, N, S} where N) where {T,S}
+ function check_readable(a :: ReinterpretArray{T, N, S} where N) where T, S
- function check_reducedims(R, A)
+ function check_reducedims(R, A)
- function check_src_module_wrap(pkg::PkgId, srcpath::String)
+ function check_src_module_wrap(pkg :: PkgId, srcpath :: String)
- function check_strides(A::AbstractArray)
+ function check_strides(A :: AbstractArray)
- function check_sync_end_race()
+ function check_sync_end_race
- function check_top_bit(::Type{To}, x) where {To}
+ function check_top_bit(??? :: Type{To}, x) where To
- function check_valid(f)
+ function check_valid(f)
- function check_writable(a::ReinterpretArray{T, N, S} where N) where {T,S}
+ function check_writable(a :: ReinterpretArray{T, N, S} where N) where T, S
- function checkbounds(::Type{Bool}, A::AbstractArray, I...)
+ function checkbounds(??? :: Type{Bool}, A :: AbstractArray, I...)
- function checkbounds(::Type{Bool}, A::AbstractArray, i)
+ function checkbounds(??? :: Type{Bool}, A :: AbstractArray, i)
- function checkbounds(::Type{Bool}, A::AbstractArray, i::Union{CartesianIndex, AbstractArray{<:CartesianIndex}})
+ function checkbounds(??? :: Type{Bool}, A :: AbstractArray, i :: Union{CartesianIndex, AbstractArray{??? <: CartesianIndex}})
- function checkbounds(::Type{Bool}, A::AbstractArray{<:Any,N}, I::AbstractArray{Bool,N}) where N
+ function checkbounds(??? :: Type{Bool}, A :: AbstractArray{??? <: Any, N}, I :: AbstractArray{Bool, N}) where N
- function checkbounds(::Type{Bool}, v::StepRange{<:BitInteger64, <:BitInteger64}, i::BitInteger64)
+ function checkbounds(??? :: Type{Bool}, v :: StepRange{??? <: BitInteger64, ??? <: BitInteger64}, i :: BitInteger64)
- function checkbounds(A::AbstractArray, I...)
+ function checkbounds(A :: AbstractArray, I...)
- function checkbounds_indices(::Type{Bool}, ::Tuple{}, I::Tuple)
+ function checkbounds_indices(??? :: Type{Bool}, ??? :: Tuple, I :: Tuple)
- function checkbounds_indices(::Type{Bool}, IA::Tuple, I::Tuple)
+ function checkbounds_indices(??? :: Type{Bool}, IA :: Tuple, I :: Tuple)
- function checkdims_perm(P::AbstractArray{TP,N}, B::AbstractArray{TB,N}, perm) where {TP,TB,N}
+ function checkdims_perm(P :: AbstractArray{TP, N}, B :: AbstractArray{TB, N}, perm) where TP, TB, N
- function checked_abs(x::SignedInt)
+ function checked_abs(x :: SignedInt)
- function checked_add(x::T, y::T) where T<:Integer
+ function checked_add(x :: T, y :: T) where T <: Integer
- function checked_den(::Type{T}, num::T, den::T) where T<:Integer
+ function checked_den(??? :: Type{T}, num :: T, den :: T) where T <: Integer
- function checked_dims(d::Int...)
+ function checked_dims(d :: Int...)
- function checked_length(r::AbstractUnitRange{T}) where T
+ function checked_length(r :: AbstractUnitRange{T}) where T
- function checked_length(r::AbstractUnitRange{T}) where T<:Rational
+ function checked_length(r :: AbstractUnitRange{T}) where T <: Rational
- function checked_length(r::OrdinalRange{T}) where T
+ function checked_length(r :: OrdinalRange{T}) where T
- function checked_length(r::OrdinalRange{T}) where T<:bigints
+ function checked_length(r :: OrdinalRange{T}) where T <: bigints
- function checked_mul(x::T, y::T) where T<:Integer
+ function checked_mul(x :: T, y :: T) where T <: Integer
- function checked_neg(x::BrokenSignedInt)
+ function checked_neg(x :: BrokenSignedInt)
- function checked_neg(x::T) where T<:BrokenUnsignedInt
+ function checked_neg(x :: T) where T <: BrokenUnsignedInt
- function checked_neg(x::T) where T<:Integer
+ function checked_neg(x :: T) where T <: Integer
- function checked_sub(x::T, y::T) where T<:Integer
+ function checked_sub(x :: T, y :: T) where T <: Integer
- function checked_trunc_sint(::Type{To}, x::From) where {To,From}
+ function checked_trunc_sint(??? :: Type{To}, x :: From) where To, From
- function checked_trunc_uint(::Type{To}, x::From) where {To,From}
+ function checked_trunc_uint(??? :: Type{To}, x :: From) where To, From
- function checkedstride(x::AbstractArray)
+ function checkedstride(x :: AbstractArray)
- function checkindex(::Type{Bool}, inds::AbstractUnitRange, I::AbstractArray)
+ function checkindex(??? :: Type{Bool}, inds :: AbstractUnitRange, I :: AbstractArray)
- function checkindex(::Type{Bool}, inds::AbstractUnitRange, r::AbstractRange)
+ function checkindex(??? :: Type{Bool}, inds :: AbstractUnitRange, r :: AbstractRange)
- function checkindex(::Type{Bool}, inds::Tuple, I::AbstractArray{<:CartesianIndex})
+ function checkindex(??? :: Type{Bool}, inds :: Tuple, I :: AbstractArray{??? <: CartesianIndex})
- function checkmode(mode::Integer)
+ function checkmode(mode :: Integer)
- function checknum(s, rx, cond)
+ function checknum(s, rx, cond)
- function checkout_head(repo::GitRepo; options::CheckoutOptions = CheckoutOptions())
+ function checkout_head(repo :: GitRepo, options :: CheckoutOptions = CheckoutOptions())
- function checksquare(A)
+ function checksquare(A)
- function checksquare(A...)
+ function checksquare(A...)
- function cherrypick(repo::GitRepo, commit::GitCommit; options::CherrypickOptions = CherrypickOptions())
+ function cherrypick(repo :: GitRepo, commit :: GitCommit, options :: CherrypickOptions = CherrypickOptions())
- function chkargsok(ret::BlasInt)
+ function chkargsok(ret :: BlasInt)
- function chkdiag(diag::AbstractChar)
+ function chkdiag(diag :: AbstractChar)
- function chkfinite(A::AbstractMatrix)
+ function chkfinite(A :: AbstractMatrix)
- function chkfullrank(C::CholeskyPivoted)
+ function chkfullrank(C :: CholeskyPivoted)
- function chklapackerror(ret::BlasInt)
+ function chklapackerror(ret :: BlasInt)
- function chknonsingular(ret::BlasInt)
+ function chknonsingular(ret :: BlasInt)
- function chkposdef(ret::BlasInt)
+ function chkposdef(ret :: BlasInt)
- function chkside(side::AbstractChar)
+ function chkside(side :: AbstractChar)
- function chktrans(trans::AbstractChar)
+ function chktrans(trans :: AbstractChar)
- function chkuplo(uplo::AbstractChar)
+ function chkuplo(uplo :: AbstractChar)
- function chkuplofinite(A::AbstractMatrix, uplo::AbstractChar)
+ function chkuplofinite(A :: AbstractMatrix, uplo :: AbstractChar)
- function chmod(path::AbstractString, mode::Integer; recursive::Bool=false)
+ function chmod(path :: AbstractString, mode :: Integer, recursive :: Bool = false)
- function cholesky!(A::AbstractMatrix, ::NoPivot = NoPivot(); check::Bool = true)
+ function cholesky!(A :: AbstractMatrix, ??? :: NoPivot = NoPivot(), check :: Bool = true)
- function cholesky!(A::AbstractMatrix, ::RowMaximum; tol = 0.0, check::Bool = true)
+ function cholesky!(A :: AbstractMatrix, ??? :: RowMaximum, tol = 0.0, check :: Bool = true)
- function cholesky!(A::Diagonal, ::NoPivot = NoPivot(); check::Bool = true)
+ function cholesky!(A :: Diagonal, ??? :: NoPivot = NoPivot(), check :: Bool = true)
- function cholesky!(A::RealHermSymComplexHerm, ::NoPivot = NoPivot(); check::Bool = true)
+ function cholesky!(A :: RealHermSymComplexHerm, ??? :: NoPivot = NoPivot(), check :: Bool = true)
- function cholesky(A::AbstractMatrix{Float16}, ::NoPivot=NoPivot(); check::Bool = true)
+ function cholesky(A :: AbstractMatrix{Float16}, ??? :: NoPivot = NoPivot(), check :: Bool = true)
- function cholesky(A::AbstractMatrix{Float16}, ::RowMaximum; tol = 0.0, check::Bool = true)
+ function cholesky(A :: AbstractMatrix{Float16}, ??? :: RowMaximum, tol = 0.0, check :: Bool = true)
- function cholesky(S::RealHermSymComplexHerm{<:Real,<:SymTridiagonal}, ::NoPivot = NoPivot(); check::Bool = true)
+ function cholesky(S :: RealHermSymComplexHerm{??? <: Real, ??? <: SymTridiagonal}, ??? :: NoPivot = NoPivot(), check :: Bool = true)
- function cholesky(S::SymTridiagonal, ::NoPivot = NoPivot(); check::Bool = true)
+ function cholesky(S :: SymTridiagonal, ??? :: NoPivot = NoPivot(), check :: Bool = true)
- function cholesky(x::Number, uplo::Symbol=:U)
+ function cholesky(x :: Number, uplo :: Symbol = :U)
- function chomp(s::AbstractString)
+ function chomp(s :: AbstractString)
- function chomp(s::String)
+ function chomp(s :: String)
- function choosetests(choices = [])
+ function choosetests(choices = [])
- function chop(s::AbstractString; head::Integer = 0, tail::Integer = 1)
+ function chop(s :: AbstractString, head :: Integer = 0, tail :: Integer = 1)
- function chopprefix(s::AbstractString, prefix::AbstractString)
+ function chopprefix(s :: AbstractString, prefix :: AbstractString)
- function chopprefix(s::AbstractString, prefix::Regex)
+ function chopprefix(s :: AbstractString, prefix :: Regex)
- function chopsuffix(s::AbstractString, suffix::AbstractString)
+ function chopsuffix(s :: AbstractString, suffix :: AbstractString)
- function chopsuffix(s::AbstractString, suffix::Regex)
+ function chopsuffix(s :: AbstractString, suffix :: Regex)
- function chown(path::AbstractString, owner::Integer, group::Integer=-1)
+ function chown(path :: AbstractString, owner :: Integer, group :: Integer = -1)
- function circcopy!(dest, src)
+ function circcopy!(dest, src)
- function circshift!(a::AbstractVector, shift::Integer)
+ function circshift!(a :: AbstractVector, shift :: Integer)
- function circshift!(dest::AbstractArray{T,N}, src, shiftamt::DimsInteger) where {T,N}
+ function circshift!(dest :: AbstractArray{T, N}, src, shiftamt :: DimsInteger) where T, N
- function circshift(a::AbstractArray, shiftamt)
+ function circshift(a :: AbstractArray, shiftamt)
- function circshift(a::AbstractArray, shiftamt::Real)
+ function circshift(a :: AbstractArray, shiftamt :: Real)
- function cis(A::Union{RealHermSymComplexHerm,SymTridiagonal{<:Real}})
+ function cis(A :: Union{RealHermSymComplexHerm, SymTridiagonal{??? <: Real}})
- function cis(theta::Real)
+ function cis(theta :: Real)
- function cis(z::Complex)
+ function cis(z :: Complex)
- function cis_fast(x::T) where {T<:FloatTypes}
+ function cis_fast(x :: T) where T <: FloatTypes
- function cispi(z::Complex)
+ function cispi(z :: Complex)
- function clamp!(x::AbstractArray, lo, hi)
+ function clamp!(x :: AbstractArray, lo, hi)
- function cld(x::T, y::T) where T<:Integer
+ function cld(x :: T, y :: T) where T <: Integer
- function cld(x::T, y::T) where T<:Unsigned
+ function cld(x :: T, y :: T) where T <: Unsigned
- function cleanup!(node::StackFrameTree)
+ function cleanup!(node :: StackFrameTree)
- function cleanup()
+ function cleanup
- function cleanup(r::GitRepo)
+ function cleanup(r :: GitRepo)
- function clear()
+ function clear
- function clear_hint(s::ModeState)
+ function clear_hint(s :: ModeState)
- function clear_input_area(terminal::AbstractTerminal, s::PromptState)
+ function clear_input_area(terminal :: AbstractTerminal, s :: PromptState)
- function clipboard()
+ function clipboard
- function clipboard(x)
+ function clipboard(x)
- function clipboard(x::AbstractString)
+ function clipboard(x :: AbstractString)
- function clipboardcmd()
+ function clipboardcmd
- function close(c::Channel, @nospecialize(excp::Exception))
+ function close(c :: Channel, excp :: Exception)
- function close(f::File)
+ function close(f :: File)
- function close(io::GenericIOBuffer{T}) where T
+ function close(io :: GenericIOBuffer{T}) where T
- function close(s::BufferStream)
+ function close(s :: BufferStream)
- function close(s::IOStream)
+ function close(s :: IOStream)
- function close(stream::Union{LibuvStream, LibuvServer})
+ function close(stream :: Union{LibuvStream, LibuvServer})
- function close(t::FDWatcher)
+ function close(t :: FDWatcher)
- function close(t::Union{FileMonitor, FolderMonitor, PollingFileWatcher})
+ function close(t :: Union{FileMonitor, FolderMonitor, PollingFileWatcher})
- function close(t::Union{Timer, AsyncCondition})
+ function close(t :: Union{Timer, AsyncCondition})
- function close(t::_FDWatcher, readable::Bool, writable::Bool)
+ function close(t :: _FDWatcher, readable :: Bool, writable :: Bool)
- function close_chnl_on_taskdone(t::Task, c::Channel)
+ function close_chnl_on_taskdone(t :: Task, c :: Channel)
- function close_libs()
+ function close_libs
- function close_path_completion(str, startpos, r, paths, pos)
+ function close_path_completion(str, startpos, r, paths, pos)
- function close_pipe_sync(handle::RawFD)
+ function close_pipe_sync(handle :: RawFD)
- function close_pipe_sync(handle::WindowsRawSocket)
+ function close_pipe_sync(handle :: WindowsRawSocket)
- function closefunc(_)
+ function closefunc(_)
- function closewrite(io::GenericIOBuffer)
+ function closewrite(io :: GenericIOBuffer)
- function closewrite(s::LibuvStream)
+ function closewrite(s :: LibuvStream)
- function clotest()
+ function clotest
- function cmd_gen(parsed)
+ function cmd_gen(parsed)
- function cmp(A::AbstractVector, B::AbstractVector)
+ function cmp(A :: AbstractVector, B :: AbstractVector)
- function cmp(a::AbstractString, b::AbstractString)
+ function cmp(a :: AbstractString, b :: AbstractString)
- function cmp(a::Array{UInt8,1}, b::Array{UInt8,1})
+ function cmp(a :: Array{UInt8, DependentType@1fb3ebeb}, b :: Array{UInt8, DependentType@548c4f57})
- function cmp(a::Memory{UInt8}, b::Memory{UInt8})
+ function cmp(a :: Memory{UInt8}, b :: Memory{UInt8})
- function cmp(a::String, b::String)
+ function cmp(a :: String, b :: String)
- function cmp(a::SubString{String}, b::SubString{String})
+ function cmp(a :: SubString{String}, b :: SubString{String})
- function cmp(x::BigFloat, y::BigInt)
+ function cmp(x :: BigFloat, y :: BigInt)
- function cmp(x::BigFloat, y::CdoubleMax)
+ function cmp(x :: BigFloat, y :: CdoubleMax)
- function cmp(x::BigFloat, y::ClongMax)
+ function cmp(x :: BigFloat, y :: ClongMax)
- function cmp(x::BigFloat, y::CulongMax)
+ function cmp(x :: BigFloat, y :: CulongMax)
- function cmp_showf(printfunc, io, A; options = ())
+ function cmp_showf(printfunc, io, A, options = ())
- function cmp_sn(w, hi, lo, slopbits=0)
+ function cmp_sn(w, hi, lo, slopbits = 0)
- function cmp_sn2(w, hi, lo, slopbits=0)
+ function cmp_sn2(w, hi, lo, slopbits = 0)
- function code_coverage_test()
+ function code_coverage_test
- function code_lowered(@nospecialize(f), @nospecialize(t=Tuple); generated::Bool=true, debuginfo::Symbol=:default)
+ function code_lowered(f, t = Tuple, generated :: Bool = true, debuginfo :: Symbol = :default)
- function codeinfo_for_const(interp::AbstractInterpreter, mi::MethodInstance, worlds::WorldRange, @nospecialize(val))
+ function codeinfo_for_const(interp :: AbstractInterpreter, mi :: MethodInstance, worlds :: WorldRange, val)
- function codeunit(s::SubString, i::Integer)
+ function codeunit(s :: SubString, i :: Integer)
- function coerce(T::Type, x)
+ function coerce(T :: Type, x)
- function collect(itr::Generator)
+ function collect(itr :: Generator)
- function collect_argtypes(interp::AbstractInterpreter, ea::Vector{Any}, vtypes::Union{VarTable,Nothing}, sv::AbsIntState)
+ function collect_argtypes(interp :: AbstractInterpreter, ea :: Vector{Any}, vtypes :: Union{VarTable, Nothing}, sv :: AbsIntState)
- function collect_const_args(argtypes::Vector{Any}, start::Int)
+ function collect_const_args(argtypes :: Vector{Any}, start :: Int)
- function collect_eachmatch(re, str; overlap=false)
+ function collect_eachmatch(re, str, overlap = false)
- function collect_limitations!(@nospecialize(typ), ::IRInterpretationState)
+ function collect_limitations!(typ, ??? :: IRInterpretationState)
- function collect_limitations!(@nospecialize(typ), sv::InferenceState)
+ function collect_limitations!(typ, sv :: InferenceState)
- function collect_manifest_warnings()
+ function collect_manifest_warnings
- function collect_preferences(project_toml::String, uuid::Union{UUID,Nothing})
+ function collect_preferences(project_toml :: String, uuid :: Union{UUID, Nothing})
- function collect_test_logs(f; kwargs...)
+ function collect_test_logs(f, kwargs...)
- function collect_to!(dest::AbstractArray{T}, itr, offs, st) where T
+ function collect_to!(dest :: AbstractArray{T}, itr, offs, st) where T
- function collect_to_with_first!(dest, v1, itr, st)
+ function collect_to_with_first!(dest, v1, itr, st)
- function collect_to_with_first!(dest::AbstractArray, v1, itr, st)
+ function collect_to_with_first!(dest :: AbstractArray, v1, itr, st)
- function combine_eltypes(f, args::Tuple)
+ function combine_eltypes(f, args :: Tuple)
- function combine_styles(bc::Broadcasted)
+ function combine_styles(bc :: Broadcasted)
- function commit(rb::GitRebase, sig::GitSignature)
+ function commit(rb :: GitRebase, sig :: GitSignature)
- function commit_line(s::MIState)
+ function commit_line(s :: MIState)
- function committer(c::GitCommit)
+ function committer(c :: GitCommit)
- function common_prefix(completions::Vector{String})
+ function common_prefix(completions :: Vector{String})
- function compact!(code::IRCode, allow_cfg_transforms::Bool=false)
+ function compact!(code :: IRCode, allow_cfg_transforms :: Bool = false)
- function compact(io::GenericIOBuffer)
+ function compact(io :: GenericIOBuffer)
- function compare(a, b)
+ function compare(a, b)
- function compare_default(a::String, b::String, a_requested::Bool, b_requested::Bool)
+ function compare_default(a :: String, b :: String, a_requested :: Bool, b_requested :: Bool)
- function compare_inconsistent()
+ function compare_inconsistent
- function compare_inconsistent(x::T) where T
+ function compare_inconsistent(x :: T) where T
- function compare_large_struct(a)
+ function compare_large_struct(a)
- function compare_version_cap(a::String, b::String, a_requested::Bool, b_requested::Bool)
+ function compare_version_cap(a :: String, b :: String, a_requested :: Bool, b_requested :: Bool)
- function compatible_vatuple(a::DataType, b::DataType)
+ function compatible_vatuple(a :: DataType, b :: DataType)
- function compile(pattern::AbstractString, options::Integer)
+ function compile(pattern :: AbstractString, options :: Integer)
- function compile(regex::Regex)
+ function compile(regex :: Regex)
- function compile(x, ivdep)
+ function compile(x, ivdep)
- function compilecache(pkg::PkgId, internal_stderr::IO = stderr, internal_stdout::IO = stdout)
+ function compilecache(pkg :: PkgId, internal_stderr :: IO = stderr, internal_stdout :: IO = stdout)
- function compilecache_dir(pkg::PkgId)
+ function compilecache_dir(pkg :: PkgId)
- function compilecache_path(pkg::PkgId, prefs_hash::UInt64; project::String=something(Base.active_project(), ""))::String
+ function compilecache_path(pkg :: PkgId, prefs_hash :: UInt64, project :: String = something(Base.active_project(),""))
- function compiled_conv(::Type{T}, x) where T
+ function compiled_conv(??? :: Type{T}, x) where T
- function complete!(tpdum::TwoPhaseDefUseMap)
+ function complete!(tpdum :: TwoPhaseDefUseMap)
- function complete(compact::IncrementalCompact)
+ function complete(compact :: IncrementalCompact)
- function complete_any_methods(ex_org::Expr, callee_module::Module, context_module::Module, moreargs::Bool, shift::Bool)
+ function complete_any_methods(ex_org :: Expr, callee_module :: Module, context_module :: Module, moreargs :: Bool, shift :: Bool)
- function complete_expanduser(path::AbstractString, r)
+ function complete_expanduser(path :: AbstractString, r)
- function complete_from_list(T::Type, list::Vector{String}, s::Union{String,SubString{String}})
+ function complete_from_list(T :: Type, list :: Vector{String}, s :: Union{String, SubString{String}})
- function complete_identifiers!(suggestions::Vector{Completion}, @nospecialize(ffunc::Function), context_module::Module, string::String, name::String, pos::Int, dotpos::Int, startpos::Int, comp_keywords=false)
+ function complete_identifiers!(suggestions :: Vector{Completion}, ffunc :: Function, context_module :: Module, string :: String, name :: String, pos :: Int, dotpos :: Int, startpos :: Int, comp_keywords = false)
- function complete_keyword_argument(partial, last_idx, context_module)
+ function complete_keyword_argument(partial, last_idx, context_module)
- function complete_line(c::LatexCompletions, s)
+ function complete_line(c :: LatexCompletions, s)
- function complete_line(c::REPLCompletionProvider, s::PromptState, mod::Module)
+ function complete_line(c :: REPLCompletionProvider, s :: PromptState, mod :: Module)
- function complete_line(c::ShellCompletionProvider, s::PromptState)
+ function complete_line(c :: ShellCompletionProvider, s :: PromptState)
- function complete_line(s::MIState)
+ function complete_line(s :: MIState)
- function complete_line(s::PromptState, repeats::Int, mod::Module)
+ function complete_line(s :: PromptState, repeats :: Int, mod :: Module)
- function complete_line(s::SearchState, repeats, mod::Module)
+ function complete_line(s :: SearchState, repeats, mod :: Module)
- function complete_methods!(out::Vector{Completion}, @nospecialize(funct), args_ex::Vector{Any}, kwargs_ex::Set{Symbol}, max_method_completions::Int, exact_nargs::Bool)
+ function complete_methods!(out :: Vector{Completion}, funct, args_ex :: Vector{Any}, kwargs_ex :: Set{Symbol}, max_method_completions :: Int, exact_nargs :: Bool)
- function complete_methods(ex_org::Expr, context_module::Module=Main, shift::Bool=false)
+ function complete_methods(ex_org :: Expr, context_module :: Module = Main, shift :: Bool = false)
- function complete_methods_args(ex::Expr, context_module::Module, default_any::Bool, allow_broadcasting::Bool)
+ function complete_methods_args(ex :: Expr, context_module :: Module, default_any :: Bool, allow_broadcasting :: Bool)
- function complete_symbol(@nospecialize(ex), name::String, @nospecialize(ffunc), context_module::Module=Main)
+ function complete_symbol(ex, name :: String, ffunc, context_module :: Module = Main)
- function completely_dead_try_catch()
+ function completely_dead_try_catch
- function completes_global(x, name)
+ function completes_global(x, name)
- function completions(string::String, pos::Int, context_module::Module=Main, shift::Bool=true)
+ function completions(string :: String, pos :: Int, context_module :: Module = Main, shift :: Bool = true)
- function complex(A::AbstractArray{T}) where T
+ function complex(A :: AbstractArray{T}) where T
- function complicated_identity(x)
+ function complicated_identity(x)
- function compute!(a, b)
+ function compute!(a, b)
- function compute(T, ax, ay, bx, by)
+ function compute(T, ax, ay, bx, by)
- function compute(a, b)
+ function compute(a, b)
- function compute_annotations(f, types)
+ function compute_annotations(f, types)
- function compute_assumed_setting(@nospecialize(setting), val::Bool=true)
+ function compute_assumed_setting(setting, val :: Bool = true)
- function compute_basic_blocks(stmts::Vector{Any})
+ function compute_basic_blocks(stmts :: Vector{Any})
- function compute_dateformat_regex(conversion_specifiers)
+ function compute_dateformat_regex(conversion_specifiers)
- function compute_domtree_nodes!(domtree::GenericDomTree{IsPostDom}) where {IsPostDom}
+ function compute_domtree_nodes!(domtree :: GenericDomTree{IsPostDom}) where IsPostDom
- function compute_frameinfo(ir::IRCode)
+ function compute_frameinfo(ir :: IRCode)
- function compute_idem_n(n)
+ function compute_idem_n(n)
- function compute_inlining_depth(linetable::Vector, iline::Int32)
+ function compute_inlining_depth(linetable :: Vector, iline :: Int32)
- function compute_ir_line_annotations(code::IRCode)
+ function compute_ir_line_annotations(code :: IRCode)
- function compute_ir_rettype(ir::IRCode)
+ function compute_ir_rettype(ir :: IRCode)
- function compute_itspace(A, ::Val{dims}) where {dims}
+ function compute_itspace(A, ??? :: Val{dims}) where dims
- function compute_linindex(f, s, IP::Tuple, I::Tuple{Any, Vararg{Any}})
+ function compute_linindex(f, s, IP :: Tuple, I :: Tuple{Any, Vararg{Any}})
- function compute_linindex(parent, I::NTuple{N,Any}) where N
+ function compute_linindex(parent, I :: NTuple{N, Any}) where N
- function compute_live_ins(cfg::CFG, defs::Vector{Int}, uses::Vector{Int})
+ function compute_live_ins(cfg :: CFG, defs :: Vector{Int}, uses :: Vector{Int})
- function compute_live_ins(cfg::CFG, du::SSADefUse)
+ function compute_live_ins(cfg :: CFG, du :: SSADefUse)
- function compute_loc_stack(linetable::Vector, line::Int32)
+ function compute_loc_stack(linetable :: Vector, line :: Int32)
- function compute_oc_signature(ir::IRCode, nargs::Int, isva::Bool)
+ function compute_oc_signature(ir :: IRCode, nargs :: Int, isva :: Bool)
- function compute_points()
+ function compute_points
- function compute_preds(bbs::Vector{BasicBlock}, result_bbs::Vector{Int}, bb_rename_pred::Vector{Int}, i::Int)
+ function compute_preds(bbs :: Vector{BasicBlock}, result_bbs :: Vector{Int}, bb_rename_pred :: Vector{Int}, i :: Int)
- function compute_succs(merged_succ::Vector{Int}, bbs::Vector{BasicBlock}, result_bbs::Vector{Int}, bb_rename_succ::Vector{Int}, i::Int)
+ function compute_succs(merged_succ :: Vector{Int}, bbs :: Vector{BasicBlock}, result_bbs :: Vector{Int}, bb_rename_succ :: Vector{Int}, i :: Int)
- function compute_trycatch(code::Vector{Any}, ip::BitSet)
+ function compute_trycatch(code :: Vector{Any}, ip :: BitSet)
- function compute_value_for_block(ir::IRCode, domtree::DomTree, allblocks::BitSet, du::SSADefUse, phinodes::IdDict{Int, SSAValue}, fidx::Int, curblock::Int)
+ function compute_value_for_block(ir :: IRCode, domtree :: DomTree, allblocks :: BitSet, du :: SSADefUse, phinodes :: IdDict{Int, SSAValue}, fidx :: Int, curblock :: Int)
- function concurrency_violation()
+ function concurrency_violation
- function cond(A::AbstractMatrix, p::Real=2)
+ function cond(A :: AbstractMatrix, p :: Real = 2)
- function cond(J::UniformScaling{T}) where T
+ function cond(J :: UniformScaling{T}) where T
- function conditional_argtype(@nospecialize(rt), @nospecialize(sig), argtypes::Vector{Any}, i::Int)
+ function conditional_argtype(rt, sig, argtypes :: Vector{Any}, i :: Int)
- function conditional_change(Lᵢ::AbstractLattice, state::VarTable, @nospecialize(typ), slot::Int)
+ function conditional_change(Lᵢ :: AbstractLattice, state :: VarTable, typ, slot :: Int)
- function conditional_successors_may_throw(lazypostdomtree::LazyPostDomtree, ir::IRCode, bb::Int)
+ function conditional_successors_may_throw(lazypostdomtree :: LazyPostDomtree, ir :: IRCode, bb :: Int)
- function conditionally_call_ambig(b::Bool, a)
+ function conditionally_call_ambig(b :: Bool, a)
- function condskeel(A::AbstractMatrix, x::AbstractVector, p::Real=Inf)
+ function condskeel(A :: AbstractMatrix, x :: AbstractVector, p :: Real = Inf)
- function config(parsers::Function...)
+ function config(parsers :: Function...)
- function conflicting_assignment_conditional()
+ function conflicting_assignment_conditional
- function connect!(sock::PipeEndpoint, path::AbstractString)
+ function connect!(sock :: PipeEndpoint, path :: AbstractString)
- function connect!(sock::TCPSocket, host::AbstractString, port::Integer)
+ function connect!(sock :: TCPSocket, host :: AbstractString, port :: Integer)
- function connect!(sock::TCPSocket, host::Union{IPv4, IPv6}, port::Integer)
+ function connect!(sock :: TCPSocket, host :: Union{IPv4, IPv6}, port :: Integer)
- function connect(sock::LibuvStream, args...)
+ function connect(sock :: LibuvStream, args...)
- function connected(rmt::GitRemote)
+ function connected(rmt :: GitRemote)
- function const_finalization(io)
+ function const_finalization(io)
- function const_implies_local()
+ function const_implies_local
- function const_prop_argument_heuristic(interp::AbstractInterpreter, arginfo::ArgInfo, sv::AbsIntState)
+ function const_prop_argument_heuristic(interp :: AbstractInterpreter, arginfo :: ArgInfo, sv :: AbsIntState)
- function const_prop_enabled(interp::AbstractInterpreter, sv::AbsIntState, match::MethodMatch)
+ function const_prop_enabled(interp :: AbstractInterpreter, sv :: AbsIntState, match :: MethodMatch)
- function const_prop_entry_heuristic(interp::AbstractInterpreter, result::MethodCallResult, si::StmtInfo, sv::AbsIntState)
+ function const_prop_entry_heuristic(interp :: AbstractInterpreter, result :: MethodCallResult, si :: StmtInfo, sv :: AbsIntState)
- function constargs(A, B::Const)
+ function constargs(A, B :: Const)
- function constprop_setting(@nospecialize setting)
+ function constprop_setting(setting)
- function constrains_param(var::TypeVar, @nospecialize(typ), covariant::Bool, type_constrains::Bool=false)
+ function constrains_param(var :: TypeVar, typ, covariant :: Bool, type_constrains :: Bool = false)
- function construct_domtree(blocks::Vector{BasicBlock})
+ function construct_domtree(blocks :: Vector{BasicBlock})
- function construct_postdomtree(blocks::Vector{BasicBlock})
+ function construct_postdomtree(blocks :: Vector{BasicBlock})
- function consume_upto!(list, s, i, j)
+ function consume_upto!(list, s, i, j)
- function consumed!(buffer::Buffer, n::Integer)
+ function consumed!(buffer :: Buffer, n :: Integer)
- function contains_is(itr, @nospecialize(x))
+ function contains_is(itr, x)
- function content(blob::GitBlob)
+ function content(blob :: GitBlob)
- function contextual_prompt(repl::LineEditREPL, prompt::Union{String,Function})
+ function contextual_prompt(repl :: LineEditREPL, prompt :: Union{String, Function})
- function contractuser(path::AbstractString)
+ function contractuser(path :: AbstractString)
- function convert(::Type{NTuple{2, UInt64}}, uuid::UUID)
+ function convert(??? :: Type{NTuple{DependentType@1218025c, UInt64}}, uuid :: UUID)
- function convert(::Type{NTuple{4, UInt32}}, uuid::UUID)
+ function convert(??? :: Type{NTuple{DependentType@816f27d, UInt32}}, uuid :: UUID)
- function convert(::Type{NT}, nt::NamedTuple{names}) where {names, NT<:NamedTuple{names}}
+ function convert(??? :: Type{NT}, nt :: NamedTuple{names}) where names, NT <: NamedTuple{names}
- function convert(::Type{NamedTuple{names,T}}, nt::NamedTuple{names}) where {names,T<:Tuple}
+ function convert(??? :: Type{NamedTuple{names, T}}, nt :: NamedTuple{names}) where names, T <: Tuple
- function convert(::Type{Pair{A,B}}, x::Pair) where {A,B}
+ function convert(??? :: Type{Pair{A, B}}, x :: Pair) where A, B
- function convert(::Type{RoundingMode}, r::MPFRRoundingMode)
+ function convert(??? :: Type{RoundingMode}, r :: MPFRRoundingMode)
- function convert(::Type{T}, A::AbstractMatrix) where T<:Diagonal
+ function convert(??? :: Type{T}, A :: AbstractMatrix) where T <: Diagonal
- function convert(::Type{T}, x::AbstractDict) where T<:AbstractDict
+ function convert(??? :: Type{T}, x :: AbstractDict) where T <: AbstractDict
- function convert(::Type{T}, x::NTuple{N,Any}) where {N, T<:Tuple}
+ function convert(??? :: Type{T}, x :: NTuple{N, Any}) where N, T <: Tuple
- function convert_cache_mode(cache_mode::Symbol)
+ function convert_cache_mode(cache_mode :: Symbol)
- function convert_to_ircode(ci::CodeInfo, sv::OptimizationState)
+ function convert_to_ircode(ci :: CodeInfo, sv :: OptimizationState)
- function copy!(dest::BitSet, src::BitSet)
+ function copy!(dest :: BitSet, src :: BitSet)
- function copy!(dest::SecretBuffer, src::SecretBuffer)
+ function copy!(dest :: SecretBuffer, src :: SecretBuffer)
- function copy!(dst::AbstractArray, src::AbstractArray)
+ function copy!(dst :: AbstractArray, src :: AbstractArray)
- function copy!(dst::AbstractDict, src::AbstractDict)
+ function copy!(dst :: AbstractDict, src :: AbstractDict)
- function copy!(dst::AbstractSet, src::AbstractSet)
+ function copy!(dst :: AbstractSet, src :: AbstractSet)
- function copy!(dst::AbstractVector, src::AbstractVector)
+ function copy!(dst :: AbstractVector, src :: AbstractVector)
- function copy!(dst::DFSTree, src::DFSTree)
+ function copy!(dst :: DFSTree, src :: DFSTree)
- function copy!(dst::MersenneTwister, src::MersenneTwister)
+ function copy!(dst :: MersenneTwister, src :: MersenneTwister)
- function copy(a::AbstractArray)
+ function copy(a :: AbstractArray)
- function copy(b::GenericIOBuffer)
+ function copy(b :: GenericIOBuffer)
- function copy(c::CodeInfo)
+ function copy(c :: CodeInfo)
- function copy(is::InstructionStream)
+ function copy(is :: InstructionStream)
- function copy_chunks!(dest::Vector{UInt64}, pos_d::Int, src::Vector{UInt64}, pos_s::Int, numbits::Int)
+ function copy_chunks!(dest :: Vector{UInt64}, pos_d :: Int, src :: Vector{UInt64}, pos_s :: Int, numbits :: Int)
- function copy_chunks_rtol!(chunks::Vector{UInt64}, pos_d::Int, pos_s::Int, numbits::Int)
+ function copy_chunks_rtol!(chunks :: Vector{UInt64}, pos_d :: Int, pos_s :: Int, numbits :: Int)
- function copy_exprs(@nospecialize(x))
+ function copy_exprs(x)
- function copy_similar(A::AdjointAbsMat, ::Type{T}) where {T}
+ function copy_similar(A :: AdjointAbsMat, ??? :: Type{T}) where T
- function copy_similar(A::TransposeAbsMat, ::Type{T}) where {T}
+ function copy_similar(A :: TransposeAbsMat, ??? :: Type{T}) where T
- function copy_to_array(A::AbstractArray)
+ function copy_to_array(A :: AbstractArray)
- function copy_to_bitarray_chunks!(Bc::Vector{UInt64}, pos_d::Int, C::Array{Bool}, pos_s::Int, numbits::Int)
+ function copy_to_bitarray_chunks!(Bc :: Vector{UInt64}, pos_d :: Int, C :: Array{Bool}, pos_s :: Int, numbits :: Int)
- function copy_to_bitarray_chunks!(Bc::Vector{UInt64}, pos_d::Int, C::StridedArray, pos_s::Int, numbits::Int)
+ function copy_to_bitarray_chunks!(Bc :: Vector{UInt64}, pos_d :: Int, C :: StridedArray, pos_s :: Int, numbits :: Int)
- function copy_to_bitarray_chunks!(Bc::Vector{UInt64}, pos_d::Int, C::StridedArray{<:Real}, pos_s::Int, numbits::Int)
+ function copy_to_bitarray_chunks!(Bc :: Vector{UInt64}, pos_d :: Int, C :: StridedArray{??? <: Real}, pos_s :: Int, numbits :: Int)
- function copy_transpose!(B::AbstractMatrix, ir_dest::AbstractUnitRange{Int}, jr_dest::AbstractUnitRange{Int}, tM::AbstractChar, M::AbstractVecOrMat, ir_src::AbstractUnitRange{Int}, jr_src::AbstractUnitRange{Int})
+ function copy_transpose!(B :: AbstractMatrix, ir_dest :: AbstractUnitRange{Int}, jr_dest :: AbstractUnitRange{Int}, tM :: AbstractChar, M :: AbstractVecOrMat, ir_src :: AbstractUnitRange{Int}, jr_src :: AbstractUnitRange{Int})
- function copybuf!(dst::IOBuffer, src::IOBuffer)
+ function copybuf!(dst :: IOBuffer, src :: IOBuffer)
- function copyline(out::GenericIOBuffer, s::IO; keep::Bool=false)
+ function copyline(out :: GenericIOBuffer, s :: IO, keep :: Bool = false)
- function copyline(out::IO, s::IO; keep::Bool=false)
+ function copyline(out :: IO, s :: IO, keep :: Bool = false)
- function copymutable(a::AbstractArray)
+ function copymutable(a :: AbstractArray)
- function copysign(x::BigFloat, y::BigFloat)
+ function copysign(x :: BigFloat, y :: BigFloat)
- function copyto!(A::AbstractMatrix, J::UniformScaling)
+ function copyto!(A :: AbstractMatrix, J :: UniformScaling)
- function copyto!(A::Diagonal, J::UniformScaling)
+ function copyto!(A :: Diagonal, J :: UniformScaling)
- function copyto!(A::T, B::T) where {T<:Union{LowerTriangular,UnitLowerTriangular}}
+ function copyto!(A :: T, B :: T) where T <: Union{LowerTriangular, UnitLowerTriangular}
- function copyto!(A::T, B::T) where {T<:Union{UpperTriangular,UnitUpperTriangular}}
+ function copyto!(A :: T, B :: T) where T <: Union{UpperTriangular, UnitUpperTriangular}
- function copyto!(A::Tridiagonal, J::UniformScaling)
+ function copyto!(A :: Tridiagonal, J :: UniformScaling)
- function copyto!(A::Union{Bidiagonal, SymTridiagonal}, J::UniformScaling)
+ function copyto!(A :: Union{Bidiagonal, SymTridiagonal}, J :: UniformScaling)
- function copyto!(B::AbstractVecOrMat, ir_dest::AbstractUnitRange{Int}, jr_dest::AbstractUnitRange{Int}, tM::AbstractChar, M::AbstractVecOrMat, ir_src::AbstractUnitRange{Int}, jr_src::AbstractUnitRange{Int})
+ function copyto!(B :: AbstractVecOrMat, ir_dest :: AbstractUnitRange{Int}, jr_dest :: AbstractUnitRange{Int}, tM :: AbstractChar, M :: AbstractVecOrMat, ir_src :: AbstractUnitRange{Int}, jr_src :: AbstractUnitRange{Int})
- function copyto!(S::SharedArray, R::SharedArray)
+ function copyto!(S :: SharedArray, R :: SharedArray)
- function copyto!(dest::AbstractArray, dstart::Integer, src)
+ function copyto!(dest :: AbstractArray, dstart :: Integer, src)
- function copyto!(dest::AbstractArray, dstart::Integer, src, sstart::Integer)
+ function copyto!(dest :: AbstractArray, dstart :: Integer, src, sstart :: Integer)
- function copyto!(dest::AbstractArray, dstart::Integer, src, sstart::Integer, n::Integer)
+ function copyto!(dest :: AbstractArray, dstart :: Integer, src, sstart :: Integer, n :: Integer)
- function copyto!(dest::AbstractArray, dstart::Integer, src::AbstractArray)
+ function copyto!(dest :: AbstractArray, dstart :: Integer, src :: AbstractArray)
- function copyto!(dest::AbstractArray, dstart::Integer, src::AbstractArray, sstart::Integer)
+ function copyto!(dest :: AbstractArray, dstart :: Integer, src :: AbstractArray, sstart :: Integer)
- function copyto!(dest::AbstractArray, src)
+ function copyto!(dest :: AbstractArray, src)
- function copyto!(dest::AbstractArray, src::AbstractArray)
+ function copyto!(dest :: AbstractArray, src :: AbstractArray)
- function copyto!(dest::AbstractMatrix, src::AbstractQ)
+ function copyto!(dest :: AbstractMatrix, src :: AbstractQ)
- function copyto!(dest::Bidiagonal, bc::Broadcasted{<:StructuredMatrixStyle})
+ function copyto!(dest :: Bidiagonal, bc :: Broadcasted{??? <: StructuredMatrixStyle})
- function copyto!(dest::BitArray, src::Array)
+ function copyto!(dest :: BitArray, src :: Array)
- function copyto!(dest::BitArray, src::BitArray)
+ function copyto!(dest :: BitArray, src :: BitArray)
- function copyto!(dest::Diagonal, bc::Broadcasted{<:StructuredMatrixStyle})
+ function copyto!(dest :: Diagonal, bc :: Broadcasted{??? <: StructuredMatrixStyle})
- function copyto!(dest::Hermitian, src::Hermitian)
+ function copyto!(dest :: Hermitian, src :: Hermitian)
- function copyto!(dest::LowerTriangular, bc::Broadcasted{<:StructuredMatrixStyle})
+ function copyto!(dest :: LowerTriangular, bc :: Broadcasted{??? <: StructuredMatrixStyle})
- function copyto!(dest::Memory, doffs::Integer, src::Memory, soffs::Integer, n::Integer)
+ function copyto!(dest :: Memory, doffs :: Integer, src :: Memory, soffs :: Integer, n :: Integer)
- function copyto!(dest::PermutedDimsArray{T,2,perm}, src::AbstractQ) where {T,perm}
+ function copyto!(dest :: PermutedDimsArray{T, DependentType@87aac27, perm}, src :: AbstractQ) where T, perm
- function copyto!(dest::SymTridiagonal, bc::Broadcasted{<:StructuredMatrixStyle})
+ function copyto!(dest :: SymTridiagonal, bc :: Broadcasted{??? <: StructuredMatrixStyle})
- function copyto!(dest::Symmetric, src::Symmetric)
+ function copyto!(dest :: Symmetric, src :: Symmetric)
- function copyto!(dest::Tridiagonal, bc::Broadcasted{<:StructuredMatrixStyle})
+ function copyto!(dest :: Tridiagonal, bc :: Broadcasted{??? <: StructuredMatrixStyle})
- function copyto!(dest::UpperTriangular, bc::Broadcasted{<:StructuredMatrixStyle})
+ function copyto!(dest :: UpperTriangular, bc :: Broadcasted{??? <: StructuredMatrixStyle})
- function copyto!(deststyle::IndexStyle, dest::AbstractArray, srcstyle::IndexStyle, src::AbstractArray)
+ function copyto!(deststyle :: IndexStyle, dest :: AbstractArray, srcstyle :: IndexStyle, src :: AbstractArray)
- function copyto_axcheck!(dest, src)
+ function copyto_axcheck!(dest, src)
- function copyto_nonleaf!(dest, bc::Broadcasted, iter, state, count)
+ function copyto_nonleaf!(dest, bc :: Broadcasted, iter, state, count)
- function copyto_unaliased!(deststyle::IndexStyle, dest::AbstractArray, srcstyle::IndexStyle, src::AbstractArray)
+ function copyto_unaliased!(deststyle :: IndexStyle, dest :: AbstractArray, srcstyle :: IndexStyle, src :: AbstractArray)
- function copyuntil(out::IO, io::GenericIOBuffer, delim::UInt8; keep::Bool=false)
+ function copyuntil(out :: IO, io :: GenericIOBuffer, delim :: UInt8, keep :: Bool = false)
- function copyuntil(out::IO, io::IO, target::AbstractString; keep::Bool=false)
+ function copyuntil(out :: IO, io :: IO, target :: AbstractString, keep :: Bool = false)
- function copyuntil(out::IO, s::IO, delim::AbstractChar; keep::Bool=false)
+ function copyuntil(out :: IO, s :: IO, delim :: AbstractChar, keep :: Bool = false)
- function copyuntil(out::IOBuffer, s::IOStream, delim::UInt8; keep::Bool=false)
+ function copyuntil(out :: IOBuffer, s :: IOStream, delim :: UInt8, keep :: Bool = false)
- function copyuntil(out::IOStream, s::IOStream, delim::UInt8; keep::Bool=false)
+ function copyuntil(out :: IOStream, s :: IOStream, delim :: UInt8, keep :: Bool = false)
- function correct_rounding_requires_increment(x, rounding_mode, sign_bit::Bool)
+ function correct_rounding_requires_increment(x, rounding_mode, sign_bit :: Bool)
- function corrupt_header(bytes, offset, val)
+ function corrupt_header(bytes, offset, val)
- function cos(A::AbstractMatrix{<:Complex})
+ function cos(A :: AbstractMatrix{??? <: Complex})
- function cos(A::AbstractMatrix{<:Real})
+ function cos(A :: AbstractMatrix{??? <: Real})
- function cos(x::T) where T<:Union{Float32, Float64}
+ function cos(x :: T) where T <: Union{Float32, Float64}
- function cos(z::Complex{T}) where T
+ function cos(z :: Complex{T}) where T
- function cosd(x::Real)
+ function cosd(x :: Real)
- function cosh(A::AbstractMatrix)
+ function cosh(A :: AbstractMatrix)
- function cosh(x::T) where T<:Union{Float32,Float64}
+ function cosh(x :: T) where T <: Union{Float32, Float64}
- function cosh(z::Complex)
+ function cosh(z :: Complex)
- function cosh_kernel(x2::Float32)
+ function cosh_kernel(x2 :: Float32)
- function cosh_kernel(x2::Float64)
+ function cosh_kernel(x2 :: Float64)
- function cospi(x::T) where T<:IEEEFloat
+ function cospi(x :: T) where T <: IEEEFloat
- function cospi(z::Complex{T}) where T
+ function cospi(z :: Complex{T}) where T
- function count!(tpdum::TwoPhaseDefUseMap, arg::SSAValue)
+ function count!(tpdum :: TwoPhaseDefUseMap, arg :: SSAValue)
- function count(diff::GitDiff)
+ function count(diff :: GitDiff)
- function count(idx::GitIndex)
+ function count(idx :: GitIndex)
- function count(rb::GitRebase)
+ function count(rb :: GitRebase)
- function count(t::Union{AbstractChar,AbstractString,AbstractPattern}, s::AbstractString; overlap::Bool=false)
+ function count(t :: Union{AbstractChar, AbstractString, AbstractPattern}, s :: AbstractString, overlap :: Bool = false)
- function count(tree::GitTree)
+ function count(tree :: GitTree)
- function count11167()
+ function count11167
- function count_added_node!(compact::IncrementalCompact, @nospecialize(v))
+ function count_added_node!(compact :: IncrementalCompact, v)
- function count_const_size(@nospecialize(x), count_self::Bool = true)
+ function count_const_size(x, count_self :: Bool = true)
- function count_expr_push(ex::Expr, head::Symbol, counter)
+ function count_expr_push(ex :: Expr, head :: Symbol, counter)
- function count_int(val::Int, arr::Vector{Int})
+ function count_int(val :: Int, arr :: Vector{Int})
- function count_meta_loc(exprs)
+ function count_meta_loc(exprs)
- function count_ones(x::BigInt)
+ function count_ones(x :: BigInt)
- function count_zeros(x::BigInt)
+ function count_zeros(x :: BigInt)
- function counthunks(blame::GitBlame)
+ function counthunks(blame :: GitBlame)
- function countlines(io::IO; eol::AbstractChar='\n')
+ function countlines(io :: IO, eol :: AbstractChar = '\n')
- function coverage_enabled(m::Module)
+ function coverage_enabled(m :: Module)
- function cp_and_test(src::AbstractString, dst::AbstractString, follow_symlinks::Bool)
+ function cp_and_test(src :: AbstractString, dst :: AbstractString, follow_symlinks :: Bool)
- function cp_follow_symlinks_false_check(s, d, file_txt; force=false)
+ function cp_follow_symlinks_false_check(s, d, file_txt, force = false)
- function cp_follow_symlinks_false_check(s, d; force=false)
+ function cp_follow_symlinks_false_check(s, d, force = false)
- function cprop_inline_bar(x...)
+ function cprop_inline_bar(x...)
- function cprop_inline_baz1()
+ function cprop_inline_baz1
- function cprop_inline_baz2()
+ function cprop_inline_baz2
- function cpu_info()
+ function cpu_info
- function cpu_summary(io::IO=stdout, cpu::AbstractVector{CPUinfo} = cpu_info())
+ function cpu_summary(io :: IO = stdout, cpu :: AbstractVector{CPUinfo} = cpu_info())
- function crc32c_sw(io::IO, nb::Integer, crc::UInt32=0x00000000)
+ function crc32c_sw(io :: IO, nb :: Integer, crc :: UInt32 = 0x00000000)
- function crc32c_sw(s::Union{String, SubString{String}}, crc::UInt32=0x00000000)
+ function crc32c_sw(s :: Union{String, SubString{String}}, crc :: UInt32 = 0x00000000)
- function crc6611(spec)
+ function crc6611(spec)
- function crc6634(spec)
+ function crc6634(spec)
- function create_dead_object13995(finalized)
+ function create_dead_object13995(finalized)
- function create_match_context()
+ function create_match_context
- function create_match_data(re)
+ function create_match_data(re)
- function create_serialization_stream(f::Function)
+ function create_serialization_stream(f :: Function)
- function create_test_overrides_toml(temp_dir::String)
+ function create_test_overrides_toml(temp_dir :: String)
- function credential_helpers(cfg::GitConfig, cred::GitCredential)
+ function credential_helpers(cfg :: GitConfig, cred :: GitCredential)
- function credential_identifier(scheme::AbstractString, host::AbstractString)
+ function credential_identifier(scheme :: AbstractString, host :: AbstractString)
- function credential_identifier(url::AbstractString)
+ function credential_identifier(url :: AbstractString)
- function cross(a::AbstractVector, b::AbstractVector)
+ function cross(a :: AbstractVector, b :: AbstractVector)
- function cstr(s)
+ function cstr(s)
- function cumprod(A::AbstractArray; dims::Integer)
+ function cumprod(A :: AbstractArray, dims :: Integer)
- function cumsum!(out::AbstractArray, v::AbstractVector; dims::Integer=1)
+ function cumsum!(out :: AbstractArray, v :: AbstractVector, dims :: Integer = 1)
- function cumsum(A::AbstractArray{T}; dims::Integer) where T
+ function cumsum(A :: AbstractArray{T}, dims :: Integer) where T
- function cumsum_ssamap!(ssachangemap::Vector{Int})
+ function cumsum_ssamap!(ssachangemap :: Vector{Int})
- function cumulative_compile_time_ns()
+ function cumulative_compile_time_ns
- function cumulative_compile_timing(b::Bool)
+ function cumulative_compile_timing(b :: Bool)
- function current(rb::GitRebase)
+ function current(rb :: GitRebase)
- function current_exceptions(task::Task=current_task(); backtrace::Bool=true)
+ function current_exceptions(task :: Task = current_task(), backtrace :: Bool = true)
- function current_image_targets()
+ function current_image_targets
- function current_logstate()
+ function current_logstate
- function current_project()
+ function current_project
- function current_project(dir::AbstractString)
+ function current_project(dir :: AbstractString)
- function current_word_with_dots(buf::IOBuffer)
+ function current_word_with_dots(buf :: IOBuffer)
- function custom_lookup(mi::MethodInstance, min_world::UInt, max_world::UInt)
+ function custom_lookup(mi :: MethodInstance, min_world :: UInt, max_world :: UInt)
- function cwstring(s::AbstractString)
+ function cwstring(s :: AbstractString)
- function cycle_fix_limited(@nospecialize(typ), sv::InferenceState)
+ function cycle_fix_limited(typ, sv :: InferenceState)
- function datatype_alignment(dt::DataType)
+ function datatype_alignment(dt :: DataType)
- function datatype_arrayelem(dt::DataType)
+ function datatype_arrayelem(dt :: DataType)
- function datatype_fieldcount(t::DataType)
+ function datatype_fieldcount(t :: DataType)
- function datatype_fielddesc_type(dt::DataType)
+ function datatype_fielddesc_type(dt :: DataType)
- function datatype_haspadding(dt::DataType)
+ function datatype_haspadding(dt :: DataType)
- function datatype_layoutsize(dt::DataType)
+ function datatype_layoutsize(dt :: DataType)
- function datatype_min_ninitialized(t::DataType)
+ function datatype_min_ninitialized(t :: DataType)
- function datatype_nfields(dt::DataType)
+ function datatype_nfields(dt :: DataType)
- function datatype_pointerfree(dt::DataType)
+ function datatype_pointerfree(dt :: DataType)
- function day(days)
+ function day(days)
- function day_in(obj::ObjMember)
+ function day_in(obj :: ObjMember)
- function dayabbr(dt::TimeType;locale::AbstractString="english")
+ function dayabbr(dt :: TimeType, locale :: AbstractString = "english")
- function dayname(dt::TimeType;locale::AbstractString="english")
+ function dayname(dt :: TimeType, locale :: AbstractString = "english")
- function dayofquarter(dt::TimeType)
+ function dayofquarter(dt :: TimeType)
- function dayofweekofmonth(dt::TimeType)
+ function dayofweekofmonth(dt :: TimeType)
- function daysofweekinmonth(dt::TimeType)
+ function daysofweekinmonth(dt :: TimeType)
- function deactivate(p::TextInterface, s::ModeState, termbuf::AbstractTerminal, term::TextTerminal)
+ function deactivate(p :: TextInterface, s :: ModeState, termbuf :: AbstractTerminal, term :: TextTerminal)
- function dec()
+ function dec
- function dec(x::Unsigned, pad::Int, neg::Bool)
+ function dec(x :: Unsigned, pad :: Int, neg :: Bool)
- function decimallength(v)
+ function decimallength(v)
- function decimallength(v::UInt16)
+ function decimallength(v :: UInt16)
- function decimallength(v::UInt32)
+ function decimallength(v :: UInt32)
- function declared_ceil(x::Float64)
+ function declared_ceil(x :: Float64)
- function declared_floor(x::Float64)
+ function declared_floor(x :: Float64)
- function decode(raw_results::RawResults)::AllocResults
+ function decode(raw_results :: RawResults)
- function decode_alloc(cache::BacktraceCache, raw_alloc::RawAlloc)::Alloc
+ function decode_alloc(cache :: BacktraceCache, raw_alloc :: RawAlloc)
- function decode_effects(e::UInt32)
+ function decode_effects(e :: UInt32)
- function decode_effects_override(e::UInt8)
+ function decode_effects_override(e :: UInt8)
- function decode_slow(b1, b2, b3, b4, buffer, i, input, ptr, n, rest)
+ function decode_slow(b1, b2, b3, b4, buffer, i, input, ptr, n, rest)
- function decompose(x::BigFloat)::Tuple{BigInt, Int, Int}
+ function decompose(x :: BigFloat)
- function decompose(x::Float16)::NTuple{3,Int}
+ function decompose(x :: Float16)
- function decompose(x::Float32)::NTuple{3,Int}
+ function decompose(x :: Float32)
- function decompose(x::Float64)::Tuple{Int64, Int, Int}
+ function decompose(x :: Float64)
- function decompose_next_char!(c, state, d, options, s)
+ function decompose_next_char!(c, state, d, options, s)
- function deepcopy(@nospecialize x)
+ function deepcopy(x)
- function deepcopy_internal(@nospecialize(x), stackdict::IdDict)
+ function deepcopy_internal(x, stackdict :: IdDict)
- function deepcopy_internal(S::SharedArray, stackdict::IdDict)
+ function deepcopy_internal(S :: SharedArray, stackdict :: IdDict)
- function deepcopy_internal(x::AbstractLock, stackdict::IdDict)
+ function deepcopy_internal(x :: AbstractLock, stackdict :: IdDict)
- function deepcopy_internal(x::GenericCondition, stackdict::IdDict)
+ function deepcopy_internal(x :: GenericCondition, stackdict :: IdDict)
- function deepcopy_internal(x::GenericMemoryRef, stackdict::IdDict)
+ function deepcopy_internal(x :: GenericMemoryRef, stackdict :: IdDict)
- function deepcopy_internal(x::Memory, stackdict::IdDict)
+ function deepcopy_internal(x :: Memory, stackdict :: IdDict)
- function deepcopy_internal(x::SimpleVector, stackdict::IdDict)
+ function deepcopy_internal(x :: SimpleVector, stackdict :: IdDict)
- function deepcopy_internal(x::String, stackdict::IdDict)
+ function deepcopy_internal(x :: String, stackdict :: IdDict)
- function deepcopy_internal(x::Union{Dict,IdDict}, stackdict::IdDict)
+ function deepcopy_internal(x :: Union{Dict, IdDict}, stackdict :: IdDict)
- function default_branch(rmt::GitRemote)
+ function default_branch(rmt :: GitRemote)
- function default_config(code::IRCode; verbose_linetable=false)
+ function default_config(code :: IRCode, verbose_linetable = false)
- function default_expr_type_printer(io::IO; @nospecialize(type), used::Bool, show_type::Bool=true, _...)
+ function default_expr_type_printer(io :: IO, type, used :: Bool, show_type :: Bool = true, _...)
- function default_group_code(file)
+ function default_group_code(file)
- function default_init()
+ function default_init
- function default_logcolor(level::LogLevel)
+ function default_logcolor(level :: LogLevel)
- function default_metafmt(level::LogLevel, _module, group, id, file, line)
+ function default_metafmt(level :: LogLevel, _module, group, id, file, line)
- function default_signature(repo::GitRepo)
+ function default_signature(repo :: GitRepo)
- function default_tt(@nospecialize(f))
+ function default_tt(f)
- function default_username(cfg::GitConfig, cred::GitCredential)
+ function default_username(cfg :: GitConfig, cred :: GitCredential)
- function define_conversions(periods)
+ function define_conversions(periods)
- function define_default_editors()
+ function define_default_editors
- function define_editor(fn::Function, pattern; wait::Bool=false)
+ function define_editor(fn :: Function, pattern, wait :: Bool = false)
- function deg2rad_ext(x::Float64)
+ function deg2rad_ext(x :: Float64)
- function delete!(d::IdDict{K}, @nospecialize(key)) where K
+ function delete!(d :: IdDict{K}, key) where K
- function delete!(h::Dict, key)
+ function delete!(h :: Dict, key)
- function delete!(wkh::WeakKeyDict, key)
+ function delete!(wkh :: WeakKeyDict, key)
- function delete(dict::PersistentDict{K}, key::K) where K
+ function delete(dict :: PersistentDict{K}, key :: K) where K
- function delete_branch(branch::GitReference)
+ function delete_branch(branch :: GitReference)
- function delete_method(m::Method)
+ function delete_method(m :: Method)
- function deleteat!(B::BitVector, i::Integer)
+ function deleteat!(B :: BitVector, i :: Integer)
- function deleteat!(B::BitVector, inds)
+ function deleteat!(B :: BitVector, inds)
- function deleteat!(B::BitVector, inds::AbstractVector{Bool})
+ function deleteat!(B :: BitVector, inds :: AbstractVector{Bool})
- function deleteat!(B::BitVector, r::AbstractUnitRange{Int})
+ function deleteat!(B :: BitVector, r :: AbstractUnitRange{Int})
- function deleteat!(a::Vector, i::Integer)
+ function deleteat!(a :: Vector, i :: Integer)
- function deleteat!(a::Vector, inds::AbstractVector{Bool})
+ function deleteat!(a :: Vector, inds :: AbstractVector{Bool})
- function deleteat!(a::Vector, r::AbstractUnitRange{<:Integer})
+ function deleteat!(a :: Vector, r :: AbstractUnitRange{??? <: Integer})
- function deletions(diff_stat::GitDiffStats)
+ function deletions(diff_stat :: GitDiffStats)
- function demangle_function_name(name::AbstractString)
+ function demangle_function_name(name :: AbstractString)
- function demo(f)
+ function demo(f)
- function depth(t::Core.Compiler.Timings.Timing)
+ function depth(t :: Core.Compiler.Timings.Timing)
- function depwarn(msg, funcsym; force::Bool=false)
+ function depwarn(msg, funcsym, force :: Bool = false)
- function deserialize(s::AbstractSerializer)
+ function deserialize(s :: AbstractSerializer)
- function deserialize(s::AbstractSerializer, ::Type{Base.StackTraces.StackFrame})
+ function deserialize(s :: AbstractSerializer, ??? :: Type{Base.StackTraces.StackFrame})
- function deserialize(s::AbstractSerializer, ::Type{CodeInfo})
+ function deserialize(s :: AbstractSerializer, ??? :: Type{CodeInfo})
- function deserialize(s::AbstractSerializer, ::Type{Core.LineInfoNode})
+ function deserialize(s :: AbstractSerializer, ??? :: Type{Core.LineInfoNode})
- function deserialize(s::AbstractSerializer, ::Type{Core.MethodInstance})
+ function deserialize(s :: AbstractSerializer, ??? :: Type{Core.MethodInstance})
- function deserialize(s::AbstractSerializer, ::Type{Core.TypeName})
+ function deserialize(s :: AbstractSerializer, ??? :: Type{Core.TypeName})
- function deserialize(s::AbstractSerializer, ::Type{Method})
+ function deserialize(s :: AbstractSerializer, ??? :: Type{Method})
- function deserialize(s::AbstractSerializer, ::Type{PhiNode})
+ function deserialize(s :: AbstractSerializer, ??? :: Type{PhiNode})
- function deserialize(s::AbstractSerializer, ::Type{Task})
+ function deserialize(s :: AbstractSerializer, ??? :: Type{Task})
- function deserialize(s::AbstractSerializer, ::Type{T}) where T<:Base.AbstractLock
+ function deserialize(s :: AbstractSerializer, ??? :: Type{T}) where T <: Base.AbstractLock
- function deserialize(s::AbstractSerializer, ::Type{T}) where T<:Base.GenericCondition
+ function deserialize(s :: AbstractSerializer, ??? :: Type{T}) where T <: Base.GenericCondition
- function deserialize(s::AbstractSerializer, ::Type{UnionAll})
+ function deserialize(s :: AbstractSerializer, ??? :: Type{UnionAll})
- function deserialize(s::AbstractSerializer, T::Type{Dict{K,V}}) where {K,V}
+ function deserialize(s :: AbstractSerializer, T :: Type{Dict{K, V}}) where K, V
- function deserialize(s::AbstractSerializer, X::Type{Core.AddrSpace{M}} where M)
+ function deserialize(s :: AbstractSerializer, X :: Type{Core.AddrSpace{M}} where M)
- function deserialize(s::AbstractSerializer, X::Type{MemoryRef{T}} where T)
+ function deserialize(s :: AbstractSerializer, X :: Type{MemoryRef{T}} where T)
- function deserialize(s::AbstractSerializer, X::Type{Memory{T}} where T)
+ function deserialize(s :: AbstractSerializer, X :: Type{Memory{T}} where T)
- function deserialize(s::AbstractSerializer, t::DataType)
+ function deserialize(s :: AbstractSerializer, t :: DataType)
- function deserialize(s::AbstractSerializer, t::Type{<:SharedArray})
+ function deserialize(s :: AbstractSerializer, t :: Type{??? <: SharedArray})
- function deserialize(s::AbstractSerializer, t::Type{Regex})
+ function deserialize(s :: AbstractSerializer, t :: Type{Regex})
- function deserialize_array(s::AbstractSerializer)
+ function deserialize_array(s :: AbstractSerializer)
- function deserialize_cycle(s::AbstractSerializer, @nospecialize(x))
+ function deserialize_cycle(s :: AbstractSerializer, x)
- function deserialize_datatype(s::AbstractSerializer, full::Bool)
+ function deserialize_datatype(s :: AbstractSerializer, full :: Bool)
- function deserialize_dict(s::AbstractSerializer, T::Type{<:AbstractDict})
+ function deserialize_dict(s :: AbstractSerializer, T :: Type{??? <: AbstractDict})
- function deserialize_expr(s::AbstractSerializer, len)
+ function deserialize_expr(s :: AbstractSerializer, len)
- function deserialize_fillarray!(A::Union{Array{T},Memory{T}}, s::AbstractSerializer) where {T}
+ function deserialize_fillarray!(A :: Union{Array{T}, Memory{T}}, s :: AbstractSerializer) where T
- function deserialize_module(s::AbstractSerializer)
+ function deserialize_module(s :: AbstractSerializer)
- function deserialize_string(s::AbstractSerializer, len::Int)
+ function deserialize_string(s :: AbstractSerializer, len :: Int)
- function deserialize_svec(s::AbstractSerializer)
+ function deserialize_svec(s :: AbstractSerializer)
- function deserialize_symbol(s::AbstractSerializer, len::Int)
+ function deserialize_symbol(s :: AbstractSerializer, len :: Int)
- function deserialize_typename(s::AbstractSerializer, number)
+ function deserialize_typename(s :: AbstractSerializer, number)
- function destroy(ref::REPLBackendRef, state::Task)
+ function destroy(ref :: REPLBackendRef, state :: Task)
- function destructure_callex(topmod::Module, @nospecialize(ex))
+ function destructure_callex(topmod :: Module, ex)
- function det(A::AbstractMatrix{T}) where {T}
+ function det(A :: AbstractMatrix{T}) where T
- function det(C::Cholesky)
+ function det(C :: Cholesky)
- function det(C::CholeskyPivoted)
+ function det(C :: CholeskyPivoted)
- function det(F::Factorization)
+ function det(F :: Factorization)
- function det(F::LU{T}) where T
+ function det(F :: LU{T}) where T
- function det(F::UpperHessenberg; shift::Number=false)
+ function det(F :: UpperHessenberg, shift :: Number = false)
- function det(J::UniformScaling{T}) where T
+ function det(J :: UniformScaling{T}) where T
- function det_bareiss!(M)
+ function det_bareiss!(M)
- function det_usmani(a::V, b::V, c::V, shift::Number=0) where {T,V<:AbstractVector{T}}
+ function det_usmani(a :: V, b :: V, c :: V, shift :: Number = 0) where T, V <: AbstractVector{T}
- function detect_args_kwargs(funargs::Vector{Any}, context_module::Module, default_any::Bool, broadcasting::Bool)
+ function detect_args_kwargs(funargs :: Vector{Any}, context_module :: Module, default_any :: Bool, broadcasting :: Bool)
- function detect_cxxstring_abi()
+ function detect_cxxstring_abi
- function detect_invalid_kwarg!(kwargs_ex::Vector{Symbol}, @nospecialize(x), kwargs_flag::Int, possible_splat::Bool)
+ function detect_invalid_kwarg!(kwargs_ex :: Vector{Symbol}, x, kwargs_flag :: Int, possible_splat :: Bool)
- function detect_libgfortran_version()
+ function detect_libgfortran_version
- function detect_libstdcxx_version(max_minor_version::Int=30)
+ function detect_libstdcxx_version(max_minor_version :: Int = 30)
- function diag(B::BitMatrix)
+ function diag(B :: BitMatrix)
- function diag(D::Diagonal{T}, k::Integer=0) where T
+ function diag(D :: Diagonal{T}, k :: Integer = 0) where T
- function diag(M::Bidiagonal{T}, n::Integer=0) where T
+ function diag(M :: Bidiagonal{T}, n :: Integer = 0) where T
- function diag(M::SymTridiagonal, n::Integer=0)
+ function diag(M :: SymTridiagonal, n :: Integer = 0)
- function diag(M::SymTridiagonal{T}, n::Integer=0) where T<:Number
+ function diag(M :: SymTridiagonal{T}, n :: Integer = 0) where T <: Number
- function diag(M::Tridiagonal{T}, n::Integer=0) where T
+ function diag(M :: Tridiagonal{T}, n :: Integer = 0) where T
- function diagind(A::AbstractMatrix, k::Integer=0)
+ function diagind(A :: AbstractMatrix, k :: Integer = 0)
- function diagm_container(size, kv::Pair{<:Integer,<:AbstractVector}...)
+ function diagm_container(size, kv :: Pair{??? <: Integer, ??? <: AbstractVector}...)
- function diagm_size(size::Nothing, kv::Pair{<:Integer,<:AbstractVector}...)
+ function diagm_size(size :: Nothing, kv :: Pair{??? <: Integer, ??? <: AbstractVector}...)
- function diagm_size(size::Tuple{Int,Int}, kv::Pair{<:Integer,<:AbstractVector}...)
+ function diagm_size(size :: Tuple{Int, Int}, kv :: Pair{??? <: Integer, ??? <: AbstractVector}...)
- function dict_identifier_key(str::String, tag::Symbol, context_module::Module=Main)
+ function dict_identifier_key(str :: String, tag :: Symbol, context_module :: Module = Main)
- function dict_with_eltype(DT_apply::F, kv::Generator, t) where F
+ function dict_with_eltype(DT_apply :: F, kv :: Generator, t) where F
- function diff(a::AbstractArray{T,N}; dims::Integer) where {T,N}
+ function diff(a :: AbstractArray{T, N}, dims :: Integer) where T, N
- function diff(r::AbstractRange{T}; dims::Integer=1) where {T}
+ function diff(r :: AbstractRange{T}, dims :: Integer = 1) where T
- function diff_tree(repo::GitRepo, oldtree::GitTree, newtree::GitTree)
+ function diff_tree(repo :: GitRepo, oldtree :: GitTree, newtree :: GitTree)
- function diff_tree(repo::GitRepo, tree::GitTree, pathspecs::AbstractString=""; cached::Bool=false)
+ function diff_tree(repo :: GitRepo, tree :: GitTree, pathspecs :: AbstractString = "", cached :: Bool = false)
- function digits!(a::AbstractVector{T}, n::BigInt; base::Integer = 10) where {T<:Integer}
+ function digits!(a :: AbstractVector{T}, n :: BigInt, base :: Integer = 10) where T <: Integer
- function digits!(a::AbstractVector{T}, n::Integer; base::Integer = 10) where T<:Integer
+ function digits!(a :: AbstractVector{T}, n :: Integer, base :: Integer = 10) where T <: Integer
- function digits(T::Type{<:Integer}, n::Integer; base::Integer = 10, pad::Integer = 1)
+ function digits(T :: Type{??? <: Integer}, n :: Integer, base :: Integer = 10, pad :: Integer = 1)
- function dim_break_linindex(I)
+ function dim_break_linindex(I)
- function dims2cat(dims)
+ function dims2cat(dims)
- function disable_finalizers() @inline
+ function disable_finalizers
- function disable_library_threading()
+ @@inlinefunction disable_library_threading
- function disable_logging(level::LogLevel)
+ function disable_logging(level :: LogLevel)
- function disable_sigint(f::Function)
+ function disable_sigint(f :: Function)
- function disconnect(rmt::GitRemote)
+ function disconnect(rmt :: GitRemote)
- function diskstat(path::AbstractString=pwd())
+ function diskstat(path :: AbstractString = pwd())
- function display(@nospecialize x)
+ function display(x)
- function display(d::REPLDisplay, mime::MIME"text/plain", x)
+ function display(d :: REPLDisplay, mime :: MIME"text/plain", x)
- function display(d::TextDisplay, M::MIME, @nospecialize x)
+ function display(d :: TextDisplay, M :: MIME, x)
- function display(m::MIME, @nospecialize x)
+ function display(m :: MIME, x)
- function display_error(io::IO, er, bt)
+ function display_error(io :: IO, er, bt)
- function display_error(io::IO, stack::ExceptionStack)
+ function display_error(io :: IO, stack :: ExceptionStack)
- function displayable(m::MIME)
+ function displayable(m :: MIME)
- function displaysize(io::TTY)
+ function displaysize(io :: TTY)
- function div!(z::Rational{BigInt}, x::Rational{BigInt}, y::Rational{BigInt})
+ function div!(z :: Rational{BigInt}, x :: Rational{BigInt}, y :: Rational{BigInt})
- function div(a::T, b::SignedMultiplicativeInverse{T}) where T
+ function div(a :: T, b :: SignedMultiplicativeInverse{T}) where T
- function div(a::T, b::UnsignedMultiplicativeInverse{T}) where T
+ function div(a :: T, b :: UnsignedMultiplicativeInverse{T}) where T
- function div(c::CdoubleMax, x::BigFloat)
+ function div(c :: CdoubleMax, x :: BigFloat)
- function div(c::ClongMax, x::BigFloat)
+ function div(c :: ClongMax, x :: BigFloat)
- function div(c::CulongMax, x::BigFloat)
+ function div(c :: CulongMax, x :: BigFloat)
- function div(x::BigFloat, c::BigInt)
+ function div(x :: BigFloat, c :: BigInt)
- function div(x::BigFloat, c::CdoubleMax)
+ function div(x :: BigFloat, c :: CdoubleMax)
- function div(x::BigFloat, c::ClongMax)
+ function div(x :: BigFloat, c :: ClongMax)
- function div(x::BigFloat, c::CulongMax)
+ function div(x :: BigFloat, c :: CulongMax)
- function div(x::BigFloat, y::BigFloat)
+ function div(x :: BigFloat, y :: BigFloat)
- function div(x::Int128, y::Int128)
+ function div(x :: Int128, y :: Int128)
- function div(x::Integer, y::Integer, ::typeof(RoundFromZero))
+ function div(x :: Integer, y :: Integer, ??? :: typeof(RoundFromZero))
- function div(x::Integer, y::Rational, r::RoundingMode)
+ function div(x :: Integer, y :: Rational, r :: RoundingMode)
- function div(x::Rational, y::Integer, r::RoundingMode)
+ function div(x :: Rational, y :: Integer, r :: RoundingMode)
- function div(x::Rational, y::Rational, r::RoundingMode)
+ function div(x :: Rational, y :: Rational, r :: RoundingMode)
- function div(x::Real, y::Real, r::RoundingMode)
+ function div(x :: Real, y :: Real, r :: RoundingMode)
- function div(x::Signed, y::Unsigned, ::typeof(RoundDown))
+ function div(x :: Signed, y :: Unsigned, ??? :: typeof(RoundDown))
- function div(x::Signed, y::Unsigned, ::typeof(RoundUp))
+ function div(x :: Signed, y :: Unsigned, ??? :: typeof(RoundUp))
- function div(x::T, y::T, ::typeof(RoundDown)) where T<:Integer
+ function div(x :: T, y :: T, ??? :: typeof(RoundDown)) where T <: Integer
- function div(x::T, y::T, ::typeof(RoundUp)) where T<:Integer
+ function div(x :: T, y :: T, ??? :: typeof(RoundUp)) where T <: Integer
- function div(x::T, y::T, ::typeof(RoundUp)) where T<:Unsigned
+ function div(x :: T, y :: T, ??? :: typeof(RoundUp)) where T <: Unsigned
- function div(x::Unsigned, y::Signed, ::typeof(RoundDown))
+ function div(x :: Unsigned, y :: Signed, ??? :: typeof(RoundDown))
- function div(x::Unsigned, y::Signed, ::typeof(RoundUp))
+ function div(x :: Unsigned, y :: Signed, ??? :: typeof(RoundUp))
- function div12(x::T, y::T) where {T<:AbstractFloat}
+ function div12(x :: T, y :: T) where T <: AbstractFloat
- function divexact(x, y)
+ function divexact(x, y)
- function divgcd(x::Integer,y::Integer)
+ function divgcd(x :: Integer, y :: Integer)
- function divrem(a, b, r::RoundingMode)
+ function divrem(a, b, r :: RoundingMode)
- function divrem(a::T, b::MultiplicativeInverse{T}) where T
+ function divrem(a :: T, b :: MultiplicativeInverse{T}) where T
- function divrem(x, y, ::typeof(RoundFromZero))
+ function divrem(x, y, ??? :: typeof(RoundFromZero))
- function divrem(x::BitSigned, y::Unsigned)
+ function divrem(x :: BitSigned, y :: Unsigned)
- function divrem(x::Integer, y::Integer, rnd:: typeof(RoundNearestTiesAway))
+ function divrem(x :: Integer, y :: Integer, rnd :: typeof(RoundNearestTiesAway))
- function divrem(x::Integer, y::Integer, rnd::typeof(RoundNearest))
+ function divrem(x :: Integer, y :: Integer, rnd :: typeof(RoundNearest))
- function divrem(x::Integer, y::Integer, rnd::typeof(RoundNearestTiesUp))
+ function divrem(x :: Integer, y :: Integer, rnd :: typeof(RoundNearestTiesUp))
- function divrem(x::UInt128, y::UInt128)
+ function divrem(x :: UInt128, y :: UInt128)
- function divrem(x::Unsigned, y::BitSigned)
+ function divrem(x :: Unsigned, y :: BitSigned)
- function dl_phdr_info_callback(di::dl_phdr_info, size::Csize_t, dynamic_libraries::Array{String,1})
+ function dl_phdr_info_callback(di :: dl_phdr_info, size :: Csize_t, dynamic_libraries :: Array{String, DependentType@3e3abc88})
- function dlclose(p::Nothing)
+ function dlclose(p :: Nothing)
- function dlclose(p::Ptr)
+ function dlclose(p :: Ptr)
- function dllist()
+ function dllist
- function dlopen(f::Function, name, args...; kwargs...)
+ function dlopen(f :: Function, name, args..., kwargs...)
- function dlopen(ll::LazyLibrary, flags::Integer = ll.flags; kwargs...)
+ function dlopen(ll :: LazyLibrary, flags :: Integer = ll.flags, kwargs...)
- function dlopen(s::AbstractString, flags::Integer = default_rtld_flags; throw_error::Bool = true)
+ function dlopen(s :: AbstractString, flags :: Integer = default_rtld_flags, throw_error :: Bool = true)
- function dlpath(handle::Ptr{Cvoid})
+ function dlpath(handle :: Ptr{Cvoid})
- function dlpath(libname::Union{AbstractString, Symbol})
+ function dlpath(libname :: Union{AbstractString, Symbol})
- function dlsym(hnd::Ptr, s::Union{Symbol,AbstractString}; throw_error::Bool = true)
+ function dlsym(hnd :: Ptr, s :: Union{Symbol, AbstractString}, throw_error :: Bool = true)
- function dlsym_e(args...)
+ function dlsym_e(args...)
- function do_async_macro(expr, linenums; wrap=identity)
+ function do_async_macro(expr, linenums, wrap = identity)
- function do_broken_test(result::ExecutionResult, orig_expr)
+ function do_broken_test(result :: ExecutionResult, orig_expr)
- function do_download(url::AbstractString, path::Union{AbstractString, Nothing})
+ function do_download(url :: AbstractString, path :: Union{AbstractString, Nothing})
- function do_escape(s)
+ function do_escape(s)
- function do_something()
+ function do_something
- function do_test(result::ExecutionResult, orig_expr)
+ function do_test(result :: ExecutionResult, orig_expr)
- function do_test_throws(result::ExecutionResult, orig_expr, extype)
+ function do_test_throws(result :: ExecutionResult, orig_expr, extype)
- function do_the_call()
+ function do_the_call
- function do_threadcall(fun_ptr::Ptr{Cvoid}, cfptr::Ptr{Cvoid}, rettype::Type, argtypes::Vector, argvals::Vector)
+ function do_threadcall(fun_ptr :: Ptr{Cvoid}, cfptr :: Ptr{Cvoid}, rettype :: Type, argtypes :: Vector, argvals :: Vector)
- function do_work()
+ function do_work
- function doc!(__module__::Module, b::Binding, str::DocStr, @nospecialize sig = Union{})
+ function doc!(__module__ :: Module, b :: Binding, str :: DocStr, sig = Union{})
- function doc!(source::LineNumberNode, mod::Module, str, ex)
+ function doc!(source :: LineNumberNode, mod :: Module, str, ex)
- function doc(binding::Binding, sig::Type = Union{})
+ function doc(binding :: Binding, sig :: Type = Union{})
- function doc_completions(name, mod::Module=Main)
+ function doc_completions(name, mod :: Module = Main)
- function doc_str(md, source::LineNumberNode, mod::Module)
+ function doc_str(md, source :: LineNumberNode, mod :: Module)
- function docerror(@nospecialize ex)
+ function docerror(ex)
- function docexpr(source::LineNumberNode, mod::Module, s, flavor = :julia)
+ function docexpr(source :: LineNumberNode, mod :: Module, s, flavor = :julia)
- function docm(source::LineNumberNode, mod::Module, ex)
+ function docm(source :: LineNumberNode, mod :: Module, ex)
- function docm(source::LineNumberNode, mod::Module, meta, ex, define::Bool = true)
+ function docm(source :: LineNumberNode, mod :: Module, meta, ex, define :: Bool = true)
- function docm(source::LineNumberNode, mod::Module, str, x)
+ function docm(source :: LineNumberNode, mod :: Module, str, x)
- function docsearch(haystack, needle)
+ function docsearch(haystack, needle)
- function docsearch(haystack::Array, needle)
+ function docsearch(haystack :: Array, needle)
- function docsearch(haystack::DocStr, needle)
+ function docsearch(haystack :: DocStr, needle)
- function docsearch(haystack::MultiDoc, needle)
+ function docsearch(haystack :: MultiDoc, needle)
- function docstr(binding::Binding, typesig = Union{})
+ function docstr(binding :: Binding, typesig = Union{})
- function docstring_startswith(d1, d2)
+ function docstring_startswith(d1, d2)
- function docstrings_equal(d1, d2; debug=true)
+ function docstrings_equal(d1, d2, debug = true)
- function doiterate(itr, valstate::Union{Nothing, Tuple{Any, Any}})
+ function doiterate(itr, valstate :: Union{Nothing, Tuple{Any, Any}})
- function dominated(domtree::DomTree, root::BBNumber)
+ function dominated(domtree :: DomTree, root :: BBNumber)
- function dominates_ssa(compact::IncrementalCompact, domtree::DomTree, x::AnySSAValue, y::AnySSAValue)
+ function dominates_ssa(compact :: IncrementalCompact, domtree :: DomTree, x :: AnySSAValue, y :: AnySSAValue)
- function domsort_ssa!(ir::IRCode, domtree::DomTree)
+ function domsort_ssa!(ir :: IRCode, domtree :: DomTree)
- function dot(D::Diagonal, B::AbstractMatrix)
+ function dot(D :: Diagonal, B :: AbstractMatrix)
- function dot(x, y)
+ function dot(x, y)
- function dot(x::AbstractArray, y::AbstractArray)
+ function dot(x :: AbstractArray, y :: AbstractArray)
- function dot(x::AbstractVector, A::AbstractMatrix, y::AbstractVector)
+ function dot(x :: AbstractVector, A :: AbstractMatrix, y :: AbstractVector)
- function dot(x::AbstractVector, A::LowerTriangular, y::AbstractVector)
+ function dot(x :: AbstractVector, A :: LowerTriangular, y :: AbstractVector)
- function dot(x::AbstractVector, A::RealHermSymComplexHerm, y::AbstractVector)
+ function dot(x :: AbstractVector, A :: RealHermSymComplexHerm, y :: AbstractVector)
- function dot(x::AbstractVector, A::Tridiagonal, y::AbstractVector)
+ function dot(x :: AbstractVector, A :: Tridiagonal, y :: AbstractVector)
- function dot(x::AbstractVector, A::UnitLowerTriangular, y::AbstractVector)
+ function dot(x :: AbstractVector, A :: UnitLowerTriangular, y :: AbstractVector)
- function dot(x::AbstractVector, A::UnitUpperTriangular, y::AbstractVector)
+ function dot(x :: AbstractVector, A :: UnitUpperTriangular, y :: AbstractVector)
- function dot(x::AbstractVector, A::UpperTriangular, y::AbstractVector)
+ function dot(x :: AbstractVector, A :: UpperTriangular, y :: AbstractVector)
- function dot(x::AbstractVector, B::Bidiagonal, y::AbstractVector)
+ function dot(x :: AbstractVector, B :: Bidiagonal, y :: AbstractVector)
- function dot(x::AbstractVector, H::UpperHessenberg, y::AbstractVector)
+ function dot(x :: AbstractVector, H :: UpperHessenberg, y :: AbstractVector)
- function dot(x::AbstractVector, S::SymTridiagonal, y::AbstractVector)
+ function dot(x :: AbstractVector, S :: SymTridiagonal, y :: AbstractVector)
- function dot(x::Adjoint{<:Union{Real,Complex}}, y::Adjoint{<:Union{Real,Complex}})
+ function dot(x :: Adjoint{??? <: Union{Real, Complex}}, y :: Adjoint{??? <: Union{Real, Complex}})
- function dot(x::BitVector, y::BitVector)
+ function dot(x :: BitVector, y :: BitVector)
- function dot(x::Vector{T}, rx::AbstractRange{TI}, y::Vector{T}, ry::AbstractRange{TI}) where {T<:BlasComplex,TI<:Integer}
+ function dot(x :: Vector{T}, rx :: AbstractRange{TI}, y :: Vector{T}, ry :: AbstractRange{TI}) where T <: BlasComplex, TI <: Integer
- function dot(x::Vector{T}, rx::AbstractRange{TI}, y::Vector{T}, ry::AbstractRange{TI}) where {T<:BlasReal,TI<:Integer}
+ function dot(x :: Vector{T}, rx :: AbstractRange{TI}, y :: Vector{T}, ry :: AbstractRange{TI}) where T <: BlasReal, TI <: Integer
- function dotf(a, b)
+ function dotf(a, b)
- function doubly_declared2_trunc(x::Float64)
+ function doubly_declared2_trunc(x :: Float64)
- function doubly_declared_floor(x::Float64)
+ function doubly_declared_floor(x :: Float64)
- function download_from_cache(desired_url::AbstractString)
+ function download_from_cache(desired_url :: AbstractString)
- function dsfmt_fill_array_close1_open2!(s::DSFMT_state, A::Ptr{Float64}, n::Int)
+ function dsfmt_fill_array_close1_open2!(s :: DSFMT_state, A :: Ptr{Float64}, n :: Int)
- function dsfmt_fill_array_close_open!(s::DSFMT_state, A::Ptr{Float64}, n::Int)
+ function dsfmt_fill_array_close_open!(s :: DSFMT_state, A :: Ptr{Float64}, n :: Int)
- function dsfmt_get_idstring()
+ function dsfmt_get_idstring
- function dsfmt_get_min_array_size()
+ function dsfmt_get_min_array_size
- function dsfmt_gv_init_by_array(seed::Vector{UInt32})
+ function dsfmt_gv_init_by_array(seed :: Vector{UInt32})
- function dsfmt_init_by_array(s::DSFMT_state, seed::StridedVector{UInt32})
+ function dsfmt_init_by_array(s :: DSFMT_state, seed :: StridedVector{UInt32})
- function dsfmt_init_gen_rand(s::DSFMT_state, seed::UInt32)
+ function dsfmt_init_gen_rand(s :: DSFMT_state, seed :: UInt32)
- function dsfmt_jump(s::DSFMT_state, jp::GF2X)
+ function dsfmt_jump(s :: DSFMT_state, jp :: GF2X)
- function dsfmt_jump_add!(dest::AbstractVector{UInt64}, src::Vector{UInt64})
+ function dsfmt_jump_add!(dest :: AbstractVector{UInt64}, src :: Vector{UInt64})
- function dsfmt_jump_next_state!(mts::Vector{UInt64})
+ function dsfmt_jump_next_state!(mts :: Vector{UInt64})
- function dsymutil(; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
+ function dsymutil(adjust_PATH :: Bool = true, adjust_LIBPATH :: Bool = true)
- function dummy_metafmt(level, _module, group, id, file, line)
+ function dummy_metafmt(level, _module, group, id, file, line)
- function dummy_uuid(project_file::String)
+ function dummy_uuid(project_file :: String)
- function dump(arg; maxdepth=DUMP_DEFAULT_MAXDEPTH)
+ function dump(arg, maxdepth = DUMP_DEFAULT_MAXDEPTH)
- function dump(io::IO, @nospecialize(x); maxdepth=DUMP_DEFAULT_MAXDEPTH)
+ function dump(io :: IO, x, maxdepth = DUMP_DEFAULT_MAXDEPTH)
- function dump(io::IOContext, @nospecialize(x), n::Int, indent)
+ function dump(io :: IOContext, x, n :: Int, indent)
- function dump(io::IOContext, x::Array, n::Int, indent)
+ function dump(io :: IOContext, x :: Array, n :: Int, indent)
- function dump(io::IOContext, x::DataType, n::Int, indent)
+ function dump(io :: IOContext, x :: DataType, n :: Int, indent)
- function dump(io::IOContext, x::SimpleVector, n::Int, indent)
+ function dump(io :: IOContext, x :: SimpleVector, n :: Int, indent)
- function dump_elts(io::IOContext, x::Array, n::Int, indent, i0, i1)
+ function dump_elts(io :: IOContext, x :: Array, n :: Int, indent, i0, i1)
- function dup(src::WindowsRawSocket)
+ function dup(src :: WindowsRawSocket)
- function dup(src::WindowsRawSocket, target::RawFD)
+ function dup(src :: WindowsRawSocket, target :: RawFD)
- function each_stmt_a_bb(stmts, preds, succs)
+ function each_stmt_a_bb(stmts, preds, succs)
- function eachindex(::IndexLinear, A::AbstractArray, B::AbstractArray...)
+ function eachindex(??? :: IndexLinear, A :: AbstractArray, B :: AbstractArray...)
- function eachindex(A::AbstractArray, B::AbstractArray)
+ function eachindex(A :: AbstractArray, B :: AbstractArray)
- function eachindex(A::AbstractArray, B::AbstractArray...)
+ function eachindex(A :: AbstractArray, B :: AbstractArray...)
- function eachline(cmd::AbstractCmd; keep::Bool=false)
+ function eachline(cmd :: AbstractCmd, keep :: Bool = false)
- function eachline(filename::AbstractString; keep::Bool=false)
+ function eachline(filename :: AbstractString, keep :: Bool = false)
- function eachline(stream::IO=stdin; keep::Bool=false)
+ function eachline(stream :: IO = stdin, keep :: Bool = false)
- function eachmethod(f, mods = Base.loaded_modules_array())
+ function eachmethod(f, mods = Base.loaded_modules_array())
- function eatindent(io::IO, n = 3)
+ function eatindent(io :: IO, n = 3)
- function edit(@nospecialize f)
+ function edit(f)
- function edit(path::AbstractString, line::Integer=0, column::Integer=0)
+ function edit(path :: AbstractString, line :: Integer = 0, column :: Integer = 0)
- function edit_abort(s::MIState, confirm::Bool=options(s).confirm_exit; key="^D")
+ function edit_abort(s :: MIState, confirm :: Bool = options(s).confirm_exit, key = "^D")
- function edit_backspace(buf::IOBuffer, align::Bool=false, adjust::Bool=false)
+ function edit_backspace(buf :: IOBuffer, align :: Bool = false, adjust :: Bool = false)
- function edit_clear(s::MIState)
+ function edit_clear(s :: MIState)
- function edit_copy_region(s::MIState)
+ function edit_copy_region(s :: MIState)
- function edit_delete(buf::IOBuffer)
+ function edit_delete(buf :: IOBuffer)
- function edit_delete(s::MIState)
+ function edit_delete(s :: MIState)
- function edit_delete_next_word(buf::IOBuffer)
+ function edit_delete_next_word(buf :: IOBuffer)
- function edit_delete_next_word(s::MIState)
+ function edit_delete_next_word(s :: MIState)
- function edit_delete_prev_word(buf::IOBuffer)
+ function edit_delete_prev_word(buf :: IOBuffer)
- function edit_delete_prev_word(s::MIState)
+ function edit_delete_prev_word(s :: MIState)
- function edit_exchange_point_and_mark(buf::IOBuffer)
+ function edit_exchange_point_and_mark(buf :: IOBuffer)
- function edit_exchange_point_and_mark(s::MIState)
+ function edit_exchange_point_and_mark(s :: MIState)
- function edit_indent(buf::IOBuffer, num::Int, multiline::Bool)
+ function edit_indent(buf :: IOBuffer, num :: Int, multiline :: Bool)
- function edit_indent(s::MIState, num::Int)
+ function edit_indent(s :: MIState, num :: Int)
- function edit_input(s, f = (filename, line, column) -> InteractiveUtils.edit(filename, line, column))
+ function edit_input(s, f = (filename,line,column)->InteractiveUtils.edit(filename,line,column))
- function edit_insert(buf::IOBuffer, c::StringLike)
+ function edit_insert(buf :: IOBuffer, c :: StringLike)
- function edit_insert(s::PromptState, c::StringLike)
+ function edit_insert(s :: PromptState, c :: StringLike)
- function edit_insert_newline(s::PromptState, align::Int = 0 - options(s).auto_indent)
+ function edit_insert_newline(s :: PromptState, align :: Int = 0-options(s).auto_indent)
- function edit_insert_tab(buf::IOBuffer, jump_spaces::Bool=false, delete_trailing::Bool=jump_spaces)
+ function edit_insert_tab(buf :: IOBuffer, jump_spaces :: Bool = false, delete_trailing :: Bool = jump_spaces)
- function edit_kill_line(s::MIState, backwards::Bool=false)
+ function edit_kill_line(s :: MIState, backwards :: Bool = false)
- function edit_kill_region(s::MIState)
+ function edit_kill_region(s :: MIState)
- function edit_lower_case(s::BufferLike)
+ function edit_lower_case(s :: BufferLike)
- function edit_move_down(buf::IOBuffer)
+ function edit_move_down(buf :: IOBuffer)
- function edit_move_down(s::MIState)
+ function edit_move_down(s :: MIState)
- function edit_move_left(buf::IOBuffer)
+ function edit_move_left(buf :: IOBuffer)
- function edit_move_right(buf::IOBuffer)
+ function edit_move_right(buf :: IOBuffer)
- function edit_move_up(buf::IOBuffer)
+ function edit_move_up(buf :: IOBuffer)
- function edit_move_up(s::MIState)
+ function edit_move_up(s :: MIState)
- function edit_move_word_left(s::PromptState)
+ function edit_move_word_left(s :: PromptState)
- function edit_move_word_right(s::PromptState)
+ function edit_move_word_right(s :: PromptState)
- function edit_redo!(s::MIState)
+ function edit_redo!(s :: MIState)
- function edit_redo!(s::PromptState)
+ function edit_redo!(s :: PromptState)
- function edit_replace_word_right(buf::IOBuffer, replace::Function)
+ function edit_replace_word_right(buf :: IOBuffer, replace :: Function)
- function edit_replace_word_right(s::Union{MIState,ModeState}, replace::Function)
+ function edit_replace_word_right(s :: Union{MIState, ModeState}, replace :: Function)
- function edit_shift_move(s::MIState, move_function::Function)
+ function edit_shift_move(s :: MIState, move_function :: Function)
- function edit_splice!(s::BufferLike, r::Region=region(s), ins::String = ""; rigid_mark::Bool=true)
+ function edit_splice!(s :: BufferLike, r :: Region = region(s), ins :: String = "", rigid_mark :: Bool = true)
- function edit_tab(s::MIState, jump_spaces::Bool=false, delete_trailing::Bool=jump_spaces)
+ function edit_tab(s :: MIState, jump_spaces :: Bool = false, delete_trailing :: Bool = jump_spaces)
- function edit_title_case(s::BufferLike)
+ function edit_title_case(s :: BufferLike)
- function edit_transpose_chars(buf::IOBuffer)
+ function edit_transpose_chars(buf :: IOBuffer)
- function edit_transpose_chars(s::MIState)
+ function edit_transpose_chars(s :: MIState)
- function edit_transpose_lines_down!(buf::IOBuffer, reg::Region)
+ function edit_transpose_lines_down!(buf :: IOBuffer, reg :: Region)
- function edit_transpose_lines_down!(s::MIState)
+ function edit_transpose_lines_down!(s :: MIState)
- function edit_transpose_lines_up!(buf::IOBuffer, reg::Region)
+ function edit_transpose_lines_up!(buf :: IOBuffer, reg :: Region)
- function edit_transpose_lines_up!(s::MIState)
+ function edit_transpose_lines_up!(s :: MIState)
- function edit_transpose_words(buf::IOBuffer, mode::Symbol=:emacs)
+ function edit_transpose_words(buf :: IOBuffer, mode :: Symbol = :emacs)
- function edit_transpose_words(s::MIState)
+ function edit_transpose_words(s :: MIState)
- function edit_undo!(s::MIState)
+ function edit_undo!(s :: MIState)
- function edit_undo!(s::PromptState)
+ function edit_undo!(s :: PromptState)
- function edit_upper_case(s::BufferLike)
+ function edit_upper_case(s :: BufferLike)
- function edit_werase(buf::IOBuffer)
+ function edit_werase(buf :: IOBuffer)
- function edit_werase(s::MIState)
+ function edit_werase(s :: MIState)
- function edit_yank(s::MIState)
+ function edit_yank(s :: MIState)
- function edit_yank_pop(s::MIState, require_previous_yank::Bool=true)
+ function edit_yank_pop(s :: MIState, require_previous_yank :: Bool = true)
- function editor()
+ function editor
- function effectbits_color(effects::Effects, name::Symbol)
+ function effectbits_color(effects :: Effects, name :: Symbol)
- function effectbits_letter(effects::Effects, name::Symbol, suffix::Char)
+ function effectbits_letter(effects :: Effects, name :: Symbol, suffix :: Char)
- function egal_svecs()
+ function egal_svecs
- function egal_tfunc(a, b)
+ function egal_tfunc(a, b)
- function egal_var(p::TypeVar, @nospecialize o)
+ function egal_var(p :: TypeVar, o)
- function eigen!(A::AbstractMatrix, C::Cholesky; sortby::Union{Function,Nothing}=nothing)
+ function eigen!(A :: AbstractMatrix, C :: Cholesky, sortby :: Union{Function, Nothing} = nothing)
- function eigen!(A::HermOrSym{T,S}, B::HermOrSym{T,S}; sortby::Union{Function,Nothing}=nothing) where {T<:BlasReal,S<:StridedMatrix}
+ function eigen!(A :: HermOrSym{T, S}, B :: HermOrSym{T, S}, sortby :: Union{Function, Nothing} = nothing) where T <: BlasReal, S <: StridedMatrix
- function eigen!(A::Hermitian{T,S}, B::Hermitian{T,S}; sortby::Union{Function,Nothing}=nothing) where {T<:BlasComplex,S<:StridedMatrix}
+ function eigen!(A :: Hermitian{T, S}, B :: Hermitian{T, S}, sortby :: Union{Function, Nothing} = nothing) where T <: BlasComplex, S <: StridedMatrix
- function eigen!(A::StridedMatrix{T}, B::StridedMatrix{T}; sortby::Union{Function,Nothing}=eigsortby) where T<:BlasComplex
+ function eigen!(A :: StridedMatrix{T}, B :: StridedMatrix{T}, sortby :: Union{Function, Nothing} = eigsortby) where T <: BlasComplex
- function eigen!(A::StridedMatrix{T}, B::StridedMatrix{T}; sortby::Union{Function,Nothing}=eigsortby) where T<:BlasReal
+ function eigen!(A :: StridedMatrix{T}, B :: StridedMatrix{T}, sortby :: Union{Function, Nothing} = eigsortby) where T <: BlasReal
- function eigen!(A::StridedMatrix{T}; permute::Bool=true, scale::Bool=true, sortby::Union{Function,Nothing}=eigsortby) where T<:BlasComplex
+ function eigen!(A :: StridedMatrix{T}, permute :: Bool = true, scale :: Bool = true, sortby :: Union{Function, Nothing} = eigsortby) where T <: BlasComplex
- function eigen!(A::StridedMatrix{T}; permute::Bool=true, scale::Bool=true, sortby::Union{Function,Nothing}=eigsortby) where T<:BlasReal
+ function eigen!(A :: StridedMatrix{T}, permute :: Bool = true, scale :: Bool = true, sortby :: Union{Function, Nothing} = eigsortby) where T <: BlasReal
- function eigen(A::AbstractMatrix, C::Cholesky; sortby::Union{Function,Nothing}=nothing)
+ function eigen(A :: AbstractMatrix, C :: Cholesky, sortby :: Union{Function, Nothing} = nothing)
- function eigen(A::AbstractMatrix, D::Diagonal; sortby::Union{Function,Nothing}=nothing)
+ function eigen(A :: AbstractMatrix, D :: Diagonal, sortby :: Union{Function, Nothing} = nothing)
- function eigen(A::AbstractMatrix{TA}, B::AbstractMatrix{TB}; kws...) where {TA,TB}
+ function eigen(A :: AbstractMatrix{TA}, B :: AbstractMatrix{TB}, kws...) where TA, TB
- function eigen(A::AbstractMatrix{T}; permute::Bool=true, scale::Bool=true, sortby::Union{Function,Nothing}=eigsortby) where T
+ function eigen(A :: AbstractMatrix{T}, permute :: Bool = true, scale :: Bool = true, sortby :: Union{Function, Nothing} = eigsortby) where T
- function eigen(A::AbstractMatrix{T}; permute::Bool=true, scale::Bool=true, sortby::Union{Function,Nothing}=eigsortby) where {T <: Union{Float16,Complex{Float16}}}
+ function eigen(A :: AbstractMatrix{T}, permute :: Bool = true, scale :: Bool = true, sortby :: Union{Function, Nothing} = eigsortby) where T <: Union{Float16, Complex{Float16}}
- function eigen(A::HermOrSym{TA}, B::HermOrSym{TB}; kws...) where {TA,TB}
+ function eigen(A :: HermOrSym{TA}, B :: HermOrSym{TB}, kws...) where TA, TB
- function eigen(A::RealHermSymComplexHerm, irange::UnitRange)
+ function eigen(A :: RealHermSymComplexHerm, irange :: UnitRange)
- function eigen(A::RealHermSymComplexHerm, vl::Real, vh::Real)
+ function eigen(A :: RealHermSymComplexHerm, vl :: Real, vh :: Real)
- function eigen(A::RealHermSymComplexHerm; sortby::Union{Function,Nothing}=nothing)
+ function eigen(A :: RealHermSymComplexHerm, sortby :: Union{Function, Nothing} = nothing)
- function eigen(D::Diagonal; permute::Bool=true, scale::Bool=true, sortby::Union{Function,Nothing}=nothing)
+ function eigen(D :: Diagonal, permute :: Bool = true, scale :: Bool = true, sortby :: Union{Function, Nothing} = nothing)
- function eigen(D::Diagonal{<:AbstractMatrix}; permute::Bool=true, scale::Bool=true, sortby::Union{Function,Nothing}=nothing)
+ function eigen(D :: Diagonal{??? <: AbstractMatrix}, permute :: Bool = true, scale :: Bool = true, sortby :: Union{Function, Nothing} = nothing)
- function eigen(Da::Diagonal, Db::Diagonal; sortby::Union{Function,Nothing}=nothing)
+ function eigen(Da :: Diagonal, Db :: Diagonal, sortby :: Union{Function, Nothing} = nothing)
- function eigmax(A::Union{Number, AbstractMatrix}; permute::Bool=true, scale::Bool=true)
+ function eigmax(A :: Union{Number, AbstractMatrix}, permute :: Bool = true, scale :: Bool = true)
- function eigvals!(A::AbstractMatrix{T}, C::Cholesky{T, <:AbstractMatrix}; sortby::Union{Function,Nothing}=nothing) where {T<:Number}
+ function eigvals!(A :: AbstractMatrix{T}, C :: Cholesky{T, ??? <: AbstractMatrix}, sortby :: Union{Function, Nothing} = nothing) where T <: Number
- function eigvals!(A::HermOrSym{T,S}, B::HermOrSym{T,S}; sortby::Union{Function,Nothing}=nothing) where {T<:BlasReal,S<:StridedMatrix}
+ function eigvals!(A :: HermOrSym{T, S}, B :: HermOrSym{T, S}, sortby :: Union{Function, Nothing} = nothing) where T <: BlasReal, S <: StridedMatrix
- function eigvals!(A::Hermitian{T,S}, B::Hermitian{T,S}; sortby::Union{Function,Nothing}=nothing) where {T<:BlasComplex,S<:StridedMatrix}
+ function eigvals!(A :: Hermitian{T, S}, B :: Hermitian{T, S}, sortby :: Union{Function, Nothing} = nothing) where T <: BlasComplex, S <: StridedMatrix
- function eigvals!(A::RealHermSymComplexHerm{<:BlasReal,<:StridedMatrix}; sortby::Union{Function,Nothing}=nothing)
+ function eigvals!(A :: RealHermSymComplexHerm{??? <: BlasReal, ??? <: StridedMatrix}, sortby :: Union{Function, Nothing} = nothing)
- function eigvals!(A::StridedMatrix{<:BlasComplex}; permute::Bool=true, scale::Bool=true, sortby::Union{Function,Nothing}=eigsortby)
+ function eigvals!(A :: StridedMatrix{??? <: BlasComplex}, permute :: Bool = true, scale :: Bool = true, sortby :: Union{Function, Nothing} = eigsortby)
- function eigvals!(A::StridedMatrix{<:BlasReal}; permute::Bool=true, scale::Bool=true, sortby::Union{Function,Nothing}=eigsortby)
+ function eigvals!(A :: StridedMatrix{??? <: BlasReal}, permute :: Bool = true, scale :: Bool = true, sortby :: Union{Function, Nothing} = eigsortby)
- function eigvals!(A::StridedMatrix{T}, B::StridedMatrix{T}; sortby::Union{Function,Nothing}=eigsortby) where T<:BlasComplex
+ function eigvals!(A :: StridedMatrix{T}, B :: StridedMatrix{T}, sortby :: Union{Function, Nothing} = eigsortby) where T <: BlasComplex
- function eigvals!(A::StridedMatrix{T}, B::StridedMatrix{T}; sortby::Union{Function,Nothing}=eigsortby) where T<:BlasReal
+ function eigvals!(A :: StridedMatrix{T}, B :: StridedMatrix{T}, sortby :: Union{Function, Nothing} = eigsortby) where T <: BlasReal
- function eigvals(A::AbstractMatrix, C::Cholesky; sortby::Union{Function,Nothing}=nothing)
+ function eigvals(A :: AbstractMatrix, C :: Cholesky, sortby :: Union{Function, Nothing} = nothing)
- function eigvals(A::AbstractMatrix{TA}, B::AbstractMatrix{TB}; kws...) where {TA,TB}
+ function eigvals(A :: AbstractMatrix{TA}, B :: AbstractMatrix{TB}, kws...) where TA, TB
- function eigvals(A::HermOrSym{TA}, B::HermOrSym{TB}; kws...) where {TA,TB}
+ function eigvals(A :: HermOrSym{TA}, B :: HermOrSym{TB}, kws...) where TA, TB
- function eigvals(A::RealHermSymComplexHerm, irange::UnitRange)
+ function eigvals(A :: RealHermSymComplexHerm, irange :: UnitRange)
- function eigvals(A::RealHermSymComplexHerm, vl::Real, vh::Real)
+ function eigvals(A :: RealHermSymComplexHerm, vl :: Real, vh :: Real)
- function eigvals(A::RealHermSymComplexHerm; sortby::Union{Function,Nothing}=nothing)
+ function eigvals(A :: RealHermSymComplexHerm, sortby :: Union{Function, Nothing} = nothing)
- function eigvecs(A::AbstractTriangular{T}) where T
+ function eigvecs(A :: AbstractTriangular{T}) where T
- function eigvecs(A::LowerTriangular{<:BlasFloat,<:StridedMatrix})
+ function eigvecs(A :: LowerTriangular{??? <: BlasFloat, ??? <: StridedMatrix})
- function eigvecs(A::UnitLowerTriangular{<:BlasFloat,<:StridedMatrix})
+ function eigvecs(A :: UnitLowerTriangular{??? <: BlasFloat, ??? <: StridedMatrix})
- function eigvecs(A::UnitUpperTriangular{<:BlasFloat,<:StridedMatrix})
+ function eigvecs(A :: UnitUpperTriangular{??? <: BlasFloat, ??? <: StridedMatrix})
- function eigvecs(A::UpperTriangular{<:BlasFloat,<:StridedMatrix})
+ function eigvecs(A :: UpperTriangular{??? <: BlasFloat, ??? <: StridedMatrix})
- function eigvecs(D::Diagonal{T}) where T<:AbstractMatrix
+ function eigvecs(D :: Diagonal{T}) where T <: AbstractMatrix
- function eigvecs(M::Bidiagonal{T}) where T
+ function eigvecs(M :: Bidiagonal{T}) where T
- function elim_free_typevars(@nospecialize t)
+ function elim_free_typevars(t)
- function elim_full_ir(y)
+ function elim_full_ir(y)
- function elsize(::Type{Ptr{T}}) where T
+ function elsize(??? :: Type{Ptr{T}}) where T
- function eltype(::Type{<:AbstractDict{K,V}}) where {K,V}
+ function eltype(??? :: Type{??? <: AbstractDict{K, V}}) where K, V
- function emit(f, tt...)
+ function emit(f, tt...)
- function emit_lineinfo_update(io::IO, linestart::String, lineidx::Int32)
+ function emit_lineinfo_update(io :: IO, linestart :: String, lineidx :: Int32)
- function emoji_data(url)
+ function emoji_data(url)
- function empty!(B::BitVector)
+ function empty!(B :: BitVector)
- function empty!(a::Vector)
+ function empty!(a :: Vector)
- function empty!(d::IdDict)
+ function empty!(d :: IdDict)
- function empty!(h::Dict{K,V}) where V where K
+ function empty!(h :: Dict{K, V}) where V where K
- function empty!(s::BitSet)
+ function empty!(s :: BitSet)
- function empty!(wkh::WeakKeyDict)
+ function empty!(wkh :: WeakKeyDict)
- function empty(stack :: Stack)
+ function empty(stack :: Stack)
- function empty_backedges!(frame::InferenceState, currpc::Int=frame.currpc)
+ function empty_backedges!(frame :: InferenceState, currpc :: Int = frame.currpc)
- function empty_nt_keys(Tpl)
+ function empty_nt_keys(Tpl)
- function empty_nt_values(Tpl)
+ function empty_nt_values(Tpl)
- function empty_undo(s::PromptState)
+ function empty_undo(s :: PromptState)
- function en_dash(stream::IO, md::MD)
+ function en_dash(stream :: IO, md :: MD)
- function enable_finalizers() @inline
+ function enable_finalizers
- function enable_logging(on::Bool=true)
+ @@inlinefunction enable_logging(on :: Bool = true)
- function encode_effects(e::Effects)
+ function encode_effects(e :: Effects)
- function encode_effects_override(eo::EffectsOverride)
+ function encode_effects_override(eo :: EffectsOverride)
- function end_loading(modkey::PkgId, @nospecialize loaded)
+ function end_loading(modkey :: PkgId, loaded)
- function endofline(buf::IOBuffer, pos::Int=position(buf))
+ function endofline(buf :: IOBuffer, pos :: Int = position(buf))
- function endswith(a::AbstractString, b::AbstractString)
+ function endswith(a :: AbstractString, b :: AbstractString)
- function endswith(s::AbstractString, r::Regex)
+ function endswith(s :: AbstractString, r :: Regex)
- function endswith(s::SubString{String}, r::Regex)
+ function endswith(s :: SubString{String}, r :: Regex)
- function enq_work(t::Task)
+ function enq_work(t :: Task)
- function ensure_initialized()
+ function ensure_initialized
- function ensure_rescheduled(othertask::Task)
+ function ensure_rescheduled(othertask :: Task)
- function ensureroom_slowpath(io::GenericIOBuffer, nshort::UInt)
+ function ensureroom_slowpath(io :: GenericIOBuffer, nshort :: UInt)
- function enter_prefix_search(s::MIState, p::PrefixHistoryPrompt, backward::Bool)
+ function enter_prefix_search(s :: MIState, p :: PrefixHistoryPrompt, backward :: Bool)
- function enter_search(s::MIState, p::HistoryPrompt, backward::Bool)
+ function enter_search(s :: MIState, p :: HistoryPrompt, backward :: Bool)
- function entry_index(trie::HAMT, bi::BitmapIndex)
+ function entry_index(trie :: HAMT, bi :: BitmapIndex)
- function entry_path(path::String, name::String)::Union{Nothing,String}
+ function entry_path(path :: String, name :: String)
- function entry_point_and_project_file(dir::String, name::String)::Union{Tuple{Nothing,Nothing},Tuple{String,Nothing},Tuple{String,String}}
+ function entry_point_and_project_file(dir :: String, name :: String)
- function entry_point_and_project_file_inside(dir::String, name::String)::Union{Tuple{Nothing,Nothing},Tuple{String,Nothing},Tuple{String,String}}
+ function entry_point_and_project_file_inside(dir :: String, name :: String)
- function entry_to_be_invalidated(c)
+ function entry_to_be_invalidated(c)
- function entryid(te::GitTreeEntry)
+ function entryid(te :: GitTreeEntry)
- function entrytype(te::GitTreeEntry)
+ function entrytype(te :: GitTreeEntry)
- function env_project_file(env::String)::Union{Bool,String}
+ function env_project_file(env :: String)
- function eof(s::BufferStream)
+ function eof(s :: BufferStream)
- function eof(s::LibuvStream)
+ function eof(s :: LibuvStream)
- function equal(ci1::Core.CodeInfo, ci2::Core.CodeInfo)
+ function equal(ci1 :: Core.CodeInfo, ci2 :: Core.CodeInfo)
- function err_message(errno::Integer)
+ function err_message(errno :: Integer)
- function error(s::Vararg{Any,N}) where {N}
+ function error(s :: Vararg{Any, N}) where N
- function errorbounds(A::AbstractTriangular{TA}, X::AbstractVecOrMat{TX}, B::AbstractVecOrMat{TB}) where {TA<:Number,TX<:Number,TB<:Number}
+ function errorbounds(A :: AbstractTriangular{TA}, X :: AbstractVecOrMat{TX}, B :: AbstractVecOrMat{TB}) where TA <: Number, TX <: Number, TB <: Number
- function errormonitor(t::Task)
+ function errormonitor(t :: Task)
- function errors_not_signals(cmd::Cmd)
+ function errors_not_signals(cmd :: Cmd)
- function errors_not_signals(p::Base.Process)
+ function errors_not_signals(p :: Base.Process)
- function esc_code(s)
+ function esc_code(s)
- function escape_array_copy!(astate::AnalysisState, pc::Int, args::Vector{Any})
+ function escape_array_copy!(astate :: AnalysisState, pc :: Int, args :: Vector{Any})
- function escape_builtin!(::typeof(getfield), astate::AnalysisState, pc::Int, args::Vector{Any})
+ function escape_builtin!(??? :: typeof(getfield), astate :: AnalysisState, pc :: Int, args :: Vector{Any})
- function escape_builtin!(::typeof(ifelse), astate::AnalysisState, pc::Int, args::Vector{Any})
+ function escape_builtin!(??? :: typeof(ifelse), astate :: AnalysisState, pc :: Int, args :: Vector{Any})
- function escape_builtin!(::typeof(setfield!), astate::AnalysisState, pc::Int, args::Vector{Any})
+ function escape_builtin!(??? :: typeof(setfield!), astate :: AnalysisState, pc :: Int, args :: Vector{Any})
- function escape_builtin!(::typeof(tuple), astate::AnalysisState, pc::Int, args::Vector{Any})
+ function escape_builtin!(??? :: typeof(tuple), astate :: AnalysisState, pc :: Int, args :: Vector{Any})
- function escape_builtin!(::typeof(typeassert), astate::AnalysisState, pc::Int, args::Vector{Any})
+ function escape_builtin!(??? :: typeof(typeassert), astate :: AnalysisState, pc :: Int, args :: Vector{Any})
- function escape_call!(astate::AnalysisState, pc::Int, args::Vector{Any})
+ function escape_call!(astate :: AnalysisState, pc :: Int, args :: Vector{Any})
- function escape_edges!(astate::AnalysisState, pc::Int, edges::Vector{Any})
+ function escape_edges!(astate :: AnalysisState, pc :: Int, edges :: Vector{Any})
- function escape_exception!(astate::AnalysisState, tryregions::Vector{UnitRange{Int}})
+ function escape_exception!(astate :: AnalysisState, tryregions :: Vector{UnitRange{Int}})
- function escape_foreigncall!(astate::AnalysisState, pc::Int, args::Vector{Any})
+ function escape_foreigncall!(astate :: AnalysisState, pc :: Int, args :: Vector{Any})
- function escape_invoke!(astate::AnalysisState, pc::Int, args::Vector{Any})
+ function escape_invoke!(astate :: AnalysisState, pc :: Int, args :: Vector{Any})
- function escape_microsoft_c_args(io::IO, args::AbstractString...)
+ function escape_microsoft_c_args(io :: IO, args :: AbstractString...)
- function escape_new!(astate::AnalysisState, pc::Int, args::Vector{Any})
+ function escape_new!(astate :: AnalysisState, pc :: Int, args :: Vector{Any})
- function escape_raw_string(io::IO, str::AbstractString, delim::Char='"')
+ function escape_raw_string(io :: IO, str :: AbstractString, delim :: Char = '"')
- function escape_raw_string(str::AbstractString, delim::Char='"')
+ function escape_raw_string(str :: AbstractString, delim :: Char = '"')
- function escape_string(io::IO, s::AbstractString, esc=""; keep = ())
+ function escape_string(io :: IO, s :: AbstractString, esc = "", keep = ())
- function escape_unanalyzable_obj!(astate::AnalysisState, @nospecialize(obj), objinfo::EscapeInfo)
+ function escape_unanalyzable_obj!(astate :: AnalysisState, obj, objinfo :: EscapeInfo)
- function escape_val!(astate::AnalysisState, pc::Int, @nospecialize(val))
+ function escape_val!(astate :: AnalysisState, pc :: Int, val)
- function escape_val_ifdefined!(astate::AnalysisState, pc::Int, x)
+ function escape_val_ifdefined!(astate :: AnalysisState, pc :: Int, x)
- function escapes(stream::IO, md::MD)
+ function escapes(stream :: IO, md :: MD)
- function euler11(grid,n)
+ function euler11(grid, n)
- function euler14(m)
+ function euler14(m)
- function euler2(n)
+ function euler2(n)
- function euler4(n)
+ function euler4(n)
- function euler8(n,m)
+ function euler8(n, m)
- function euler9(n)
+ function euler9(n)
- function eval_test(evaluated::Expr, quoted::Expr, source::LineNumberNode, negate::Bool=false)
+ function eval_test(evaluated :: Expr, quoted :: Expr, source :: LineNumberNode, negate :: Bool = false)
- function eval_user_input(@nospecialize(ast), backend::REPLBackend, mod::Module)
+ function eval_user_input(ast, backend :: REPLBackend, mod :: Module)
- function eval_user_input(errio, @nospecialize(ast), show_value::Bool)
+ function eval_user_input(errio, ast, show_value :: Bool)
- function eval_with_backend(ast, backend::REPLBackendRef)
+ function eval_with_backend(ast, backend :: REPLBackendRef)
- function evalfile(path::AbstractString, args::Vector{String}=String[])
+ function evalfile(path :: AbstractString, args :: Vector{String} = String[])
- function evalpoly(x, p::Tuple)
+ function evalpoly(x, p :: Tuple)
- function evalpoly(z::Complex, p::Tuple)
+ function evalpoly(z :: Complex, p :: Tuple)
- function examine(mt::Core.MethodTable)
+ function examine(mt :: Core.MethodTable)
- function example_function(x, y, z)
+ function example_function(x, y, z)
- function exe7z()
+ function exe7z
- function exec_options(opts)
+ function exec_options(opts)
- function exec_r(re, subject, offset, options)
+ function exec_r(re, subject, offset, options)
- function exec_r_data(re, subject, offset, options)
+ function exec_r_data(re, subject, offset, options)
- function exhausted_abort()
+ function exhausted_abort
- function exit_on_sigint(on::Bool)
+ function exit_on_sigint(on :: Bool)
- function exp!(A::StridedMatrix{T}) where T<:BlasFloat
+ function exp!(A :: StridedMatrix{T}) where T <: BlasFloat
- function exp(z::Complex)
+ function exp(z :: Complex)
- function exp10(z::Complex{T}) where T
+ function exp10(z :: Complex{T}) where T
- function exp2(z::Complex{T}) where T
+ function exp2(z :: Complex{T}) where T
- function expand_ccallable(rt, def)
+ function expand_ccallable(rt, def)
- function expanduser(path::AbstractString)
+ function expanduser(path :: AbstractString)
- function expb_kernel(::Val{10}, x::Float32)
+ function expb_kernel(??? :: Val{DependentType@6ce253f1}, x :: Float32)
- function expb_kernel(::Val{2}, x::Float32)
+ function expb_kernel(??? :: Val{DependentType@53d8d10a}, x :: Float32)
- function expb_kernel(::Val{:ℯ}, x::Float32)
+ function expb_kernel(??? :: Val{:, ℯ}, x :: Float32)
- function explicit_manifest_deps_get(project_file::String, where::PkgId, name::String)::Union{Nothing,PkgId}
+ function explicit_manifest_deps_get(project_file :: String, where :: PkgId, name :: String)
- function explicit_manifest_entry_path(manifest_file::String, pkg::PkgId, entry::Dict{String,Any})
+ function explicit_manifest_entry_path(manifest_file :: String, pkg :: PkgId, entry :: Dict{String, Any})
- function explicit_manifest_uuid_path(project_file::String, pkg::PkgId)::Union{Nothing,String,Missing}
+ function explicit_manifest_uuid_path(project_file :: String, pkg :: PkgId)
- function explicit_mantissa_noinfnan(x::T) where {T<:IEEEFloat}
+ function explicit_mantissa_noinfnan(x :: T) where T <: IEEEFloat
- function explicit_noinline(args...)
+ function explicit_noinline(args...)
- function explicit_project_deps_get(project_file::String, name::String)::Union{Nothing,UUID}
+ function explicit_project_deps_get(project_file :: String, name :: String)
- function expm1(x::Float16)
+ function expm1(x :: Float16)
- function expm1(x::Float32)
+ function expm1(x :: Float32)
- function expm1(x::Float64)
+ function expm1(x :: Float64)
- function expm1(z::Complex{T}) where T<:Real
+ function expm1(z :: Complex{T}) where T <: Real
- function expm1b_kernel(::Val{10}, x::Float64)
+ function expm1b_kernel(??? :: Val{DependentType@e9e54c2}, x :: Float64)
- function expm1b_kernel(::Val{2}, x::Float64)
+ function expm1b_kernel(??? :: Val{DependentType@65ab7765}, x :: Float64)
- function expm1b_kernel(::Val{:ℯ}, x::Float64)
+ function expm1b_kernel(??? :: Val{:, ℯ}, x :: Float64)
- function exponent(x::BigFloat)
+ function exponent(x :: BigFloat)
- function exponent(x::T) where T<:IEEEFloat
+ function exponent(x :: T) where T <: IEEEFloat
- function export!(a::AbstractVector{T}, n::BigInt; order::Integer=-1, nails::Integer=0, endian::Integer=0) where {T<:Base.BitInteger}
+ function export!(a :: AbstractVector{T}, n :: BigInt, order :: Integer = -1, nails :: Integer = 0, endian :: Integer = 0) where T <: Base.BitInteger
- function exprresolve(ex::Expr)
+ function exprresolve(ex :: Expr)
- function exprresolve_arith(ex::Expr)
+ function exprresolve_arith(ex :: Expr)
- function exprresolve_conditional(ex::Expr)
+ function exprresolve_conditional(ex :: Expr)
- function extendedterminfo(data::IO, NumInt::Union{Type{UInt16}, Type{UInt32}})
+ function extendedterminfo(data :: IO, NumInt :: Union{Type{UInt16}, Type{UInt32}})
- function f()
+ function f
- function f(; x)
+ function f(x)
- function f(; x=2)
+ function f(x = 2)
- function f(io::IO)
+ function f(io :: IO)
- function f(x)
+ function f(x)
- function f(x::Vector{T}) where {T}
+ function f(x :: Vector{T}) where T
- function f1()
+ function f1
- function f1(a)
+ function f1(a)
- function f1(a, b, c, d)
+ function f1(a, b, c, d)
- function f1(cond)
+ function f1(cond)
- function f1090(x)::Int
+ function f1090(x)
- function f1090_err()::Int
+ function f1090_err
- function f11065()
+ function f11065
- function f11295(x...)
+ function f11295(x...)
- function f11355(arg::DataType)
+ function f11355(arg :: DataType)
- function f11355(sig::Type{T}) where T<:Tuple
+ function f11355(sig :: Type{T}) where T <: Tuple
- function f11357()
+ function f11357
- function f11675(x)
+ function f11675(x)
- function f12476(a)
+ function f12476(a)
- function f13127()
+ function f13127
- function f13432(x)
+ function f13432(x)
- function f13432b(x)
+ function f13432b(x)
- function f13647(x, y)
+ function f13647(x, y)
- function f14346(id, mask, limit)
+ function f14346(id, mask, limit)
- function f14893()
+ function f14893
- function f15180(x::T) where T
+ function f15180(x :: T) where T
- function f15276(x)
+ function f15276(x)
- function f15425(x)
+ function f15425(x)
- function f15447(s, a)
+ function f15447(s, a)
- function f15561()
+ function f15561
- function f15714(array_var15714)
+ function f15714(array_var15714)
- function f15809()
+ function f15809
- function f15844(x)
+ function f15844(x)
- function f15894(d)
+ function f15894(d)
- function f16023()
+ function f16023
- function f16158(x)
+ function f16158(x)
- function f16340(x::T) where T
+ function f16340(x :: T) where T
- function f16431(x)
+ function f16431(x)
- function f16783()
+ function f16783
- function f17204(a)
+ function f17204(a)
- function f17255(n)
+ function f17255(n)
- function f17572(::Type{Val{A}}) where A
+ function f17572(??? :: Type{Val{A}}) where A
- function f17613_2(x)::Float64
+ function f17613_2(x)
- function f18173()
+ function f18173
- function f18385(g)
+ function f18385(g)
- function f18386(a, b, second_pass)
+ function f18386(a, b, second_pass)
- function f18621()
+ function f18621
- function f18679()
+ function f18679
- function f19333(x19333)
+ function f19333(x19333)
- function f19554(a)
+ function f19554(a)
- function f19554_2(a, b)
+ function f19554_2(a, b)
- function f1_30093(r)
+ function f1_30093(r)
- function f1_optrefine(b)
+ function f1_optrefine(b)
- function f2()
+ function f2
- function f2(a)
+ function f2(a)
- function f2(a, b, c, d, e...)
+ function f2(a, b, c, d, e...)
- function f2(cond)
+ function f2(cond)
- function f20961(x::Vector{Vec{N, T}}, y::Vector{Vec{N, T}}) where{N, T}
+ function f20961(x :: Vector{Vec{N, T}}, y :: Vector{Vec{N, T}}) where N, T
- function f21065(x,y)
+ function f21065(x, y)
- function f21147(f::Tuple{A}; kwargs...) where {B,A<:Tuple{B}}
+ function f21147(f :: Tuple{A}, kwargs...) where B, A <: Tuple{B}
- function f21900()
+ function f21900
- function f21972()
+ function f21972
- function f22314()
+ function f22314
- function f22440_gen(world::UInt, source, _, y)
+ function f22440_gen(world :: UInt, source, _, y)
- function f22938(a, b, x...)
+ function f22938(a, b, x...)
- function f23024(::Type{T}, ::Int) where T
+ function f23024(??? :: Type{T}, ??? :: Int) where T
- function f23168(a, x)
+ function f23168(a, x)
- function f24331()
+ function f24331
- function f24852_early_expr(f, x::X, y::Y) where {X, Y}
+ function f24852_early_expr(f, x :: X, y :: Y) where X, Y
- function f24852_early_inflated(f, x::X, y::Y) where {X, Y}
+ function f24852_early_inflated(f, x :: X, y :: Y) where X, Y
- function f24852_early_uninflated(f, x::X, y::Y) where {X, Y}
+ function f24852_early_uninflated(f, x :: X, y :: Y) where X, Y
- function f24852_gen_cinfo_inflated(world::UInt, source, X, Y, _, f, x, y)
+ function f24852_gen_cinfo_inflated(world :: UInt, source, X, Y, _, f, x, y)
- function f24852_gen_cinfo_uninflated(world::UInt, source, X, Y, _, f, x, y)
+ function f24852_gen_cinfo_uninflated(world :: UInt, source, X, Y, _, f, x, y)
- function f24852_gen_expr(X, Y, _, f, x, y)
+ function f24852_gen_expr(X, Y, _, f, x, y)
- function f24852_kernel_cinfo(world::UInt, source, fsig::Type)
+ function f24852_kernel_cinfo(world :: UInt, source, fsig :: Type)
- function f24852_late_expr(f, x::X, y::Y) where {X, Y}
+ function f24852_late_expr(f, x :: X, y :: Y) where X, Y
- function f25055()
+ function f25055
- function f25579(g)
+ function f25579(g)
- function f26743()
+ function f26743
- function f27079()
+ function f27079
- function f27103()
+ function f27103
- function f27181()
+ function f27181
- function f27209(x::Union{Float64, Nothing})
+ function f27209(x :: Union{Float64, Nothing})
- function f27268()
+ function f27268
- function f27268_2()
+ function f27268_2
- function f27597(y)
+ function f27597(y)
- function f28044(::Val{code28044}) where code28044
+ function f28044(??? :: Val{code28044}) where code28044
- function f28279(b::Bool)
+ function f28279(b :: Bool)
- function f28356(::Type{T}) where {T<:Union{Float64,Float32}}
+ function f28356(??? :: Type{T}) where T <: Union{Float64, Float32}
- function f28399()
+ function f28399
- function f28789()
+ function f28789
- function f28825()
+ function f28825
- function f29036(s, i)
+ function f29036(s, i)
- function f29152()
+ function f29152
- function f29175(tuple::T) where {T<:Tuple}
+ function f29175(tuple :: T) where T <: Tuple
- function f29326()::Any
+ function f29326
- function f29718()
+ function f29718
- function f2_optrefine()
+ function f2_optrefine
- function f3(a)
+ function f3(a)
- function f3(cond)
+ function f3(cond)
- function f30679(::DataType)
+ function f30679(??? :: DataType)
- function f30679(t::Type{Int})
+ function f30679(t :: Type{Int})
- function f30772(a::T) where T
+ function f30772(a :: T) where T
- function f31353(f, x::Array{<:Dict})
+ function f31353(f, x :: Array{??? <: Dict})
- function f31824(input...)
+ function f31824(input...)
- function f32579(x::Int, b::Bool)
+ function f32579(x :: Int, b :: Bool)
- function f32620(x::T) where T
+ function f32620(x :: T) where T
- function f32820(refs)
+ function f32820(refs)
- function f32843(vals0, v)
+ function f32843(vals0, v)
- function f33590(b, x)
+ function f33590(b, x)
- function f33768()
+ function f33768
- function f33915(a_tuple, which_ones)
+ function f33915(a_tuple, which_ones)
- function f34247(a)
+ function f34247(a)
- function f34459(args...)
+ function f34459(args...)
- function f34482()
+ function f34482
- function f3471(y)
+ function f3471(y)
- function f36527()
+ function f36527
- function f37044(r)
+ function f37044(r)
- function f37262(x)
+ function f37262(x)
- function f37555(x::Int; kwargs...)
+ function f37555(x :: Int, kwargs...)
- function f3821()
+ function f3821
- function f3852()
+ function f3852
- function f38751!(dest::Vector{UInt8}, src::Vector{UInt8}, n::UInt)
+ function f38751!(dest :: Vector{UInt8}, src :: Vector{UInt8}, n :: UInt)
- function f39232(a)
+ function f39232(a)
- function f3_optrefine(x)
+ function f3_optrefine(x)
- function f4(a, p)
+ function f4(a, p)
- function f4(cond)
+ function f4(cond)
- function f42645()
+ function f42645
- function f42752(do_gc::Bool, cell = (()->Any[[]])())
+ function f42752(do_gc :: Bool, cell = (()->Any[[]])())
- function f44200()
+ function f44200
- function f44336()
+ function f44336
- function f44921(a)
+ function f44921(a)
- function f4528(A, B)
+ function f4528(A, B)
- function f47374(i::Int, x)
+ function f47374(i :: Int, x)
- function f47374(x)
+ function f47374(x)
- function f48802!(log, x::Integer)
+ function f48802!(log, x :: Integer)
- function f48889()
+ function f48889
- function f5(a)
+ function f5(a)
- function f5457(obj_ptr::Ptr{Float64}, f)
+ function f5457(obj_ptr :: Ptr{Float64}, f)
- function f5584()
+ function f5584
- function f5906(h::Hanoi5906{T}) where T
+ function f5906(h :: Hanoi5906{T}) where T
- function f6(a)
+ function f6(a)
- function f6(e)
+ function f6(e)
- function f6591(d)
+ function f6591(d)
- function f6597(c)
+ function f6597(c)
- function f7(a)
+ function f7(a)
- function f7234_a()
+ function f7234_a
- function f7234_b()
+ function f7234_b
- function f8(a, c)
+ function f8(a, c)
- function f8(b,y)
+ function f8(b, y)
- function f9(a)
+ function f9(a)
- function f9134()
+ function f9134
- function f9770(x)
+ function f9770(x)
- function f9947()
+ function f9947
- function fNonBitsTypeConstants()
+ function fNonBitsTypeConstants
- function f_29213()
+ function f_29213
- function f_31546(x)
+ function f_31546(x)
- function f_apply_bail(f)
+ function f_apply_bail(f)
- function f_apply_typevar(T)
+ function f_apply_typevar(T)
- function f_apply_union_split(fs, x)
+ function f_apply_union_split(fs, x)
- function f_boundscheck_elim(n)
+ function f_boundscheck_elim(n)
- function f_call_total_noinline_unused(x)
+ function f_call_total_noinline_unused(x)
- function f_call_volatile_escape(ptr)
+ function f_call_volatile_escape(ptr)
- function f_convert_me_to_ir(b, x)
+ function f_convert_me_to_ir(b, x)
- function f_dict_hash_alloc()
+ function f_dict_hash_alloc
- function f_div(x)
+ function f_div(x)
- function f_div(x, y)
+ function f_div(x, y)
- function f_finalizer_throws()
+ function f_finalizer_throws
- function f_ifelse(x)
+ function f_ifelse(x)
- function f_inferred_union()
+ function f_inferred_union
- function f_oc_noinline_call(x, y)
+ function f_oc_noinline_call(x, y)
- function f_subtype()
+ function f_subtype
- function f_total_noinline(x)
+ function f_total_noinline(x)
- function f_typ_assert(x::Int)
+ function f_typ_assert(x :: Int)
- function f_typ_assert2(x::Any)
+ function f_typ_assert2(x :: Any)
- function f_typeassert(c)
+ function f_typeassert(c)
- function f_unused_undefined_sp(::T...) where T
+ function f_unused_undefined_sp(??? :: T...) where T
- function f_voltatile_escape(ptr)
+ function f_voltatile_escape(ptr)
- function f_with_early_try_catch_exit()
+ function f_with_early_try_catch_exit
- function f_with_maybe_nonbool_cond(a::Int, r::Bool)
+ function f_with_maybe_nonbool_cond(a :: Int, r :: Bool)
- function f_with_slots(a, b)
+ function f_with_slots(a, b)
- function factor_recreation_tests(a_U, a_L)
+ function factor_recreation_tests(a_U, a_L)
- function factorial(n::Integer)
+ function factorial(n :: Integer)
- function factorial(x::BigFloat)
+ function factorial(x :: BigFloat)
- function factorial_lookup(n::Integer, table, lim)
+ function factorial_lookup(n :: Integer, table, lim)
- function factorize(A::AbstractMatrix{T}) where T
+ function factorize(A :: AbstractMatrix{T}) where T
- function failfast_print()
+ function failfast_print
- function failval(s, v)
+ function failval(s, v)
- function fake_repl(@nospecialize(f); options::REPL.Options=REPL.Options(confirm_exit=false))
+ function fake_repl(f, options :: REPL.Options = REPL.Options(confirm_exit=false))
- function fdio(name::AbstractString, fd::Integer, own::Bool=false)
+ function fdio(name :: AbstractString, fd :: Integer, own :: Bool = false)
- function feature_names()
+ function feature_names
- function features()
+ function features
- function fencedcode(stream::IO, block::MD)
+ function fencedcode(stream :: IO, block :: MD)
- function fetch()
+ function fetch
- function fetch(;include_meta = true, limitwarn = true)
+ function fetch(include_meta = true, limitwarn = true)
- function fetch(t::Task)
+ function fetch(t :: Task)
- function fetch_buffered(c::Channel)
+ function fetch_buffered(c :: Channel)
- function fetch_refspecs(rmt::GitRemote)
+ function fetch_refspecs(rmt :: GitRemote)
- function fetchheads(repo::GitRepo)
+ function fetchheads(repo :: GitRepo)
- function ffmerge!(repo::GitRepo, ann::GitAnnotated)
+ function ffmerge!(repo :: GitRepo, ann :: GitAnnotated)
- function field_completion_eligible(@nospecialize t)
+ function field_completion_eligible(t)
- function fieldcount(@nospecialize t)
+ function fieldcount(t)
- function fieldcount_noerror(@nospecialize t)
+ function fieldcount_noerror(t)
- function fielddoc(binding::Binding, field::Symbol)
+ function fielddoc(binding :: Binding, field :: Symbol)
- function fieldindex(T::DataType, name::Symbol, err::Bool=true)
+ function fieldindex(T :: DataType, name :: Symbol, err :: Bool = true)
- function fieldindex(t::UnionAll, name::Symbol, err::Bool=true)
+ function fieldindex(t :: UnionAll, name :: Symbol, err :: Bool = true)
- function fieldname(t::DataType, i::Integer)
+ function fieldname(t :: DataType, i :: Integer)
- function filemode(te::GitTreeEntry)
+ function filemode(te :: GitTreeEntry)
- function filemode_string(mode)
+ function filemode_string(mode)
- function filename(te::GitTreeEntry)
+ function filename(te :: GitTreeEntry)
- function files_changed(diff_stat::GitDiffStats)
+ function files_changed(diff_stat :: GitDiffStats)
- function filesize(s::IOStream)
+ function filesize(s :: IOStream)
- function fill!(A::AbstractArray{T}, x) where T
+ function fill!(A :: AbstractArray{T}, x) where T
- function fill!(A::Union{Diagonal,Bidiagonal,Tridiagonal,SymTridiagonal}, x)
+ function fill!(A :: Union{Diagonal, Bidiagonal, Tridiagonal, SymTridiagonal}, x)
- function fill!(B::BitArray, x)
+ function fill!(B :: BitArray, x)
- function fill!(S::SharedArray, v)
+ function fill!(S :: SharedArray, v)
- function fill!(V::SubArray{Bool, <:Any, <:BitArray, <:Tuple{AbstractUnitRange{Int}}}, x)
+ function fill!(V :: SubArray{Bool, ??? <: Any, ??? <: BitArray, ??? <: Tuple{AbstractUnitRange{Int}}}, x)
- function fill!(a::Union{Array{UInt8}, Array{Int8}}, x::Integer)
+ function fill!(a :: Union{Array{UInt8}, Array{Int8}}, x :: Integer)
- function fill!(a::Union{Memory{UInt8}, Memory{Int8}}, x::Integer)
+ function fill!(a :: Union{Memory{UInt8}, Memory{Int8}}, x :: Integer)
- function fill!(cfg::GitConfig, cred::GitCredential)
+ function fill!(cfg :: GitConfig, cred :: GitCredential)
- function fill!(dest::Array{T}, x) where T
+ function fill!(dest :: Array{T}, x) where T
- function fill_array!(rng::MersenneTwister, A::Ptr{Float64}, n::Int, I)
+ function fill_array!(rng :: MersenneTwister, A :: Ptr{Float64}, n :: Int, I)
- function fill_bitarray_from_itr!(B::BitArray, itr)
+ function fill_bitarray_from_itr!(B :: BitArray, itr)
- function fill_chunks!(Bc::Array{UInt64}, x::Bool, pos::Int, numbits::Int)
+ function fill_chunks!(Bc :: Array{UInt64}, x :: Bool, pos :: Int, numbits :: Int)
- function fillband!(A::AbstractMatrix{T}, x, l, u) where T
+ function fillband!(A :: AbstractMatrix{T}, x, l, u) where T
- function fillcells!(mc::Array{Cell})
+ function fillcells!(mc :: Array{Cell})
- function fillstored!(A::HermOrSym{T}, x) where T
+ function fillstored!(A :: HermOrSym{T}, x) where T
- function filter!(f, a::AbstractVector)
+ function filter!(f, a :: AbstractVector)
- function filter!(f, d::AbstractDict)
+ function filter!(f, d :: AbstractDict)
- function filter!(pred, h::Dict{K,V}) where {K,V}
+ function filter!(pred, h :: Dict{K, V}) where K, V
- function filter(f)
+ function filter(f)
- function filter(f, Bs::BitArray)
+ function filter(f, Bs :: BitArray)
- function filter(f, a::AbstractArray)
+ function filter(f, a :: AbstractArray)
- function filter(f, a::Array{T, N}) where {T, N}
+ function filter(f, a :: Array{T, N}) where T, N
- function filter(f, d::AbstractDict)
+ function filter(f, d :: AbstractDict)
- function filter(f, itr::SkipMissing{<:AbstractArray})
+ function filter(f, itr :: SkipMissing{??? <: AbstractArray})
- function filter(f, s::AbstractString)
+ function filter(f, s :: AbstractString)
- function filter(f, s::Union{String, SubString{String}})
+ function filter(f, s :: Union{String, SubString{String}})
- function filter_errors(ts::DefaultTestSet)
+ function filter_errors(ts :: DefaultTestSet)
- function filter_in_one_pass!(f, d::AbstractDict)
+ function filter_in_one_pass!(f, d :: AbstractDict)
- function filter_preferences(prefs::Dict{String, Any}, pkg_name)
+ function filter_preferences(prefs :: Dict{String, Any}, pkg_name)
- function filtered_mod_names(ffunc::Function, mod::Module, name::AbstractString, all::Bool = false, imported::Bool = false)
+ function filtered_mod_names(ffunc :: Function, mod :: Module, name :: AbstractString, all :: Bool = false, imported :: Bool = false)
- function filtertests!(tests, name, files=[name])
+ function filtertests!(tests, name, files = [name])
- function fin(f)
+ function fin(f)
- function final_shred!(s::SecretBuffer)
+ function final_shred!(s :: SecretBuffer)
- function finalize_and_test(r)
+ function finalize_and_test(r)
- function finalize_refs(S::SharedArray{T,N}) where T where N
+ function finalize_refs(S :: SharedArray{T, N}) where T where N
- function finalizer(@nospecialize(f), @nospecialize(o))
+ function finalizer(f, o)
- function finalizer(f::Ptr{Cvoid}, o::T) where T @inline
+ function finalizer(f :: Ptr{Cvoid}, o :: T) where T
- function find7z()
+ @@inlinefunction find7z
- function find_all_in_cache_path(pkg::PkgId)
+ function find_all_in_cache_path(pkg :: PkgId)
- function find_artifacts_toml(path::String)
+ function find_artifacts_toml(path :: String)
- function find_call(code::Core.CodeInfo, @nospecialize(func), narg)
+ function find_call(code :: Core.CodeInfo, func, narg)
- function find_constrained_arg(cnd::Conditional, fargs::Vector{Any}, sv::InferenceState)
+ function find_constrained_arg(cnd :: Conditional, fargs :: Vector{Any}, sv :: InferenceState)
- function find_curblock(domtree::DomTree, allblocks::BitSet, curblock::Int)
+ function find_curblock(domtree :: DomTree, allblocks :: BitSet, curblock :: Int)
- function find_dict_matches(identifier::AbstractDict, partial_key)
+ function find_dict_matches(identifier :: AbstractDict, partial_key)
- function find_dominating_assignment(id::Int, idx::Int, sv::InferenceState)
+ function find_dominating_assignment(id :: Int, idx :: Int, sv :: InferenceState)
- function find_ext_path(project_path::String, extname::String)
+ function find_ext_path(project_path :: String, extname :: String)
- function find_library(libnames, extrapaths=String[])
+ function find_library(libnames, extrapaths = String[])
- function find_package(arg)
+ function find_package(arg)
- function find_readme(m::Module)::Union{String, Nothing}
+ function find_readme(m :: Module)
- function find_root_impl!(parents::Vector{T}, x::Integer) where {T<:Integer}
+ function find_root_impl!(parents :: Vector{T}, x :: Integer) where T <: Integer
- function find_source_file(path::AbstractString)
+ function find_source_file(path :: AbstractString)
- function find_ssavalue_uses(body::Vector{Any}, nvals::Int)
+ function find_ssavalue_uses(body :: Vector{Any}, nvals :: Int)
- function find_ssavalue_uses(e::Expr, uses::Vector{BitSet}, line::Int)
+ function find_ssavalue_uses(e :: Expr, uses :: Vector{BitSet}, line :: Int)
- function find_ssavalue_uses(e::PhiNode, uses::Vector{BitSet}, line::Int)
+ function find_ssavalue_uses(e :: PhiNode, uses :: Vector{BitSet}, line :: Int)
- function find_ssavalue_uses1(compact::IncrementalCompact)
+ function find_ssavalue_uses1(compact :: IncrementalCompact)
- function find_start_brace(s::AbstractString; c_start='(', c_end=')')
+ function find_start_brace(s :: AbstractString, c_start = '(', c_end = ')')
- function find_terminfo_file(term::String)
+ function find_terminfo_file(term :: String)
- function find_tfunc(@nospecialize f)
+ function find_tfunc(f)
- function find_throw_blocks(code::Vector{Any}, handler_at::Vector{Int})
+ function find_throw_blocks(code :: Vector{Any}, handler_at :: Vector{Int})
- function find_tvar10930(arg)
+ function find_tvar10930(arg)
- function find_unsuitable_manifests_versions()
+ function find_unsuitable_manifests_versions
- function findall(@nospecialize(sig::Type), table::CachedMethodTable; limit::Int=-1)
+ function findall(sig :: Type, table :: CachedMethodTable, limit :: Int = -1)
- function findall(@nospecialize(sig::Type), table::OverlayMethodTable; limit::Int=-1)
+ function findall(sig :: Type, table :: OverlayMethodTable, limit :: Int = -1)
- function findall(A)
+ function findall(A)
- function findall(A::AbstractArray{Bool})
+ function findall(A :: AbstractArray{Bool})
- function findall(B::BitArray)
+ function findall(B :: BitArray)
- function findall(pred::Fix2{typeof(in),<:Union{Array{<:Real},Real}}, x::Array{<:Real})
+ function findall(pred :: Fix2{typeof(in), ??? <: Union{Array{??? <: Real}, Real}}, x :: Array{??? <: Real})
- function findall(pred::Fix2{typeof(in),<:Union{Memory{<:Real},Real}}, x::Memory{<:Real})
+ function findall(pred :: Fix2{typeof(in), ??? <: Union{Memory{??? <: Real}, Real}}, x :: Memory{??? <: Real})
- function findall(testf::Function, A)
+ function findall(testf :: Function, A)
- function finddoc(λ, def::Expr)
+ function finddoc(λ, def :: Expr)
- function findfirst(p::Union{Fix2{typeof(isequal),T},Fix2{typeof(==),T}}, r::StepRange{T,S}) where {T,S}
+ function findfirst(p :: Union{Fix2{typeof(isequal), T}, Fix2{typeof(==), T}}, r :: StepRange{T, S}) where T, S
- function findfirst(testf::Function, A)
+ function findfirst(testf :: Function, A)
- function findlast(testf::Function, A)
+ function findlast(testf :: Function, A)
- function findmax(a::BitArray)
+ function findmax(a :: BitArray)
- function findmeta(ex::Expr)
+ function findmeta(ex :: Expr)
- function findmeta_block(exargs, argsmatch=args->true)
+ function findmeta_block(exargs, argsmatch = args->true)
- function findmetaarg(metaargs, sym)
+ function findmetaarg(metaargs, sym)
- function findmin(a::BitArray)
+ function findmin(a :: BitArray)
- function findminmax!(f, op, Rval, Rind, A::AbstractArray{T,N}) where {T,N}
+ function findminmax!(f, op, Rval, Rind, A :: AbstractArray{T, N}) where T, N
- function findnext(B::BitArray, start::Integer)
+ function findnext(B :: BitArray, start :: Integer)
- function findnext(testf::Function, A, start)
+ function findnext(testf :: Function, A, start)
- function findnext(testf::Function, s::AbstractString, i::Integer)
+ function findnext(testf :: Function, s :: AbstractString, i :: Integer)
- function findnextnot(B::BitArray, start::Int)
+ function findnextnot(B :: BitArray, start :: Int)
- function findprev(B::BitArray, start::Integer)
+ function findprev(B :: BitArray, start :: Integer)
- function findprev(testf::Function, A, start)
+ function findprev(testf :: Function, A, start)
- function findprev(testf::Function, s::AbstractString, i::Integer)
+ function findprev(testf :: Function, s :: AbstractString, i :: Integer)
- function findprevnot(B::BitArray, start::Int)
+ function findprevnot(B :: BitArray, start :: Int)
- function findsup(@nospecialize(sig::Type), table::OverlayMethodTable)
+ function findsup(sig :: Type, table :: OverlayMethodTable)
- function finish!(interp::AbstractInterpreter, caller::InferenceState)
+ function finish!(interp :: AbstractInterpreter, caller :: InferenceState)
- function finish(compact::IncrementalCompact)
+ function finish(compact :: IncrementalCompact)
- function finish(me::InferenceState, interp::AbstractInterpreter)
+ function finish(me :: InferenceState, interp :: AbstractInterpreter)
- function finish(rb::GitRebase, sig::GitSignature)
+ function finish(rb :: GitRebase, sig :: GitSignature)
- function finish(ts::CustomTestSet)
+ function finish(ts :: CustomTestSet)
- function finish(ts::DefaultTestSet; print_results::Bool=TESTSET_PRINT_ENABLE[])
+ function finish(ts :: DefaultTestSet, print_results :: Bool = TESTSET_PRINT_ENABLE[])
- function finish_cfg_inline!(state::CFGInliningState)
+ function finish_cfg_inline!(state :: CFGInliningState)
- function finish_show_ir(io::IO, cfg::CFG, config::IRShowConfig)
+ function finish_show_ir(io :: IO, cfg :: CFG, config :: IRShowConfig)
- function first(itr)
+ function first(itr)
- function first(s::BitSet)
+ function first(s :: BitSet)
- function first(v::AbstractVector, n::Integer)
+ function first(v :: AbstractVector, n :: Integer)
- function first_insert_for_bb(code::Vector{Any}, cfg::CFG, block::Int)
+ function first_insert_for_bb(code :: Vector{Any}, cfg :: CFG, block :: Int)
- function first_step_last_ascending(r::StepRange)
+ function first_step_last_ascending(r :: StepRange)
- function firstcaller(bt::Vector, funcsyms)
+ function firstcaller(bt :: Vector, funcsyms)
- function firstdayofquarter(dt::Date)
+ function firstdayofquarter(dt :: Date)
- function fixemup!(@specialize(slot_filter), @specialize(rename_slot), ir::IRCode, ci::CodeInfo, idx::Int, @nospecialize(stmt))
+ function fixemup!(slot_filter, rename_slot, ir :: IRCode, ci :: CodeInfo, idx :: Int, stmt)
- function fixup_keymaps!(dict::Dict{Char,Any}, level, s, subkeymap)
+ function fixup_keymaps!(dict :: Dict{Char, Any}, level, s, subkeymap)
- function fixup_node(compact::IncrementalCompact, @nospecialize(stmt), reify_new_nodes::Bool)
+ function fixup_node(compact :: IncrementalCompact, stmt, reify_new_nodes :: Bool)
- function fixup_phinode_values!(compact::IncrementalCompact, old_values::Vector{Any}, reify_new_nodes::Bool)
+ function fixup_phinode_values!(compact :: IncrementalCompact, old_values :: Vector{Any}, reify_new_nodes :: Bool)
- function fixup_slot!(ir::IRCode, ci::CodeInfo, idx::Int, slot::Int, @nospecialize(ssa), @nospecialize(def_ssa))
+ function fixup_slot!(ir :: IRCode, ci :: CodeInfo, idx :: Int, slot :: Int, ssa, def_ssa)
- function fixup_stdlib_path(path::String)
+ function fixup_stdlib_path(path :: String)
- function fixup_uses!(ir::IRCode, ci::CodeInfo, code::Vector{Any}, uses::Vector{Int}, slot::Int, @nospecialize(ssa))
+ function fixup_uses!(ir :: IRCode, ci :: CodeInfo, code :: Vector{Any}, uses :: Vector{Int}, slot :: Int, ssa)
- function fl_incomplete_tag(msg::AbstractString)
+ function fl_incomplete_tag(msg :: AbstractString)
- function fl_parse(text::AbstractString, filename::AbstractString, lineno, offset, options)
+ function fl_parse(text :: AbstractString, filename :: AbstractString, lineno, offset, options)
- function flags_for_effects(effects::Effects)
+ function flags_for_effects(effects :: Effects)
- function flat(io::IO, data::Vector{Alloc}, cols::Int, fmt::ProfileFormat)
+ function flat(io :: IO, data :: Vector{Alloc}, cols :: Int, fmt :: ProfileFormat)
- function flatten(bc::Broadcasted)
+ function flatten(bc :: Broadcasted)
- function flatten(data::Vector, lidict::LineInfoDict)
+ function flatten(data :: Vector, lidict :: LineInfoDict)
- function flatten(xs)
+ function flatten(xs)
- function flatten_length(f, T::Type{<:NTuple{N,Any}}) where {N}
+ function flatten_length(f, T :: Type{??? <: NTuple{N, Any}}) where N
- function flatten_times(t::Core.Compiler.Timings.Timing)
+ function flatten_times(t :: Core.Compiler.Timings.Timing)
- function fld(x::T, y::T) where T<:Integer
+ function fld(x :: T, y :: T) where T <: Integer
- function fld1(x::T, y::T) where T<:Integer
+ function fld1(x :: T, y :: T) where T <: Integer
- function float(A::AbstractArray{T}) where T
+ function float(A :: AbstractArray{T}) where T
- function float(A::AbstractArray{Union{T, Missing}}) where {T}
+ function float(A :: AbstractArray{Union{T, Missing}}) where T
- function float(r::LinRange)
+ function float(r :: LinRange)
- function float_samples(::Type{T}, exponents, n::Int) where {T<:AbstractFloat}
+ function float_samples(??? :: Type{T}, exponents, n :: Int) where T <: AbstractFloat
- function floatrange(::Type{T}, start_n::Integer, step_n::Integer, len::Integer, den::Integer) where T
+ function floatrange(??? :: Type{T}, start_n :: Integer, step_n :: Integer, len :: Integer, den :: Integer) where T
- function floorceil(dt::TimeType, p::Period)
+ function floorceil(dt :: TimeType, p :: Period)
- function floorceil(x::ConvertiblePeriod, precision::ConvertiblePeriod)
+ function floorceil(x :: ConvertiblePeriod, precision :: ConvertiblePeriod)
- function flush(s::BufferStream)
+ function flush(s :: BufferStream)
- function flush(s::IOStream)
+ function flush(s :: IOStream)
- function flush(s::LibuvStream)
+ function flush(s :: LibuvStream)
- function fma(a::Float16, b::Float16, c::Float16)
+ function fma(a :: Float16, b :: Float16, c :: Float16)
- function fma(x::BigFloat, y::BigFloat, z::BigFloat)
+ function fma(x :: BigFloat, y :: BigFloat, z :: BigFloat)
- function fma_emulated(a::Float32, b::Float32, c::Float32)::Float32
+ function fma_emulated(a :: Float32, b :: Float32, c :: Float32)
- function fma_emulated(a::Float64, b::Float64,c::Float64)
+ function fma_emulated(a :: Float64, b :: Float64, c :: Float64)
- function fmemory(nel)
+ function fmemory(nel)
- function fmt(buf, pos, arg::Ref{<:Integer}, ::Spec{PositionCounter})
+ function fmt(buf, pos, arg :: Ref{??? <: Integer}, ??? :: Spec{PositionCounter})
- function fmtfallback(buf, pos, arg, spec::Spec{T}) where {T}
+ function fmtfallback(buf, pos, arg, spec :: Spec{T}) where T
- function fold_alloc(a)
+ function fold_alloc(a)
- function fold_ifelse!(compact::IncrementalCompact, idx::Int, stmt::Expr)
+ function fold_ifelse!(compact :: IncrementalCompact, idx :: Int, stmt :: Expr)
- function foldl_impl(op::OP, nt, itr) where {OP}
+ function foldl_impl(op :: OP, nt, itr) where OP
- function follow_map(map::Vector{Int}, idx::Int)
+ function follow_map(map :: Vector{Int}, idx :: Int)
- function foo(a::A, b::B) where {A,B}
+ function foo(a :: A, b :: B) where A, B
- function foo(a::T) where {T}
+ function foo(a :: T) where T
- function foo(b, x)
+ function foo(b, x)
- function foo(i)
+ function foo(i)
- function foo(n)
+ function foo(n)
- function foo(x)
+ function foo(x)
- function foo1784()
+ function foo1784
- function foo21568()
+ function foo21568
- function foo22770()
+ function foo22770
- function foo23996(xs...)
+ function foo23996(xs...)
- function foo25261()
+ function foo25261
- function foo27594()
+ function foo27594
- function foo28077()
+ function foo28077
- function foo28208(a::Bool, b::Bool)
+ function foo28208(a :: Bool, b :: Bool)
- function foo28224()
+ function foo28224
- function foo28326(a)
+ function foo28326(a)
- function foo30594(cnt::Int, dx::Int)
+ function foo30594(cnt :: Int, dx :: Int)
- function foo30783(b)
+ function foo30783(b)
- function foo31018!(a, b)
+ function foo31018!(a, b)
- function foo31357(b::Bool)
+ function foo31357(b :: Bool)
- function foo37690()
+ function foo37690
- function foo4075(f::Foo4075, s::Symbol)
+ function foo4075(f :: Foo4075, s :: Symbol)
- function foo42190(r::Union{Nothing,Int}, n::Int)
+ function foo42190(r :: Union{Nothing, Int}, n :: Int)
- function foo9222()
+ function foo9222
- function foo_apply_apply_type_svec()
+ function foo_apply_apply_type_svec
- function foo_cfg_empty(b)
+ function foo_cfg_empty(b)
- function foo_defined_last_iter(n::Int)
+ function foo_defined_last_iter(n :: Int)
- function foo_error(c, n)
+ function foo_error(c, n)
- function foo_tail_const_prop()
+ function foo_tail_const_prop
- function fooo()
+ function fooo
- function fooo_2()
+ function fooo_2
- function fooo_3()
+ function fooo_3
- function footnote(stream::IO, block::MD)
+ function footnote(stream :: IO, block :: MD)
- function footnote_link(stream::IO, md::MD)
+ function footnote_link(stream :: IO, md :: MD)
- function force_const_prop(interp::AbstractInterpreter, @nospecialize(f), method::Method)
+ function force_const_prop(interp :: AbstractInterpreter, f, method :: Method)
- function foreach_anyssa(@specialize(f), @nospecialize(stmt))
+ function foreach_anyssa(f, stmt)
- function foreachssa(@specialize(f), @nospecialize(stmt))
+ function foreachssa(f, stmt)
- function foreigncall_effects(@specialize(abstract_eval), e::Expr)
+ function foreigncall_effects(abstract_eval, e :: Expr)
- function forkRand(rng::Union{TaskLocalRNG, Xoshiro}, ::Val{N}) where N
+ function forkRand(rng :: Union{TaskLocalRNG, Xoshiro}, ??? :: Val{N}) where N
- function form_8x8_chunk(Bc::Vector{UInt64}, i1::Int, i2::Int, m::Int, cgap::Int, cinc::Int, nc::Int, msk8::UInt64)
+ function form_8x8_chunk(Bc :: Vector{UInt64}, i1 :: Int, i2 :: Int, m :: Int, cgap :: Int, cinc :: Int, nc :: Int, msk8 :: UInt64)
- function form_new_preserves(origex::Expr, intermediates::Vector{Int}, new_preserves::Vector{Any})
+ function form_new_preserves(origex :: Expr, intermediates :: Vector{Int}, new_preserves :: Vector{Any})
- function format(dt::TimeType, f::AbstractString; locale::Locale=ENGLISH)
+ function format(dt :: TimeType, f :: AbstractString, locale :: Locale = ENGLISH)
- function format(dt::TimeType, fmt::DateFormat, bufsize=12)
+ function format(dt :: TimeType, fmt :: DateFormat, bufsize = 12)
- function format(f::Format, args...)
+ function format(f :: Format, args...)
- function format(io, d::DatePart{'p'}, dt, locale)
+ function format(io, d :: DatePart{'p'}, dt, locale)
- function format(io, d::DatePart{'s'}, dt)
+ function format(io, d :: DatePart{'s'}, dt)
- function format(io::IO, f::Format, args...)
+ function format(io :: IO, f :: Format, args...)
- function format(result::GitDescribeResult; options::DescribeFormatOptions=DescribeFormatOptions())
+ function format(result :: GitDescribeResult, options :: DescribeFormatOptions = DescribeFormatOptions())
- function format_bytes(bytes; binary=true)
+ function format_bytes(bytes, binary = true)
- function format_error_message_for_err_type(error::ParserError)
+ function format_error_message_for_err_type(error :: ParserError)
- function format_filename(s)
+ function format_filename(s)
- function format_output(output)
+ function format_output(output)
- function formatdoc(d::DocStr)
+ function formatdoc(d :: DocStr)
- function forouter()
+ function forouter
- function foundfunc(bt, funcname)
+ function foundfunc(bt, funcname)
- function frame_module(sv::AbsIntState)
+ function frame_module(sv :: AbsIntState)
- function frameworkDir()
+ function frameworkDir
- function free(buf_ref::Base.Ref{Buffer})
+ function free(buf_ref :: Base.Ref{Buffer})
- function free(sa_ref::Base.Ref{StrArrayStruct})
+ function free(sa_ref :: Base.Ref{StrArrayStruct})
- function frexp(x::BigFloat)
+ function frexp(x :: BigFloat)
- function frexp(x::T) where T<:IEEEFloat
+ function frexp(x :: T) where T <: IEEEFloat
- function from(frame::StackFrame, m::Module)
+ function from(frame :: StackFrame, m :: Module)
- function from_fenv(r::Integer)
+ function from_fenv(r :: Integer)
- function from_intermustalias(rt::InterMustAlias, arginfo::ArgInfo)
+ function from_intermustalias(rt :: InterMustAlias, arginfo :: ArgInfo)
- function from_interprocedural(argescape::ArgEscapeInfo, pc::Int)
+ function from_interprocedural(argescape :: ArgEscapeInfo, pc :: Int)
- function fromfraction(f::Int128)
+ function fromfraction(f :: Int128)
- function front(t::Tuple)
+ function front(t :: Tuple)
- function full!(A::LowerTriangular)
+ function full!(A :: LowerTriangular)
- function full!(A::UnitLowerTriangular)
+ function full!(A :: UnitLowerTriangular)
- function full!(A::UnitUpperTriangular)
+ function full!(A :: UnitUpperTriangular)
- function full!(A::UpperTriangular)
+ function full!(A :: UpperTriangular)
- function full_va_len(p::Core.SimpleVector)
+ function full_va_len(p :: Core.SimpleVector)
- function fullname(m::Module)
+ function fullname(m :: Module)
- function fullname(ref::GitReference)
+ function fullname(ref :: GitReference)
- function fully_eliminated(code::Vector{Any}; retval=(@__FILE__), kwargs...)
+ function fully_eliminated(code :: Vector{Any}, retval = (@__FILE__), kwargs...)
- function fun1_47326(args...)
+ function fun1_47326(args...)
- function fun2_47326(args...)
+ function fun2_47326(args...)
- function func1_6404(v1::Integer)
+ function func1_6404(v1 :: Integer)
- function func_nospecialized(@nospecialize a)
+ function func_nospecialized(a)
- function functionloc(@nospecialize(f))
+ function functionloc(f)
- function functionloc(m::Method)
+ function functionloc(m :: Method)
- function futime(f::File, atime::Float64, mtime::Float64)
+ function futime(f :: File, atime :: Float64, mtime :: Float64)
- function fuzzyscore(needle::AbstractString, haystack::AbstractString)
+ function fuzzyscore(needle :: AbstractString, haystack :: AbstractString)
- function fuzzysort(search::String, candidates::Vector{String})
+ function fuzzysort(search :: String, candidates :: Vector{String})
- function fzero(bc::Broadcast.Broadcasted)
+ function fzero(bc :: Broadcast.Broadcasted)
- function g((x,y))
+ function g((x,y))
- function g()
+ function g
- function g(::Union{map(t->Array{t,N},types27268)...} where N)
+ function g(??? :: Union{map, (, t, -, >, Array{t, N}, types27268, ), ...} where N)
- function g(a)
+ function g(a)
- function g(i)
+ function g(i)
- function g(y::T) where T
+ function g(y :: T) where T
- function g1(a=(1,2)..., b...=3)
+ function g1(a = (1,2)..., b..., ??? = 3)
- function g15276()
+ function g15276
- function g15714(array_var15714)
+ function g15714(array_var15714)
- function g17449(r)
+ function g17449(r)
- function g19348(x)
+ function g19348(x)
- function g2(a=(1,2)..., b=3, c=4)
+ function g2(a = (1,2)..., b = 3, c = 4)
- function g2(start, two, N)
+ function g2(start, two, N)
- function g20343()
+ function g20343
- function g21147(f::Tuple{A}, k = 2) where {B,A<:Tuple{B}}
+ function g21147(f :: Tuple{A}, k = 2) where B, A <: Tuple{B}
- function g22421_1(x, y, b)
+ function g22421_1(x, y, b)
- function g22421_2(x, y, b)
+ function g22421_2(x, y, b)
- function g25579(g)
+ function g25579(g)
- function g26301()
+ function g26301
- function g27079(X)
+ function g27079(X)
- function g27268()
+ function g27268
- function g27316()
+ function g27316
- function g28399(n)
+ function g28399(n)
- function g28955(x, y)
+ function g28955(x, y)
- function g3(a=(1,2)..., b=3, c...=4)
+ function g3(a = (1,2)..., b = 3, c..., ??? = 4)
- function g3(start, three, N)
+ function g3(start, three, N)
- function g3182(t::DataType)
+ function g3182(t :: DataType)
- function g32074(i::Float32; args...)
+ function g32074(i :: Float32, args...)
- function g32074(i::Int32; args...)
+ function g32074(i :: Int32, args...)
- function g33768()
+ function g33768
- function g37690()
+ function g37690
- function g44921(a)
+ function g44921(a)
- function g9770(x,y)
+ function g9770(x, y)
- function g_dict_hash_alloc()
+ function g_dict_hash_alloc
- function gc_alloc_count(diff::GC_Diff)
+ function gc_alloc_count(diff :: GC_Diff)
- function gc_bytes()
+ function gc_bytes
- function gc_counter()
+ function gc_counter
- function gc_counter_full()
+ function gc_counter_full
- function gc_counter_inc()
+ function gc_counter_inc
- function gc_live_bytes()
+ function gc_live_bytes
- function gcd(a::T, b::T) where T<:BitInteger
+ function gcd(a :: T, b :: T) where T <: BitInteger
- function gcd(a::T, b::T) where T<:Integer
+ function gcd(a :: T, b :: T) where T <: Integer
- function gcd(abc::AbstractArray{<:Integer})
+ function gcd(abc :: AbstractArray{??? <: Integer})
- function gcdext!(x::BigInt, y::BigInt, z::BigInt, a::BigInt, b::BigInt)
+ function gcdext!(x :: BigInt, y :: BigInt, z :: BigInt, a :: BigInt, b :: BigInt)
- function gcdx(a::BigInt, b::BigInt)
+ function gcdx(a :: BigInt, b :: BigInt)
- function gcdx(x::Rational, y::Rational)
+ function gcdx(x :: Rational, y :: Rational)
- function gen(d)
+ function gen(d)
- function gen_bitarray(::HasLength, itr)
+ function gen_bitarray(??? :: HasLength, itr)
- function gen_bitarray(::HasShape, itr)
+ function gen_bitarray(??? :: HasShape, itr)
- function gen_bitarray(::HasShape, itr::Generator)
+ function gen_bitarray(??? :: HasShape, itr :: Generator)
- function gen_bitarray_from_itr(itr)
+ function gen_bitarray_from_itr(itr)
- function gen_call_with_extracted_types(__module__, fcn, ex0, kws=Expr[])
+ function gen_call_with_extracted_types(__module__, fcn, ex0, kws = Expr[])
- function gen_call_with_extracted_types_and_kwargs(__module__, fcn, ex0)
+ function gen_call_with_extracted_types_and_kwargs(__module__, fcn, ex0)
- function gen_ccall_echo(x, T, U, ret=nothing)
+ function gen_ccall_echo(x, T, U, ret = nothing)
- function gen_ex(; cached_cred=nothing, allow_prompt=true)
+ function gen_ex(cached_cred = nothing, allow_prompt = true)
- function gen_ex(; username="git")
+ function gen_ex(username = "git")
- function gen_ex(cred)
+ function gen_ex(cred)
- function gen_ex(cred; allow_prompt=true)
+ function gen_ex(cred, allow_prompt = true)
- function gen_ex(cred; allow_prompt=true, allow_ssh_agent=false)
+ function gen_ex(cred, allow_prompt = true, allow_ssh_agent = false)
- function gen_ex(cred; username="git")
+ function gen_ex(cred, username = "git")
- function gen_f(a::T) where T
+ function gen_f(a :: T) where T
- function gen_nodes(qty::Integer) :: AbstractNode
+ function gen_nodes(qty :: Integer)
- function gen_rand(r::MersenneTwister)
+ function gen_rand(r :: MersenneTwister)
- function generate_markdown(basename)
+ function generate_markdown(basename)
- function generateinversetables()
+ function generateinversetables
- function generating_output(incremental::Union{Bool,Nothing}=nothing)
+ function generating_output(incremental :: Union{Bool, Nothing} = nothing)
- function generator49715(world, source, self, f, tt)
+ function generator49715(world, source, self, f, tt)
- function generic_map_tests(mapf, inplace_mapf=nothing)
+ function generic_map_tests(mapf, inplace_mapf = nothing)
- function generic_matmatmul!(C::AbstractVecOrMat, tA, tB, A::AbstractVecOrMat, B::AbstractVecOrMat, _add::MulAddMul)
+ function generic_matmatmul!(C :: AbstractVecOrMat, tA, tB, A :: AbstractVecOrMat, B :: AbstractVecOrMat, _add :: MulAddMul)
- function generic_matmatmul(tA, tB, A::AbstractVecOrMat{T}, B::AbstractMatrix{S}) where {T,S}
+ function generic_matmatmul(tA, tB, A :: AbstractVecOrMat{T}, B :: AbstractMatrix{S}) where T, S
- function generic_mattridiv!(C::AbstractMatrix, uploc, isunitc, ::Function, A::AbstractMatrix, xB::AdjOrTrans)
+ function generic_mattridiv!(C :: AbstractMatrix, uploc, isunitc, ??? :: Function, A :: AbstractMatrix, xB :: AdjOrTrans)
- function generic_mattridiv!(C::AbstractMatrix, uploc, isunitc, tfun::Function, A::AbstractMatrix, B::AbstractMatrix)
+ function generic_mattridiv!(C :: AbstractMatrix, uploc, isunitc, tfun :: Function, A :: AbstractMatrix, B :: AbstractMatrix)
- function generic_mattrimul!(C::AbstractMatrix, uploc, isunitc, ::Function, A::AbstractMatrix, xB::AdjOrTrans)
+ function generic_mattrimul!(C :: AbstractMatrix, uploc, isunitc, ??? :: Function, A :: AbstractMatrix, xB :: AdjOrTrans)
- function generic_mattrimul!(C::AbstractMatrix, uploc, isunitc, tfun::Function, A::AbstractMatrix, B::AbstractMatrix)
+ function generic_mattrimul!(C :: AbstractMatrix, uploc, isunitc, tfun :: Function, A :: AbstractMatrix, B :: AbstractMatrix)
- function generic_mul!(C::AbstractArray, X::AbstractArray, s::Number, _add::MulAddMul)
+ function generic_mul!(C :: AbstractArray, X :: AbstractArray, s :: Number, _add :: MulAddMul)
- function generic_mul!(C::AbstractArray, s::Number, X::AbstractArray, _add::MulAddMul)
+ function generic_mul!(C :: AbstractArray, s :: Number, X :: AbstractArray, _add :: MulAddMul)
- function generic_norm2(x)
+ function generic_norm2(x)
- function generic_normp(x, p)
+ function generic_normp(x, p)
- function generic_trimatdiv!(C::AbstractVecOrMat, uploc, isunitc, ::Function, xA::AdjOrTrans, B::AbstractVecOrMat)
+ function generic_trimatdiv!(C :: AbstractVecOrMat, uploc, isunitc, ??? :: Function, xA :: AdjOrTrans, B :: AbstractVecOrMat)
- function generic_trimatdiv!(C::AbstractVecOrMat, uploc, isunitc, tfun::Function, A::AbstractMatrix, B::AbstractVecOrMat)
+ function generic_trimatdiv!(C :: AbstractVecOrMat, uploc, isunitc, tfun :: Function, A :: AbstractMatrix, B :: AbstractVecOrMat)
- function generic_trimatmul!(C::AbstractVecOrMat, uploc, isunitc, ::Function, xA::AdjOrTrans, B::AbstractVecOrMat)
+ function generic_trimatmul!(C :: AbstractVecOrMat, uploc, isunitc, ??? :: Function, xA :: AdjOrTrans, B :: AbstractVecOrMat)
- function generic_trimatmul!(C::AbstractVecOrMat, uploc, isunitc, tfun::Function, A::AbstractMatrix, B::AbstractVecOrMat)
+ function generic_trimatmul!(C :: AbstractVecOrMat, uploc, isunitc, tfun :: Function, A :: AbstractMatrix, B :: AbstractVecOrMat)
- function genfinalizer(val)
+ function genfinalizer(val)
- function genmsg(level, message, _module, filepath, line; kws...)
+ function genmsg(level, message, _module, filepath, line, kws...)
- function genmsg_err(level, message, _module, filepath, line; kws...)
+ function genmsg_err(level, message, _module, filepath, line, kws...)
- function genr()
+ function genr
- function genxs()
+ function genxs
- function geqp3!(A::AbstractMatrix{<:BlasFloat})
+ function geqp3!(A :: AbstractMatrix{??? <: BlasFloat})
- function geqp3!(A::AbstractMatrix{<:BlasFloat}, jpvt::AbstractVector{BlasInt})
+ function geqp3!(A :: AbstractMatrix{??? <: BlasFloat}, jpvt :: AbstractVector{BlasInt})
- function get!(X::AbstractArray{T}, A::AbstractArray, I::RangeVecIntList, default::T) where T
+ function get!(X :: AbstractArray{T}, A :: AbstractArray, I :: RangeVecIntList, default :: T) where T
- function get!(X::AbstractArray{T}, A::AbstractArray, I::Union{AbstractRange,AbstractVector{Int}}, default::T) where T
+ function get!(X :: AbstractArray{T}, A :: AbstractArray, I :: Union{AbstractRange, AbstractVector{Int}}, default :: T) where T
- function get!(X::AbstractVector{T}, A::AbstractVector, I::Union{AbstractRange,AbstractVector{Int}}, default::T) where T
+ function get!(X :: AbstractVector{T}, A :: AbstractVector, I :: Union{AbstractRange, AbstractVector{Int}}, default :: T) where T
- function get!(d::IdDict{K,V}, @nospecialize(key), @nospecialize(default)) where {K, V}
+ function get!(d :: IdDict{K, V}, key, default) where K, V
- function get!(default::Callable, ::EnvDict, k::AbstractString)
+ function get!(default :: Callable, ??? :: EnvDict, k :: AbstractString)
- function get!(default::Callable, d::IdDict{K,V}, @nospecialize(key)) where {K, V}
+ function get!(default :: Callable, d :: IdDict{K, V}, key) where K, V
- function get!(default::Callable, h::Dict{K,V}, key0) where V where K
+ function get!(default :: Callable, h :: Dict{K, V}, key0) where V where K
- function get!(default::Callable, h::Dict{K,V}, key::K) where V where K
+ function get!(default :: Callable, h :: Dict{K, V}, key :: K) where V where K
- function get!(default::Callable, t::AbstractDict{K,V}, key) where K where V
+ function get!(default :: Callable, t :: AbstractDict{K, V}, key) where K where V
- function get!(default::Callable, wkh::WeakKeyDict{K}, key) where {K}
+ function get!(default :: Callable, wkh :: WeakKeyDict{K}, key) where K
- function get!(lazyagdomtree::LazyAugmentedDomtree)
+ function get!(lazyagdomtree :: LazyAugmentedDomtree)
- function get!(wkh::WeakKeyDict{K}, key, default) where {K}
+ function get!(wkh :: WeakKeyDict{K}, key, default) where K
- function get!(x::LazyGenericDomtree{IsPostDom}) where {IsPostDom}
+ function get!(x :: LazyGenericDomtree{IsPostDom}) where IsPostDom
- function get(::Type{<:AbstractString}, c::GitConfig, name::AbstractString)
+ function get(??? :: Type{??? <: AbstractString}, c :: GitConfig, name :: AbstractString)
- function get(::Type{Bool}, c::GitConfig, name::AbstractString)
+ function get(??? :: Type{Bool}, c :: GitConfig, name :: AbstractString)
- function get(::Type{GitRemote}, repo::GitRepo, rmt_name::AbstractString)
+ function get(??? :: Type{GitRemote}, repo :: GitRepo, rmt_name :: AbstractString)
- function get(::Type{Int32}, c::GitConfig, name::AbstractString)
+ function get(??? :: Type{Int32}, c :: GitConfig, name :: AbstractString)
- function get(::Type{Int64}, c::GitConfig, name::AbstractString)
+ function get(??? :: Type{Int64}, c :: GitConfig, name :: AbstractString)
- function get(c::GitConfig, name::AbstractString, default::T) where T
+ function get(c :: GitConfig, name :: AbstractString, default :: T) where T
- function get(d::IdDict{K,V}, @nospecialize(key), @nospecialize(default)) where {K, V}
+ function get(d :: IdDict{K, V}, key, default) where K, V
- function get(default::Callable, d::IdDict{K,V}, @nospecialize(key)) where {K, V}
+ function get(default :: Callable, d :: IdDict{K, V}, key) where K, V
- function get(default::Callable, dict::ImmutableDict, key)
+ function get(default :: Callable, dict :: ImmutableDict, key)
- function get(default::Callable, dict::PersistentDict{K,V}, key::K) where {K,V}
+ function get(default :: Callable, dict :: PersistentDict{K, V}, key :: K) where K, V
- function get(default::Callable, h::Dict{K,V}, key) where V where K
+ function get(default :: Callable, h :: Dict{K, V}, key) where V where K
- function get(default::Callable, wkh::WeakKeyDict{K}, key) where {K}
+ function get(default :: Callable, wkh :: WeakKeyDict{K}, key) where K
- function get(dict::ImmutableDict, key, default)
+ function get(dict :: ImmutableDict, key, default)
- function get(dict::PersistentDict{K,V}, key::K, default) where {K,V}
+ function get(dict :: PersistentDict{K, V}, key :: K, default) where K, V
- function get(h::Dict{K,V}, key, default) where V where K
+ function get(h :: Dict{K, V}, key, default) where V where K
- function get(s::AbstractString, i::Integer, default)
+ function get(s :: AbstractString, i :: Integer, default)
- function get(val::ScopedValue{T}) where {T}
+ function get(val :: ScopedValue{T}) where T
- function get(wkh::WeakKeyDict{K}, key, default) where {K}
+ function get(wkh :: WeakKeyDict{K}, key, default) where K
- function get(wvc::WorldView{InternalCodeCache}, mi::MethodInstance, default)
+ function get(wvc :: WorldView{InternalCodeCache}, mi :: MethodInstance, default)
- function getData(dic)
+ function getData(dic)
- function getEntry(keymap::Dict{Char,Any},key::Union{String,Char})
+ function getEntry(keymap :: Dict{Char, Any}, key :: Union{String, Char})
- function get_A18434()
+ function get_A18434
- function get_alignment(ts::DefaultTestSet, depth::Int)
+ function get_alignment(ts :: DefaultTestSet, depth :: Int)
- function get_atomic_order(order::Symbol, loading::Bool, storing::Bool)
+ function get_atomic_order(order :: Symbol, loading :: Bool, storing :: Bool)
- function get_aux_root(n :: Int)
+ function get_aux_root(n :: Int)
- function get_bool_env(name::String, default::Bool)
+ function get_bool_env(name :: String, default :: Bool)
- function get_bt_frames(functionname, bt)
+ function get_bt_frames(functionname, bt)
- function get_code_cache()
+ function get_code_cache
- function get_compare_strategy(p::Platform, key::String, default = compare_default)
+ function get_compare_strategy(p :: Platform, key :: String, default = compare_default)
- function get_compileable_sig(method::Method, @nospecialize(atype), sparams::SimpleVector)
+ function get_compileable_sig(method :: Method, atype, sparams :: SimpleVector)
- function get_data()
+ function get_data
- function get_default_console_mode()
+ function get_default_console_mode
- function get_deps(raw_manifest::Dict)
+ function get_deps(raw_manifest :: Dict)
- function get_elem(x, i::Int, v::Val, ::Val{:descending})
+ function get_elem(x, i :: Int, v :: Val, ??? :: Val{:, descending})
- function get_elem(x::RawBigInt, i::Int, ::Val{:bits}, v::Val{:ascending})
+ function get_elem(x :: RawBigInt, i :: Int, ??? :: Val{:, bits}, v :: Val{:, ascending})
- function get_elem(x::RawBigInt{T}, i::Int, ::Val{:words}, ::Val{:ascending}) where {T}
+ function get_elem(x :: RawBigInt{T}, i :: Int, ??? :: Val{:, words}, ??? :: Val{:, ascending}) where T
- function get_elem(x::Unsigned, i::Int, ::Val{:bits}, ::Val{:ascending})
+ function get_elem(x :: Unsigned, i :: Int, ??? :: Val{:, bits}, ??? :: Val{:, ascending})
- function get_expr_list(ex::Core.CodeInfo)
+ function get_expr_list(ex :: Core.CodeInfo)
- function get_expr_list(ex::Expr)
+ function get_expr_list(ex :: Expr)
- function get_extension(parentid::PkgId, ext::Symbol)
+ function get_extension(parentid :: PkgId, ext :: Symbol)
- function get_global_dir()
+ function get_global_dir
- function get_have_color()
+ function get_have_color
- function get_have_truecolor()
+ function get_have_truecolor
- function get_help_io(input)
+ function get_help_io(input)
- function get_inlinetable(mi::MethodInstance)
+ function get_inlinetable(mi :: MethodInstance)
- function get_last_word(buf::IOBuffer)
+ function get_last_word(buf :: IOBuffer)
- function get_lines_in_region(s::BufferLike)
+ function get_lines_in_region(s :: BufferLike)
- function get_linfo(@nospecialize(f), @nospecialize(t))
+ function get_linfo(f, t)
- function get_llvm(@nospecialize(f), @nospecialize(t), raw=true, dump_module=false, optimize=true)
+ function get_llvm(f, t, raw = true, dump_module = false, optimize = true)
- function get_local_match_context()
+ function get_local_match_context
- function get_max_methods(interp::AbstractInterpreter, @nospecialize(f))
+ function get_max_methods(interp :: AbstractInterpreter, f)
- function get_max_methods(interp::AbstractInterpreter, @nospecialize(f), sv::AbsIntState)
+ function get_max_methods(interp :: AbstractInterpreter, f, sv :: AbsIntState)
- function get_max_methods(interp::AbstractInterpreter, sv::AbsIntState)
+ function get_max_methods(interp :: AbstractInterpreter, sv :: AbsIntState)
- function get_max_methods_for_func(@nospecialize(f))
+ function get_max_methods_for_func(f)
- function get_max_methods_for_module(mod::Module)
+ function get_max_methods_for_module(mod :: Module)
- function get_method_for_type(func, @nospecialize(T))
+ function get_method_for_type(func, T)
- function get_method_instance_roots(mi::Union{Method, MethodInstance})
+ function get_method_instance_roots(mi :: Union{Method, MethodInstance})
- function get_methodtable(m::Method)
+ function get_methodtable(m :: Method)
- function get_name_color(x::EscapeInfo, symbol::Bool = false)
+ function get_name_color(x :: EscapeInfo, symbol :: Bool = false)
- function get_next()
+ function get_next
- function get_nospecializeinfer_sig(method::Method, @nospecialize(atype), sparams::SimpleVector)
+ function get_nospecializeinfer_sig(method :: Method, atype, sparams :: SimpleVector)
- function get_nthreads(options ; cpus = nothing)
+ function get_nthreads(options, cpus = nothing)
- function get_order(by = identity, func = isless, rev = false)
+ function get_order(by = identity, func = isless, rev = false)
- function get_pkgversion_from_path(path)
+ function get_pkgversion_from_path(path)
- function get_preferences(uuid::Union{UUID,Nothing} = nothing)
+ function get_preferences(uuid :: Union{UUID, Nothing} = nothing)
- function get_preferences_hash(uuid::Union{UUID, Nothing}, prefs_list::Vector{String})
+ function get_preferences_hash(uuid :: Union{UUID, Nothing}, prefs_list :: Vector{String})
- function get_process_title()
+ function get_process_title
- function get_set(arch, name)
+ function get_set(arch, name)
- function get_staged(mi::MethodInstance, world::UInt)
+ function get_staged(mi :: MethodInstance, world :: UInt)
- function get_stmt_edges!(caller::InferenceState, currpc::Int=caller.currpc)
+ function get_stmt_edges!(caller :: InferenceState, currpc :: Int = caller.currpc)
- function get_task_ids(data::Vector{<:Unsigned}, threadid = nothing)
+ function get_task_ids(data :: Vector{??? <: Unsigned}, threadid = nothing)
- function get_task_tls(t::Task)
+ function get_task_tls(t :: Task)
- function get_test_counts(ts::DefaultTestSet)
+ function get_test_counts(ts :: DefaultTestSet)
- function get_test_result(ex, source)
+ function get_test_result(ex, source)
- function get_testset()
+ function get_testset
- function get_testset_depth()
+ function get_testset_depth
- function get_thread_ids(data::Vector{<:Unsigned}, taskid = nothing)
+ function get_thread_ids(data :: Vector{??? <: Unsigned}, taskid = nothing)
- function get_umask()
+ function get_umask
- function get_updated_dict(p::TOML.Parser, f::CachedTOMLDict)
+ function get_updated_dict(p :: TOML.Parser, f :: CachedTOMLDict)
- function get_usings!(usings, ex)
+ function get_usings!(usings, ex)
- function get_uuid_name(project::Dict{String, Any}, uuid::UUID)
+ function get_uuid_name(project :: Dict{String, Any}, uuid :: UUID)
- function get_uuid_name(project_toml::String, uuid::UUID)
+ function get_uuid_name(project_toml :: String, uuid :: UUID)
- function get_vmsize()
+ function get_vmsize
- function getaddrinfo(host::AbstractString)
+ function getaddrinfo(host :: AbstractString)
- function getaddrinfo(host::String, T::Type{<:IPAddr})
+ function getaddrinfo(host :: String, T :: Type{??? <: IPAddr})
- function getaliases(x::Union{Argument,SSAValue}, estate::EscapeState)
+ function getaliases(x :: Union{Argument, SSAValue}, estate :: EscapeState)
- function getaliases(xidx::Int, estate::EscapeState)
+ function getaliases(xidx :: Int, estate :: EscapeState)
- function getalladdrinfo(host::String)
+ function getalladdrinfo(host :: String)
- function getcache(mi::Core.MethodInstance)
+ function getcache(mi :: Core.MethodInstance)
- function getcompletion(completions)
+ function getcompletion(completions)
- function getconfig(name::AbstractString, default)
+ function getconfig(name :: AbstractString, default)
- function getconfig(r::GitRepo, name::AbstractString, default)
+ function getconfig(r :: GitRepo, name :: AbstractString, default)
- function getconfig(rname::AbstractString, name::AbstractString, default)
+ function getconfig(rname :: AbstractString, name :: AbstractString, default)
- function getdict!(dict::LineInfoDict, data::Vector{UInt})
+ function getdict!(dict :: LineInfoDict, data :: Vector{UInt})
- function getdict(data::Vector{UInt})
+ function getdict(data :: Vector{UInt})
- function getfield_boundscheck((; fargs, argtypes)::ArgInfo)
+ function getfield_boundscheck((;fargs,argtypes) :: ArgInfo)
- function getfield_effects(L::AbstractLattice, arginfo::ArgInfo, @nospecialize(rt))
+ function getfield_effects(L :: AbstractLattice, arginfo :: ArgInfo, rt)
- function getfield_knownindex_unused(v)
+ function getfield_knownindex_unused(v)
- function getfield_knownindex_used1(r, v)
+ function getfield_knownindex_used1(r, v)
- function getfield_knownindex_used2(r, v)
+ function getfield_knownindex_used2(r, v)
- function getfield_knownindex_used3(r, v)
+ function getfield_knownindex_used3(r, v)
- function getfield_nothrow(L::AbstractLattice, arginfo::ArgInfo, boundscheck::Symbol=getfield_boundscheck(arginfo))
+ function getfield_nothrow(L :: AbstractLattice, arginfo :: ArgInfo, boundscheck :: Symbol = getfield_boundscheck(arginfo))
- function getfield_unknownindex_unused(v, n)
+ function getfield_unknownindex_unused(v, n)
- function getfilespaths!(filepaths::Vector, rootdir::AbstractString)
+ function getfilespaths!(filepaths :: Vector, rootdir :: AbstractString)
- function getglobal_effects(argtypes::Vector{Any}, @nospecialize(rt))
+ function getglobal_effects(argtypes :: Vector{Any}, rt)
- function getgrgid(gid::Unsigned, throw_error::Bool=true)
+ function getgrgid(gid :: Unsigned, throw_error :: Bool = true)
- function getgroupname(gid::Unsigned)
+ function getgroupname(gid :: Unsigned)
- function gethandle(io::IO)
+ function gethandle(io :: IO)
- function gethostname()
+ function gethostname
- function getindex(::Type{Any}, @nospecialize vals...)
+ function getindex(??? :: Type{Any}, vals...)
- function getindex(::Type{T}, vals...) where T
+ function getindex(??? :: Type{T}, vals...) where T
- function getindex(@nospecialize(t::Tuple), r::AbstractUnitRange)
+ function getindex(t :: Tuple, r :: AbstractUnitRange)
- function getindex(A::AbstractArray, I...)
+ function getindex(A :: AbstractArray, I...)
- function getindex(A::Array, I::AbstractUnitRange{<:Integer})
+ function getindex(A :: Array, I :: AbstractUnitRange{??? <: Integer})
- function getindex(A::Array, c::Colon)
+ function getindex(A :: Array, c :: Colon)
- function getindex(A::Array, i1::Int, i2::Int, I::Int...)
+ function getindex(A :: Array, i1 :: Int, i2 :: Int, I :: Int...)
- function getindex(A::Array, i::Int)
+ function getindex(A :: Array, i :: Int)
- function getindex(A::Array{S}, I::AbstractRange{Int}) where S
+ function getindex(A :: Array{S}, I :: AbstractRange{Int}) where S
- function getindex(A::Memory, I::AbstractUnitRange{<:Integer})
+ function getindex(A :: Memory, I :: AbstractUnitRange{??? <: Integer})
- function getindex(G::Givens, i::Integer, j::Integer)
+ function getindex(G :: Givens, i :: Integer, j :: Integer)
- function getindex(J::UniformScaling{T}, n::AbstractVector{<:Integer}, m::AbstractVector{<:Integer}) where T
+ function getindex(J :: UniformScaling{T}, n :: AbstractVector{??? <: Integer}, m :: AbstractVector{??? <: Integer}) where T
- function getindex(J::UniformScaling{T}, n::AbstractVector{<:Integer}, m::Integer) where T
+ function getindex(J :: UniformScaling{T}, n :: AbstractVector{??? <: Integer}, m :: Integer) where T
- function getindex(V::FastContiguousSubArray, i::Int)
+ function getindex(V :: FastContiguousSubArray, i :: Int)
- function getindex(V::FastContiguousSubArray{<:Any, 1}, i::Int)
+ function getindex(V :: FastContiguousSubArray{??? <: Any, DependentType@1b28cdfa}, i :: Int)
- function getindex(V::FastSubArray, i::Int)
+ function getindex(V :: FastSubArray, i :: Int)
- function getindex(V::FastSubArray{<:Any, 1}, i::Int)
+ function getindex(V :: FastSubArray{??? <: Any, DependentType@eed1f14}, i :: Int)
- function getindex(V::SubArray{T,N}, I::Vararg{Int,N}) where {T,N}
+ function getindex(V :: SubArray{T, N}, I :: Vararg{Int, N}) where T, N
- function getindex(compact::IncrementalCompact, ssa::NewSSAValue)
+ function getindex(compact :: IncrementalCompact, ssa :: NewSSAValue)
- function getindex(compact::IncrementalCompact, ssa::OldSSAValue)
+ function getindex(compact :: IncrementalCompact, ssa :: OldSSAValue)
- function getindex(compact::IncrementalCompact, ssa::SSAValue)
+ function getindex(compact :: IncrementalCompact, ssa :: SSAValue)
- function getindex(d::IdDict{K,V}, @nospecialize(key)) where {K, V}
+ function getindex(d :: IdDict{K, V}, key) where K, V
- function getindex(dict::ImmutableDict, key)
+ function getindex(dict :: ImmutableDict, key)
- function getindex(dict::PersistentDict{K,V}, key::K) where {K,V}
+ function getindex(dict :: PersistentDict{K, V}, key :: K) where K, V
- function getindex(dtfd::DataTypeFieldDesc, i::Int)
+ function getindex(dtfd :: DataTypeFieldDesc, i :: Int)
- function getindex(estate::EscapeState, @nospecialize(x))
+ function getindex(estate :: EscapeState, x)
- function getindex(h::Dict{K,V}, key) where V where K
+ function getindex(h :: Dict{K, V}, key) where V where K
- function getindex(ir::IRCode, s::SSAValue)
+ function getindex(ir :: IRCode, s :: SSAValue)
- function getindex(iter::LinearIndices, i::AbstractRange{<:Integer})
+ function getindex(iter :: LinearIndices, i :: AbstractRange{??? <: Integer})
- function getindex(iter::LinearIndices, i::Int)
+ function getindex(iter :: LinearIndices, i :: Int)
- function getindex(m::RegexMatch, name::Union{AbstractString,Symbol})
+ function getindex(m :: RegexMatch, name :: Union{AbstractString, Symbol})
- function getindex(r::AbstractUnitRange, s::AbstractUnitRange{T}) where {T<:Integer}
+ function getindex(r :: AbstractUnitRange, s :: AbstractUnitRange{T}) where T <: Integer
- function getindex(r::AbstractUnitRange, s::StepRange{T}) where {T<:Integer}
+ function getindex(r :: AbstractUnitRange, s :: StepRange{T}) where T <: Integer
- function getindex(r::LinRange{T}, s::OrdinalRange{S}) where {T, S<:Integer}
+ function getindex(r :: LinRange{T}, s :: OrdinalRange{S}) where T, S <: Integer
- function getindex(r::OneTo{T}, s::OneTo) where T
+ function getindex(r :: OneTo{T}, s :: OneTo) where T
- function getindex(r::StepRange, s::AbstractRange{T}) where {T<:Integer}
+ function getindex(r :: StepRange, s :: AbstractRange{T}) where T <: Integer
- function getindex(r::StepRangeLen{T,<:TwicePrecision,<:TwicePrecision}, s::OrdinalRange{S}) where {T, S<:Integer}
+ function getindex(r :: StepRangeLen{T, ??? <: TwicePrecision, ??? <: TwicePrecision}, s :: OrdinalRange{S}) where T, S <: Integer
- function getindex(r::StepRangeLen{T}, s::OrdinalRange{S}) where {T, S<:Integer}
+ function getindex(r :: StepRangeLen{T}, s :: OrdinalRange{S}) where T, S <: Integer
- function getindex(s::AbstractString, i::Integer)
+ function getindex(s :: AbstractString, i :: Integer)
- function getindex(s::AnnotatedString, i::Integer)
+ function getindex(s :: AnnotatedString, i :: Integer)
- function getindex(s::SubString, i::Integer)
+ function getindex(s :: SubString, i :: Integer)
- function getindex(t::AbstractDict{<:Any,V}, key) where V
+ function getindex(t :: AbstractDict{??? <: Any, V}, key) where V
- function getindex(tpdum::TwoPhaseDefUseMap, idx::Int)
+ function getindex(tpdum :: TwoPhaseDefUseMap, idx :: Int)
- function getindex(tpvv::TwoPhaseVectorView, i::Int)
+ function getindex(tpvv :: TwoPhaseVectorView, i :: Int)
- function getindex(view::TypesView, idx::Int)
+ function getindex(view :: TypesView, idx :: Int)
- function getindex(view::TypesView, idx::NewSSAValue)
+ function getindex(view :: TypesView, idx :: NewSSAValue)
- function getindex(view::TypesView, v::OldSSAValue)
+ function getindex(view :: TypesView, v :: OldSSAValue)
- function getindex(wkh::WeakKeyDict{K}, key) where {K}
+ function getindex(wkh :: WeakKeyDict{K}, key) where K
- function getindex(wvc::WorldView{InternalCodeCache}, mi::MethodInstance)
+ function getindex(wvc :: WorldView{InternalCodeCache}, mi :: MethodInstance)
- function getindex(x::Number, I::Integer...)
+ function getindex(x :: Number, I :: Integer...)
- function getindex(x::Number, i::Integer)
+ function getindex(x :: Number, i :: Integer)
- function getindex_continued(s, i::Int, u::UInt32)
+ function getindex_continued(s, i :: Int, u :: UInt32)
- function getipaddr(addr_type::Type{T}) where T<:IPAddr
+ function getipaddr(addr_type :: Type{T}) where T <: IPAddr
- function getipaddrs(addr_type::Type{T}=IPAddr; loopback::Bool=false) where T<:IPAddr
+ function getipaddrs(addr_type :: Type{T} = IPAddr, loopback :: Bool = false) where T <: IPAddr
- function getkey(h::Dict{K,V}, key, default) where V where K
+ function getkey(h :: Dict{K, V}, key, default) where V where K
- function getkey(wkh::WeakKeyDict{K}, kk, default) where K
+ function getkey(wkh :: WeakKeyDict{K}, kk, default) where K
- function getline(output)
+ function getline(output)
- function getline(sfs)
+ function getline(sfs)
- function getnameinfo(address::Union{IPv4, IPv6})
+ function getnameinfo(address :: Union{IPv4, IPv6})
- function getpass(input::TTY, output::IO, prompt::AbstractString)
+ function getpass(input :: TTY, output :: IO, prompt :: AbstractString)
- function getproperty(B::BunchKaufman{T,<:StridedMatrix}, d::Symbol) where {T<:BlasFloat}
+ function getproperty(B :: BunchKaufman{T, ??? <: StridedMatrix}, d :: Symbol) where T <: BlasFloat
- function getproperty(C::Cholesky, d::Symbol)
+ function getproperty(C :: Cholesky, d :: Symbol)
- function getproperty(C::CholeskyPivoted{T}, d::Symbol) where {T}
+ function getproperty(C :: CholeskyPivoted{T}, d :: Symbol) where T
- function getproperty(C::Cholesky{<:Any,<:Diagonal}, d::Symbol)
+ function getproperty(C :: Cholesky{??? <: Any, ??? <: Diagonal}, d :: Symbol)
- function getproperty(F::GeneralizedSchur, d::Symbol)
+ function getproperty(F :: GeneralizedSchur, d :: Symbol)
- function getproperty(F::Hessenberg, d::Symbol)
+ function getproperty(F :: Hessenberg, d :: Symbol)
- function getproperty(F::LDLt{<:Any, <:SymTridiagonal}, d::Symbol)
+ function getproperty(F :: LDLt{??? <: Any, ??? <: SymTridiagonal}, d :: Symbol)
- function getproperty(F::LQ, d::Symbol)
+ function getproperty(F :: LQ, d :: Symbol)
- function getproperty(F::LU{T,Tridiagonal{T,V}}, d::Symbol) where {T,V}
+ function getproperty(F :: LU{T, Tridiagonal{T, V}}, d :: Symbol) where T, V
- function getproperty(F::LU{T}, d::Symbol) where T
+ function getproperty(F :: LU{T}, d :: Symbol) where T
- function getproperty(F::QR, d::Symbol)
+ function getproperty(F :: QR, d :: Symbol)
- function getproperty(F::QRCompactWY, d::Symbol)
+ function getproperty(F :: QRCompactWY, d :: Symbol)
- function getproperty(F::QRPivoted{T}, d::Symbol) where T
+ function getproperty(F :: QRPivoted{T}, d :: Symbol) where T
- function getproperty(F::SVD, d::Symbol)
+ function getproperty(F :: SVD, d :: Symbol)
- function getproperty(F::Schur, d::Symbol)
+ function getproperty(F :: Schur, d :: Symbol)
- function getproperty(ci::CodeInfo, s::Symbol)
+ function getproperty(ci :: CodeInfo, s :: Symbol)
- function getproperty(f::FDEvent, field::Symbol)
+ function getproperty(f :: FDEvent, field :: Symbol)
- function getproperty(fdw::FDWatcher, s::Symbol)
+ function getproperty(fdw :: FDWatcher, s :: Symbol)
- function getproperty(m::AbstractMenu, name::Symbol)
+ function getproperty(m :: AbstractMenu, name :: Symbol)
- function getproperty(pipe::AbstractPipe, name::Symbol)
+ function getproperty(pipe :: AbstractPipe, name :: Symbol)
- function getproperty(server::LibuvServer, name::Symbol)
+ function getproperty(server :: LibuvServer, name :: Symbol)
- function getproperty(stream::LibuvStream, name::Symbol)
+ function getproperty(stream :: LibuvStream, name :: Symbol)
- function getproperty(x::Pairs, s::Symbol)
+ function getproperty(x :: Pairs, s :: Symbol)
- function getpw()
+ function getpw
- function getpwuid(uid::Unsigned, throw_error::Bool=true)
+ function getpwuid(uid :: Unsigned, throw_error :: Bool = true)
- function getqs(F::LinearAlgebra.LQ)
+ function getqs(F :: LinearAlgebra.LQ)
- function getrandom!(A::Union{Array,Base.RefValue})
+ function getrandom!(A :: Union{Array, Base.RefValue})
- function gettable(s::AbstractSerializer, id::Int)
+ function gettable(s :: AbstractSerializer, id :: Int)
- function gettypeinfos(io::IO, p::Pair)
+ function gettypeinfos(io :: IO, p :: Pair)
- function getusername(uid::Unsigned)
+ function getusername(uid :: Unsigned)
- function ginv(start, inv, N)
+ function ginv(start, inv, N)
- function gitdir(repo::GitRepo)
+ function gitdir(repo :: GitRepo)
- function github_paragraph(stream::IO, md::MD)
+ function github_paragraph(stream :: IO, md :: MD)
- function github_table(stream::IO, md::MD)
+ function github_table(stream :: IO, md :: MD)
- function givens(f::T, g::T, i1::Integer, i2::Integer) where T
+ function givens(f :: T, g :: T, i1 :: Integer, i2 :: Integer) where T
- function givensAlgorithm(f::Complex{T}, g::Complex{T}) where T<:AbstractFloat
+ function givensAlgorithm(f :: Complex{T}, g :: Complex{T}) where T <: AbstractFloat
- function givensAlgorithm(f::T, g::T) where T
+ function givensAlgorithm(f :: T, g :: T) where T
- function givensAlgorithm(f::T, g::T) where T<:AbstractFloat
+ function givensAlgorithm(f :: T, g :: T) where T <: AbstractFloat
- function global_assignment_nothrow(M::Module, s::Symbol, @nospecialize(newty))
+ function global_assignment_nothrow(M :: Module, s :: Symbol, newty)
- function global_logger(logger::AbstractLogger)
+ function global_logger(logger :: AbstractLogger)
- function global_order_nothrow(@nospecialize(o), loading::Bool, storing::Bool)
+ function global_order_nothrow(o, loading :: Bool, storing :: Bool)
- function glotest()
+ function glotest
- function glue_src_bitchunks(src::Vector{UInt64}, k::Int, ks1::Int, msk_s0::UInt64, ls0::Int)
+ function glue_src_bitchunks(src :: Vector{UInt64}, k :: Int, ks1 :: Int, msk_s0 :: UInt64, ls0 :: Int)
- function goto_test1()
+ function goto_test1
- function goto_test5_3()
+ function goto_test5_3
- function goto_test6()
+ function goto_test6
- function goto_test7(x)
+ function goto_test7(x)
- function graphemes(s::AbstractString, r::AbstractUnitRange{<:Integer})
+ function graphemes(s :: AbstractString, r :: AbstractUnitRange{??? <: Integer})
- function group_roots(iter::RLEIterator)
+ function group_roots(iter :: RLEIterator)
- function group_roots(m::Method)
+ function group_roots(m :: Method)
- function grow!(io::IO, offset::Integer, len::Integer)
+ function grow!(io :: IO, offset :: Integer, len :: Integer)
- function grow_to!(dest, itr)
+ function grow_to!(dest, itr)
- function grow_to!(dest, itr, st)
+ function grow_to!(dest, itr, st)
- function grow_to!(dest::AbstractDict{K, V}, itr) where V where K
+ function grow_to!(dest :: AbstractDict{K, V}, itr) where V where K
- function grow_to!(dest::AbstractDict{K,V}, itr, st) where V where K
+ function grow_to!(dest :: AbstractDict{K, V}, itr, st) where V where K
- function guardseed(f::Function, r::AbstractRNG=default_rng())
+ function guardseed(f :: Function, r :: AbstractRNG = default_rng())
- function guess_current_mode_name(s)
+ function guess_current_mode_name(s)
- function h(x)
+ function h(x)
- function h11480(x::A{A{A{A{A{A{A{A{A{Int}}}}}}}}})
+ function h11480(x :: A{A{A{A{A{A{A{A{A{Int}}}}}}}}})
- function h17449(v)
+ function h17449(v)
- function h18679()
+ function h18679
- function h19333()
+ function h19333
- function h20343()
+ function h20343
- function h25579(g)
+ function h25579(g)
- function h27268()
+ function h27268
- function h27316()
+ function h27316
- function h33768()
+ function h33768
- function h34482()
+ function h34482
- function h34752()
+ function h34752
- function h5142(a::Bool)
+ function h5142(a :: Bool)
- function h5142(a::Int)
+ function h5142(a :: Int)
- function h5142b(a::Int)
+ function h5142b(a :: Int)
- function handle_concrete_result!(cases::Vector{InliningCase}, result::ConcreteResult, @nospecialize(info::CallInfo), state::InliningState)
+ function handle_concrete_result!(cases :: Vector{InliningCase}, result :: ConcreteResult, info :: CallInfo, state :: InliningState)
- function handle_control_backedge!(interp::AbstractInterpreter, frame::InferenceState, from::Int, to::Int)
+ function handle_control_backedge!(interp :: AbstractInterpreter, frame :: InferenceState, from :: Int, to :: Int)
- function handle_deserialize(s::AbstractSerializer, b::Int32)
+ function handle_deserialize(s :: AbstractSerializer, b :: Int32)
- function handle_global_assignment!(interp::AbstractInterpreter, frame::InferenceState, lhs::GlobalRef, @nospecialize(newty))
+ function handle_global_assignment!(interp :: AbstractInterpreter, frame :: InferenceState, lhs :: GlobalRef, newty)
- function handle_modifyfield!_call!(ir::IRCode, idx::Int, stmt::Expr, info::ModifyFieldInfo, state::InliningState)
+ function handle_modifyfield!_call!(ir :: IRCode, idx :: Int, stmt :: Expr, info :: ModifyFieldInfo, state :: InliningState)
- function handler(append)
+ function handler(append)
- function hardlink(src::AbstractString, dst::AbstractString)
+ function hardlink(src :: AbstractString, dst :: AbstractString)
- function has_backslashes(f::Function)
+ function has_backslashes(f :: Function)
- function has_backslashes(meth::Method)
+ function has_backslashes(meth :: Method)
- function has_backslashes(mod::Module)
+ function has_backslashes(mod :: Module)
- function has_bottom_parameter(t::DataType)
+ function has_bottom_parameter(t :: DataType)
- function has_meta(data)
+ function has_meta(data)
- function has_unbound_vars(@nospecialize sig)
+ function has_unbound_vars(sig)
- function hash(A::AbstractArray, h::UInt)
+ function hash(A :: AbstractArray, h :: UInt)
- function hash(a::AbstractDict, h::UInt)
+ function hash(a :: AbstractDict, h :: UInt)
- function hash(frame::StackFrame, h::UInt)
+ function hash(frame :: StackFrame, h :: UInt)
- function hash(pkg::PkgId, h::UInt)
+ function hash(pkg :: PkgId, h :: UInt)
- function hash(r::Regex, h::UInt)
+ function hash(r :: Regex, h :: UInt)
- function hash(s::AbstractSet, h::UInt)
+ function hash(s :: AbstractSet, h :: UInt)
- function hash(s::SubString{String}, h::UInt)
+ function hash(s :: SubString{String}, h :: UInt)
- function hash(t::Any32, h::UInt)
+ function hash(t :: Any32, h :: UInt)
- function hash(v::VersionNumber, h::UInt)
+ function hash(v :: VersionNumber, h :: UInt)
- function hash(x::BigInt, h::UInt)
+ function hash(x :: BigInt, h :: UInt)
- function hash(x::Float16, h::UInt)
+ function hash(x :: Float16, h :: UInt)
- function hash(x::Float64, h::UInt)
+ function hash(x :: Float64, h :: UInt)
- function hash(x::Rational{<:BitInteger64}, h::UInt)
+ function hash(x :: Rational{??? <: BitInteger64}, h :: UInt)
- function hash(x::Real, h::UInt)
+ function hash(x :: Real, h :: UInt)
- function hash(z::Complex, h::UInt)
+ function hash(z :: Complex, h :: UInt)
- function hash_32_32(n::UInt32)
+ function hash_32_32(n :: UInt32)
- function hash_64_32(n::UInt64)
+ function hash_64_32(n :: UInt64)
- function hash_64_64(n::UInt64)
+ function hash_64_64(n :: UInt64)
- function hash_integer(n::BigInt, h::UInt)
+ function hash_integer(n :: BigInt, h :: UInt)
- function hash_integer(n::Integer, h::UInt)
+ function hash_integer(n :: Integer, h :: UInt)
- function hash_seed(seed::Integer)
+ function hash_seed(seed :: Integer)
- function hash_seed(seed::Union{AbstractArray{UInt32}, AbstractArray{UInt64}})
+ function hash_seed(seed :: Union{AbstractArray{UInt32}, AbstractArray{UInt64}})
- function hash_seed(str::AbstractString)
+ function hash_seed(str :: AbstractString)
- function hashheader(stream::IO, md::MD)
+ function hashheader(stream :: IO, md :: MD)
- function hashindex(key, sz)
+ function hashindex(key, sz)
- function haskey(dict::ImmutableDict, key)
+ function haskey(dict :: ImmutableDict, key)
- function haskey(dict::PersistentDict{K}, key::K) where K
+ function haskey(dict :: PersistentDict{K}, key :: K) where K
- function haskey(m::RegexMatch, name::Union{AbstractString,Symbol})
+ function haskey(m :: RegexMatch, name :: Union{AbstractString, Symbol})
- function haskey(wkh::WeakKeyDict{K}, key) where {K}
+ function haskey(wkh :: WeakKeyDict{K}, key) where K
- function haskey(wvc::WorldView{InternalCodeCache}, mi::MethodInstance)
+ function haskey(wvc :: WorldView{InternalCodeCache}, mi :: MethodInstance)
- function hasmethod(@nospecialize(f), @nospecialize(t))
+ function hasmethod(f, t)
- function hasmethod(f, t, kwnames::Tuple{Vararg{Symbol}}; world::UInt=get_world_counter())
+ function hasmethod(f, t, kwnames :: Tuple{Vararg{Symbol}}, world :: UInt = get_world_counter())
- function hasnokwsuggestions(str)
+ function hasnokwsuggestions(str)
- function hasuniquerep(@nospecialize t)
+ function hasuniquerep(t)
- function hasvalid(mi, world)
+ function hasvalid(mi, world)
- function haszerolayout(x::NTuple{32, VecElement{UInt8}})
+ function haszerolayout(x :: NTuple{DependentType@7229724f, VecElement{UInt8}})
- function hcat(A::Union{BitMatrix,BitVector}...)
+ function hcat(A :: Union{BitMatrix, BitVector}...)
- function hcat(B::BitVector...)
+ function hcat(B :: BitVector...)
- function hcat(V::Vector{T}...) where T
+ function hcat(V :: Vector{T}...) where T
- function head!(repo::GitRepo, ref::GitReference)
+ function head!(repo :: GitRepo, ref :: GitReference)
- function head(pkg::AbstractString)
+ function head(pkg :: AbstractString)
- function head(repo::GitRepo)
+ function head(repo :: GitRepo)
- function head_oid(repo::GitRepo)
+ function head_oid(repo :: GitRepo)
- function header(p::Pager)
+ function header(p :: Pager)
- function headname(repo::GitRepo)
+ function headname(repo :: GitRepo)
- function heapify!(xs::Vector, o::Ordering)
+ function heapify!(xs :: Vector, o :: Ordering)
- function heappop!(xs::Vector, o::Ordering)
+ function heappop!(xs :: Vector, o :: Ordering)
- function heappush!(xs::Vector, x, o::Ordering)
+ function heappush!(xs :: Vector, x, o :: Ordering)
- function hello(param::Vector{In64_nOt_DeFiNeD__})
+ function hello(param :: Vector{In64_nOt_DeFiNeD__})
- function hello_err_out()
+ function hello_err_out
- function helpmode(io::IO, line::AbstractString, mod::Module=Main)
+ function helpmode(io :: IO, line :: AbstractString, mod :: Module = Main)
- function hermitian_type(::Type{T}) where {S, T<:AbstractMatrix{S}}
+ function hermitian_type(??? :: Type{T}) where S, T <: AbstractMatrix{S}
- function hermitian_type(::Type{T}) where {S<:AbstractMatrix, T<:AbstractMatrix{S}}
+ function hermitian_type(??? :: Type{T}) where S <: AbstractMatrix, T <: AbstractMatrix{S}
- function hermitian_type(::Type{T}) where {S<:Number, T<:AbstractMatrix{S}}
+ function hermitian_type(??? :: Type{T}) where S <: Number, T <: AbstractMatrix{S}
- function hessenberg!(A::Union{Symmetric{<:BlasReal,<:StridedMatrix},Hermitian{<:BlasFloat,<:StridedMatrix}})
+ function hessenberg!(A :: Union{Symmetric{??? <: BlasReal, ??? <: StridedMatrix}, Hermitian{??? <: BlasFloat, ??? <: StridedMatrix}})
- function hex(x::Unsigned, pad::Int, neg::Bool)
+ function hex(x :: Unsigned, pad :: Int, neg :: Bool)
- function hex2bytes!(dest::AbstractArray{UInt8}, itr)
+ function hex2bytes!(dest :: AbstractArray{UInt8}, itr)
- function hex2bytes!(dest::AbstractArray{UInt8}, s::String)
+ function hex2bytes!(dest :: AbstractArray{UInt8}, s :: String)
- function hh6614()
+ function hh6614
- function hidigit(x::AbstractFloat, base)
+ function hidigit(x :: AbstractFloat, base)
- function highlight_llvm(s)
+ function highlight_llvm(s)
- function highlight_native(s, arch)
+ function highlight_native(s, arch)
- function highlight_region(lwrite::Union{String,SubString{String}}, regstart::Int, regstop::Int, written::Int, slength::Int)
+ function highlight_region(lwrite :: Union{String, SubString{String}}, regstart :: Int, regstop :: Int, written :: Int, slength :: Int)
- function highprec_pair(x, y)
+ function highprec_pair(x, y)
- function hilb(T::Type, m::Integer, n::Integer)
+ function hilb(T :: Type, m :: Integer, n :: Integer)
- function hilb(T::Type, n::Integer)
+ function hilb(T :: Type, n :: Integer)
- function hist(X, n)
+ function hist(X, n)
- function hist_from_file(hp::REPLHistoryProvider, path::String)
+ function hist_from_file(hp :: REPLHistoryProvider, path :: String)
- function hist_open_file(hp::REPLHistoryProvider)
+ function hist_open_file(hp :: REPLHistoryProvider)
- function history_move(s::Union{LineEdit.MIState,LineEdit.PrefixSearchState}, hist::REPLHistoryProvider, idx::Int, save_idx::Int = hist.cur_idx)
+ function history_move(s :: Union{LineEdit.MIState, LineEdit.PrefixSearchState}, hist :: REPLHistoryProvider, idx :: Int, save_idx :: Int = hist.cur_idx)
- function history_next(s::ModeState, hist)
+ function history_next(s :: ModeState, hist)
- function history_next_result(s::MIState, data::ModeState)
+ function history_next_result(s :: MIState, data :: ModeState)
- function history_prev(s::ModeState, hist)
+ function history_prev(s :: ModeState, hist)
- function history_reset_state(hist::REPLHistoryProvider)
+ function history_reset_state(hist :: REPLHistoryProvider)
- function history_set_backward(s::SearchState, backward::Bool)
+ function history_set_backward(s :: SearchState, backward :: Bool)
- function homedir()
+ function homedir
- function horizontalrule(stream::IO, block::MD)
+ function horizontalrule(stream :: IO, block :: MD)
- function host_triplet()
+ function host_triplet
- function ht_keyindex2_shorthash!(h::Dict{K,V}, key) where V where K
+ function ht_keyindex2_shorthash!(h :: Dict{K, V}, key) where V where K
- function html(io::IO, code::Code)
+ function html(io :: IO, code :: Code)
- function html(io::IO, content::Vector)
+ function html(io :: IO, content :: Vector)
- function html(io::IO, f::Footnote)
+ function html(io :: IO, f :: Footnote)
- function html(io::IO, header::Header{l}) where l
+ function html(io :: IO, header :: Header{l}) where l
- function html(io::IO, md::Admonition)
+ function html(io :: IO, md :: Admonition)
- function html(io::IO, md::BlockQuote)
+ function html(io :: IO, md :: BlockQuote)
- function html(io::IO, md::HorizontalRule)
+ function html(io :: IO, md :: HorizontalRule)
- function html(io::IO, md::List)
+ function html(io :: IO, md :: List)
- function html(io::IO, md::Paragraph)
+ function html(io :: IO, md :: Paragraph)
- function html(io::IO, md::Table)
+ function html(io :: IO, md :: Table)
- function htmlesc(io::IO, s::AbstractString)
+ function htmlesc(io :: IO, s :: AbstractString)
- function htmlesc(io::IO, s::Symbol)
+ function htmlesc(io :: IO, s :: Symbol)
- function htmlesc(io::IO, xs::Union{AbstractString,Symbol}...)
+ function htmlesc(io :: IO, xs :: Union{AbstractString, Symbol}...)
- function htmlesc(s::Union{AbstractString,Symbol})
+ function htmlesc(s :: Union{AbstractString, Symbol})
- function htmlinline(io::IO, br::LineBreak)
+ function htmlinline(io :: IO, br :: LineBreak)
- function htmlinline(io::IO, code::Code)
+ function htmlinline(io :: IO, code :: Code)
- function htmlinline(io::IO, content::Vector)
+ function htmlinline(io :: IO, content :: Vector)
- function htmlinline(io::IO, f::Footnote)
+ function htmlinline(io :: IO, f :: Footnote)
- function htmlinline(io::IO, link::Link)
+ function htmlinline(io :: IO, link :: Link)
- function htmlinline(io::IO, md::Bold)
+ function htmlinline(io :: IO, md :: Bold)
- function htmlinline(io::IO, md::Image)
+ function htmlinline(io :: IO, md :: Image)
- function htmlinline(io::IO, md::Italic)
+ function htmlinline(io :: IO, md :: Italic)
- function htmlinline(io::IO, md::Union{Symbol,AbstractString})
+ function htmlinline(io :: IO, md :: Union{Symbol, AbstractString})
- function hvcat(nbc::Int, as...)
+ function hvcat(nbc :: Int, as...)
- function hvcat(rows::Tuple{Vararg{Int}}, xs::T...) where T<:Number
+ function hvcat(rows :: Tuple{Vararg{Int}}, xs :: T...) where T <: Number
- function hvcat18399(as)
+ function hvcat18399(as)
- function hvcat_fill!(a::Array, xs::Tuple)
+ function hvcat_fill!(a :: Array, xs :: Tuple)
- function hvncat_fill!(A::Array, row_first::Bool, xs::Tuple)
+ function hvncat_fill!(A :: Array, row_first :: Bool, xs :: Tuple)
- function hypot(x::BigFloat, y::BigFloat)
+ function hypot(x :: BigFloat, y :: BigFloat)
- function i18408()
+ function i18408
- function i20343()
+ function i20343
- function i2619()
+ function i2619
- function i7197()
+ function i7197
- function iamax(dx::AbstractArray)
+ function iamax(dx :: AbstractArray)
- function ident_cmp(A::VerTuple, B::VerTuple)
+ function ident_cmp(A :: VerTuple, B :: VerTuple)
- function identify_package_env(name::String)
+ function identify_package_env(name :: String)
- function identify_package_env(where::PkgId, name::String)
+ function identify_package_env(where :: PkgId, name :: String)
- function identify_possible_method_completion(partial, last_idx)
+ function identify_possible_method_completion(partial, last_idx)
- function idle_callback(handle)
+ function idle_callback(handle)
- function ifs_around_var_capture()
+ function ifs_around_var_capture
- function ig27907(::Type{T}, ::Type, N::Integer, offsets...) where {T}
+ function ig27907(??? :: Type{T}, ??? :: Type, N :: Integer, offsets...) where T
- function image(stream::IO, md::MD)
+ function image(stream :: IO, md :: MD)
- function immut50285(b, x, y)
+ function immut50285(b, x, y)
- function implicit_manifest_deps_get(dir::String, where::PkgId, name::String)::Union{Nothing,PkgId}
+ function implicit_manifest_deps_get(dir :: String, where :: PkgId, name :: String)
- function implicit_manifest_uuid_path(dir::String, pkg::PkgId)::Union{Nothing,String}
+ function implicit_manifest_uuid_path(dir :: String, pkg :: PkgId)
- function implicit_project_deps_get(dir::String, name::String)::Union{Nothing,PkgId}
+ function implicit_project_deps_get(dir :: String, name :: String)
- function in!(x, s::Set)
+ function in!(x, s :: Set)
- function in(idx::Int, bsbmp::BitSetBoundedMinPrioritySet)
+ function in(idx :: Int, bsbmp :: BitSetBoundedMinPrioritySet)
- function in(key_val::Pair{K,V}, dict::PersistentDict{K,V}, valcmp=(==)) where {K,V}
+ function in(key_val :: Pair{K, V}, dict :: PersistentDict{K, V}, valcmp = (==)) where K, V
- function in(key_value::Pair, dict::ImmutableDict, valcmp=(==))
+ function in(key_value :: Pair, dict :: ImmutableDict, valcmp = (==))
- function in(p, a::AbstractDict)
+ function in(p, a :: AbstractDict)
- function in(p::Pair, a::AbstractDict, valcmp=(==))
+ function in(p :: Pair, a :: AbstractDict, valcmp = (==))
- function in(x::T, r::StepRange{T}) where T<:TimeType
+ function in(x :: T, r :: StepRange{T}) where T <: TimeType
- function in_finalizer() @inline
+ function in_finalizer
- function inbase(m::Module)
+ @@inlinefunction inbase(m :: Module)
- function inbounds_30563()
+ function inbounds_30563
- function inbounds_option()
+ function inbounds_option
- function inc()
+ function inc
- function include(fname::AbstractString)
+ function include(fname :: AbstractString)
- function include(mod::Module, path::String)
+ function include(mod :: Module, path :: String)
- function includeDir()
+ function includeDir
- function include_dependency(path::AbstractString)
+ function include_dependency(path :: AbstractString)
- function incomplete_tag(ex::Expr)
+ function incomplete_tag(ex :: Expr)
- function increment_uses(ssa::AnySSAValue)
+ function increment_uses(ssa :: AnySSAValue)
- function indcopy(sz::Dims, I::GenericMemory)
+ function indcopy(sz :: Dims, I :: GenericMemory)
- function indcopy(sz::Dims, I::Tuple{Vararg{RangeIndex}})
+ function indcopy(sz :: Dims, I :: Tuple{Vararg{RangeIndex}})
- function indcopy(sz::Dims, I::Vector)
+ function indcopy(sz :: Dims, I :: Vector)
- function indent(depth::Int)
+ function indent(depth :: Int)
- function indentation(str::AbstractString; tabwidth=8)
+ function indentation(str :: AbstractString, tabwidth = 8)
- function indentcode(stream::IO, block::MD)
+ function indentcode(stream :: IO, block :: MD)
- function index_elements(iter)
+ function index_elements(iter)
- function indexed_iterate(I, i)
+ function indexed_iterate(I, i)
- function indexed_iterate(I, i, state)
+ function indexed_iterate(I, i, state)
- function indexin(a, b::AbstractArray)
+ function indexin(a, b :: AbstractArray)
- function indices_promote_type(::Type{Tuple{R1,Vararg{R1,N}}}, ::Type{Tuple{R2,Vararg{R2,N}}}) where {R1,R2,N}
+ function indices_promote_type(??? :: Type{Tuple{R1, Vararg{R1, N}}}, ??? :: Type{Tuple{R2, Vararg{R2, N}}}) where R1, R2, N
- function indmaxcolumn(A::AbstractMatrix)
+ function indmaxcolumn(A :: AbstractMatrix)
- function inf_error_21369(arg)
+ function inf_error_21369(arg)
- function inferred_test_function()
+ function inferred_test_function
- function inflate_ir!(ci::CodeInfo, linfo::MethodInstance)
+ function inflate_ir!(ci :: CodeInfo, linfo :: MethodInstance)
- function inflate_ir!(ci::CodeInfo, sptypes::Vector{VarState}, argtypes::Vector{Any})
+ function inflate_ir!(ci :: CodeInfo, sptypes :: Vector{VarState}, argtypes :: Vector{Any})
- function inflate_ir(ci::CodeInfo)
+ function inflate_ir(ci :: CodeInfo)
- function info(regex::Ptr{Cvoid}, what::Integer, ::Type{T}) where T
+ function info(regex :: Ptr{Cvoid}, what :: Integer, ??? :: Type{T}) where T
- function info_effects(@nospecialize(result), match::MethodMatch, state::InliningState)
+ function info_effects(result, match :: MethodMatch, state :: InliningState)
- function init(; n::Union{Nothing,Integer} = nothing, delay::Union{Nothing,Real} = nothing, limitwarn::Bool = true)
+ function init(n :: Union{Nothing, Integer} = nothing, delay :: Union{Nothing, Real} = nothing, limitwarn :: Bool = true)
- function init(n::Integer, delay::Real; limitwarn::Bool = true)
+ function init(n :: Integer, delay :: Real, limitwarn :: Bool = true)
- function init(path::AbstractString, bare::Bool=false)
+ function init(path :: AbstractString, bare :: Bool = false)
- function init_active_project()
+ function init_active_project
- function init_depot_path()
+ function init_depot_path
- function init_lld_path()
+ function init_lld_path
- function init_load_path()
+ function init_load_path
- function init_loc_flds(S::SharedArray{T,N}, empty_local=false) where T where N
+ function init_loc_flds(S :: SharedArray{T, N}, empty_local = false) where T where N
- function init_p7zip_path()
+ function init_p7zip_path
- function init_state(terminal, m::ModalInterface)
+ function init_state(terminal, m :: ModalInterface)
- function init_stdio(handle::Ptr{Cvoid})
+ function init_stdio(handle :: Ptr{Cvoid})
- function init_vartable!(vartable::VarTable, frame::InferenceState)
+ function init_vartable!(vartable :: VarTable, frame :: InferenceState)
- function initialize()
+ function initialize
- function initialize_shared_array(S, onlocalhost, init, pids)
+ function initialize_shared_array(S, onlocalhost, init, pids)
- function initmeta(m::Module)
+ function initmeta(m :: Module)
- function initstate!(r::MersenneTwister, data::StridedVector, seed)
+ function initstate!(r :: MersenneTwister, data :: StridedVector, seed)
- function inline_code(stream::IO, md::MD)
+ function inline_code(stream :: IO, md :: MD)
- function inline_const_if_inlineable!(inst::Instruction)
+ function inline_const_if_inlineable!(inst :: Instruction)
- function inline_cost(ir::IRCode, params::OptimizationParams, cost_threshold::Int)
+ function inline_cost(ir :: IRCode, params :: OptimizationParams, cost_threshold :: Int)
- function inline_cost_clamp(x::Int)
+ function inline_cost_clamp(x :: Int)
- function inline_into_block!(state::CFGInliningState, block::Int)
+ function inline_into_block!(state :: CFGInliningState, block :: Int)
- function inline_linfo_printer(code::IRCode)
+ function inline_linfo_printer(code :: IRCode)
- function inline_splatnew!(ir::IRCode, idx::Int, stmt::Expr, @nospecialize(rt), state::InliningState)
+ function inline_splatnew!(ir :: IRCode, idx :: Int, stmt :: Expr, rt, state :: InliningState)
- function inlineanonymous(ex::Expr, val)
+ function inlineanonymous(ex :: Expr, val)
- function inner()
+ function inner
- function inner(ti)
+ function inner(ti)
- function inner2()
+ function inner2
- function input_string_newlines_aftercursor(s::PromptState)
+ function input_string_newlines_aftercursor(s :: PromptState)
- function inputeltypes(celt, alleltypes = alleltypes)
+ function inputeltypes(celt, alleltypes = alleltypes)
- function inputmattypes(cmat, mattypes = mattypes)
+ function inputmattypes(cmat, mattypes = mattypes)
- function insert!(a::Array{T,1}, i::Integer, item) where T
+ function insert!(a :: Array{T, DependentType@4c873330}, i :: Integer, item) where T
- function insert_extension_triggers(env::String, pkg::PkgId)::Union{Nothing,Missing}
+ function insert_extension_triggers(env :: String, pkg :: PkgId)
- function insert_extension_triggers(pkg::PkgId)
+ function insert_extension_triggers(pkg :: PkgId)
- function insert_hlines(docs)
+ function insert_hlines(docs)
- function insert_internal_warning(md::Markdown.MD, internal_access::Set{Pair{Module,Symbol}})
+ function insert_internal_warning(md :: Markdown.MD, internal_access :: Set{Pair{Module, Symbol}})
- function insert_internal_warning(other, internal_access::Set{Pair{Module,Symbol}})
+ function insert_internal_warning(other, internal_access :: Set{Pair{Module, Symbol}})
- function insert_node!(compact::IncrementalCompact, @nospecialize(before), newinst::NewInstruction, attach_after::Bool=false)
+ function insert_node!(compact :: IncrementalCompact, before, newinst :: NewInstruction, attach_after :: Bool = false)
- function insert_node!(ir::IRCode, pos::SSAValue, newinst::NewInstruction, attach_after::Bool=false)
+ function insert_node!(ir :: IRCode, pos :: SSAValue, newinst :: NewInstruction, attach_after :: Bool = false)
- function insert_node_here!(compact::IncrementalCompact, newinst::NewInstruction, reverse_affinity::Bool=false)
+ function insert_node_here!(compact :: IncrementalCompact, newinst :: NewInstruction, reverse_affinity :: Bool = false)
- function insert_spval!(insert_node!::Inserter, spvals_ssa::SSAValue, spidx::Int, do_isdefined::Bool)
+ function insert_spval!(insert_node! :: Inserter, spvals_ssa :: SSAValue, spidx :: Int, do_isdefined :: Bool)
- function insertions(diff_stat::GitDiffStats)
+ function insertions(diff_stat :: GitDiffStats)
- function instanceof_tfunc(@nospecialize(t), astag::Bool=false)
+ function instanceof_tfunc(t, astag :: Bool = false)
- function instantiate(bc::Broadcasted{Style{Tuple}})
+ function instantiate(bc :: Broadcasted{Style{Tuple}})
- function int_symdiff!(s::BitSet, n::Integer)
+ function int_symdiff!(s :: BitSet, n :: Integer)
- function integerpow(A::AbstractMatrix{T}, p) where T
+ function integerpow(A :: AbstractMatrix{T}, p) where T
- function interp(stream::IO, md::MD)
+ function interp(stream :: IO, md :: MD)
- function interpinner(stream::IO, greedy = false)
+ function interpinner(stream :: IO, greedy = false)
- function intersect!(s::AbstractSet, itrs...)
+ function intersect!(s :: AbstractSet, itrs...)
- function intersect(a::WorldRange, b::WorldRange)
+ function intersect(a :: WorldRange, b :: WorldRange)
- function intersect(p1::Padding, p2::Padding)
+ function intersect(p1 :: Padding, p2 :: Padding)
- function intersect(r1::AbstractRange, r2::AbstractRange)
+ function intersect(r1 :: AbstractRange, r2 :: AbstractRange)
- function intersect(r1::AbstractRange, r2::AbstractRange, r3::AbstractRange, r::AbstractRange...)
+ function intersect(r1 :: AbstractRange, r2 :: AbstractRange, r3 :: AbstractRange, r :: AbstractRange...)
- function intersect(r::AbstractUnitRange{<:Integer}, s::StepRange{<:Integer})
+ function intersect(r :: AbstractUnitRange{??? <: Integer}, s :: StepRange{??? <: Integer})
- function intersect(r::StepRange, s::StepRange)
+ function intersect(r :: StepRange, s :: StepRange)
- function intersect(r::StepRange{<:Integer}, s::AbstractUnitRange{<:Integer})
+ function intersect(r :: StepRange{??? <: Integer}, s :: AbstractUnitRange{??? <: Integer})
- function intersect(s::AbstractSet, itr)
+ function intersect(s :: AbstractSet, itr)
- function intersect(s::AbstractSet, itr, itrs...)
+ function intersect(s :: AbstractSet, itr, itrs...)
- function intersect(v::AbstractVector, r::AbstractRange)
+ function intersect(v :: AbstractVector, r :: AbstractRange)
- function intrinsic_effect_free_if_nothrow(@nospecialize f)
+ function intrinsic_effect_free_if_nothrow(f)
- function intrinsic_effects(f::IntrinsicFunction, argtypes::Vector{Any})
+ function intrinsic_effects(f :: IntrinsicFunction, argtypes :: Vector{Any})
- function intrinsic_nothrow(f::IntrinsicFunction, argtypes::Vector{Any})
+ function intrinsic_nothrow(f :: IntrinsicFunction, argtypes :: Vector{Any})
- function inv(A::AbstractMatrix{T}) where T
+ function inv(A :: AbstractMatrix{T}) where T
- function inv(A::StridedMatrix{T}) where T
+ function inv(A :: StridedMatrix{T}) where T
- function inv(B::Bidiagonal{T}) where T
+ function inv(B :: Bidiagonal{T}) where T
- function inv(B::BunchKaufman{<:BlasComplex,<:StridedMatrix})
+ function inv(B :: BunchKaufman{??? <: BlasComplex, ??? <: StridedMatrix})
- function inv(B::BunchKaufman{<:BlasReal,<:StridedMatrix})
+ function inv(B :: BunchKaufman{??? <: BlasReal, ??? <: StridedMatrix})
- function inv(C::CholeskyPivoted{<:BlasFloat,<:StridedMatrix})
+ function inv(C :: CholeskyPivoted{??? <: BlasFloat, ??? <: StridedMatrix})
- function inv(D::Diagonal{T}) where T
+ function inv(D :: Diagonal{T}) where T
- function inv(F::SVD{T}) where T
+ function inv(F :: SVD{T}) where T
- function inv(w::ComplexF64)
+ function inv(w :: ComplexF64)
- function inv(z::Complex)
+ function inv(z :: Complex)
- function inv(z::Complex{T}) where T<:Union{Float16,Float32}
+ function inv(z :: Complex{T}) where T <: Union{Float16, Float32}
- function invalid_tupleref()
+ function invalid_tupleref
- function invalid_usecase1(f, xs)
+ function invalid_usecase1(f, xs)
- function invalid_usecase2(f, xs)
+ function invalid_usecase2(f, xs)
- function invalidate_slotwrapper(vt::VarState, changeid::Int, ignore_conditional::Bool)
+ function invalidate_slotwrapper(vt :: VarState, changeid :: Int, ignore_conditional :: Bool)
- function invmod(n::Integer, m::Integer)
+ function invmod(n :: Integer, m :: Integer)
- function invmod(x::BigInt, y::BigInt)
+ function invmod(x :: BigInt, y :: BigInt)
- function invoke_in_world(world::UInt, @nospecialize(f), @nospecialize args...; kwargs...)
+ function invoke_in_world(world :: UInt, f, args..., kwargs...)
- function invoke_rewrite(xs::Vector{Any})
+ function invoke_rewrite(xs :: Vector{Any})
- function invoke_signature(argtypes::Vector{Any})
+ function invoke_signature(argtypes :: Vector{Any})
- function invperm(P::Tuple)
+ function invperm(P :: Tuple)
- function invperm(a::AbstractVector)
+ function invperm(a :: AbstractVector)
- function invperm(p::Union{Tuple{},Tuple{Int},Tuple{Int,Int}})
+ function invperm(p :: Union{Tuple, Tuple{Int}, Tuple{Int, Int}})
- function invsquaring(A0::UpperTriangular, theta)
+ function invsquaring(A0 :: UpperTriangular, theta)
- function io_has_tvar_name(io::IOContext, name::Symbol, @nospecialize(x))
+ function io_has_tvar_name(io :: IOContext, name :: Symbol, x)
- function ip_has_file_and_func(ip, file, funcs)
+ function ip_has_file_and_func(ip, file, funcs)
- function ip_matches_func(ip, func::Symbol)
+ function ip_matches_func(ip, func :: Symbol)
- function ipiv2perm(v::AbstractVector{T}, maxi::Integer) where T
+ function ipiv2perm(v :: AbstractVector{T}, maxi :: Integer) where T
- function ipo_dataflow_analysis!(interp::AbstractInterpreter, ir::IRCode, result::InferenceResult)
+ function ipo_dataflow_analysis!(interp :: AbstractInterpreter, ir :: IRCode, result :: InferenceResult)
- function ipv6_field(ip::IPv6,i)
+ function ipv6_field(ip :: IPv6, i)
- function ir_abstract_constant_propagation(interp::NativeInterpreter, irsv::IRInterpretationState)
+ function ir_abstract_constant_propagation(interp :: NativeInterpreter, irsv :: IRInterpretationState)
- function ir_to_codeinf!(opt::OptimizationState)
+ function ir_to_codeinf!(opt :: OptimizationState)
- function ir_to_codeinf!(src::CodeInfo, ir::IRCode)
+ function ir_to_codeinf!(src :: CodeInfo, ir :: IRCode)
- function iridx(@nospecialize(x), estate::EscapeState)
+ function iridx(x, estate :: EscapeState)
- function irrational(sym, val, def)
+ function irrational(sym, val, def)
- function irval(xidx::Int, estate::EscapeState)
+ function irval(xidx :: Int, estate :: EscapeState)
- function isTypeDataType(@nospecialize t)
+ function isTypeDataType(t)
- function is_all_const_arg(argtypes::Vector{Any}, start::Int)
+ function is_all_const_arg(argtypes :: Vector{Any}, start :: Int)
- function is_all_overridden(interp::AbstractInterpreter, (; fargs, argtypes)::ArgInfo, sv::AbsIntState)
+ function is_all_overridden(interp :: AbstractInterpreter, (;fargs,argtypes) :: ArgInfo, sv :: AbsIntState)
- function is_ancestor_of(a::AbstractString, b::AbstractString, repo::GitRepo)
+ function is_ancestor_of(a :: AbstractString, b :: AbstractString, repo :: GitRepo)
- function is_bb_empty(ir::IRCode, bb::BasicBlock)
+ function is_bb_empty(ir :: IRCode, bb :: BasicBlock)
- function is_block_end(data, i)
+ function is_block_end(data, i)
- function is_builtin(Lₒ::AbstractLattice, s::Signature)
+ function is_builtin(Lₒ :: AbstractLattice, s :: Signature)
- function is_call_graph_uncached(sv::CC.InferenceState)
+ function is_call_graph_uncached(sv :: CC.InferenceState)
- function is_conditional_noub(inst::Instruction, sv::PostOptAnalysisState)
+ function is_conditional_noub(inst :: Instruction, sv :: PostOptAnalysisState)
- function is_const_prop_profitable_conditional(cnd::Conditional, fargs::Vector{Any}, sv::InferenceState)
+ function is_const_prop_profitable_conditional(cnd :: Conditional, fargs :: Vector{Any}, sv :: InferenceState)
- function is_constprop_edge_recursed(edge::MethodInstance, caller::AbsIntState)
+ function is_constprop_edge_recursed(edge :: MethodInstance, caller :: AbsIntState)
- function is_constprop_method_recursed(method::Method, caller::AbsIntState)
+ function is_constprop_method_recursed(method :: Method, caller :: AbsIntState)
- function is_constprop_recursed(result::MethodCallResult, mi::MethodInstance, sv::AbsIntState)
+ function is_constprop_recursed(result :: MethodCallResult, mi :: MethodInstance, sv :: AbsIntState)
- function is_derived_type(@nospecialize(t), @nospecialize(c), mindepth::Int)
+ function is_derived_type(t, c, mindepth :: Int)
- function is_derived_type_from_any(@nospecialize(t), sources::SimpleVector, mindepth::Int)
+ function is_derived_type_from_any(t, sources :: SimpleVector, mindepth :: Int)
- function is_edge_recursed(edge::MethodInstance, caller::AbsIntState)
+ function is_edge_recursed(edge :: MethodInstance, caller :: AbsIntState)
- function is_effect_overridden(linfo::MethodInstance, effect::Symbol)
+ function is_effect_overridden(linfo :: MethodInstance, effect :: Symbol)
- function is_expected_union(u::Union)
+ function is_expected_union(u :: Union)
- function is_exported_from_stdlib(name::Symbol, mod::Module)
+ function is_exported_from_stdlib(name :: Symbol, mod :: Module)
- function is_file_tracked(file::Symbol)
+ function is_file_tracked(file :: Symbol)
- function is_getfield_captures(@nospecialize(def), compact::IncrementalCompact, Lₒ::AbstractLattice)
+ function is_getfield_captures(def, compact :: IncrementalCompact, Lₒ :: AbstractLattice)
- function is_getfield_with_boundscheck_arg(@nospecialize(stmt), sv::PostOptAnalysisState)
+ function is_getfield_with_boundscheck_arg(stmt, sv :: PostOptAnalysisState)
- function is_global_function(tn::Core.TypeName, globname::Union{Symbol,Nothing})
+ function is_global_function(tn :: Core.TypeName, globname :: Union{Symbol, Nothing})
- function is_in_mods(m::Module, recursive::Bool, mods)
+ function is_in_mods(m :: Module, recursive :: Bool, mods)
- function is_inline_checker(@nospecialize stmt)
+ function is_inline_checker(stmt)
- function is_inlineable_constant(@nospecialize(x))
+ function is_inlineable_constant(x)
- function is_ipo_dataflow_analysis_profitable(effects::Effects)
+ function is_ipo_dataflow_analysis_profitable(effects :: Effects)
- function is_known_call(@nospecialize(x), @nospecialize(func), ir::Union{IRCode,IncrementalCompact})
+ function is_known_call(x, func, ir :: Union{IRCode, IncrementalCompact})
- function is_legal_bb_drop(ir::IRCode, bbidx::Int, bb::BasicBlock)
+ function is_legal_bb_drop(ir :: IRCode, bbidx :: Int, bb :: BasicBlock)
- function is_load_forwardable(x::EscapeInfo)
+ function is_load_forwardable(x :: EscapeInfo)
- function is_load_forwarded(@nospecialize(T), src::CodeInfo)
+ function is_load_forwarded(T, src :: CodeInfo)
- function is_method_recursed(method::Method, caller::AbsIntState)
+ function is_method_recursed(method :: Method, caller :: AbsIntState)
- function is_nonverbose_env(k::String)
+ function is_nonverbose_env(k :: String)
- function is_old(compact, @nospecialize(old_node_ssa))
+ function is_old(compact, old_node_ssa)
- function is_parent(dfs_tree::DFSTree, x::BBNumber, y::BBNumber)
+ function is_parent(dfs_tree :: DFSTree, x :: BBNumber, y :: BBNumber)
- function is_passphrase_required(private_key::AbstractString)
+ function is_passphrase_required(private_key :: AbstractString)
- function is_pending(compact::IncrementalCompact, old::OldSSAValue)
+ function is_pending(compact :: IncrementalCompact, old :: OldSSAValue)
- function is_pop_loc(ex::Expr)
+ function is_pop_loc(ex :: Expr)
- function is_pure_intrinsic_infer(f::IntrinsicFunction)
+ function is_pure_intrinsic_infer(f :: IntrinsicFunction)
- function is_relevant_expr(e::Expr)
+ function is_relevant_expr(e :: Expr)
- function is_repl_frame_getproperty(sv::CC.InferenceState)
+ function is_repl_frame_getproperty(sv :: CC.InferenceState)
- function is_result_constabi_eligible(result::InferenceResult)
+ function is_result_constabi_eligible(result :: InferenceResult)
- function is_return_ssavalue(ex)
+ function is_return_ssavalue(ex)
- function is_same_frame(interp::AbstractInterpreter, mi::MethodInstance, frame::InferenceState)
+ function is_same_frame(interp :: AbstractInterpreter, mi :: MethodInstance, frame :: InferenceState)
- function is_scalar_replaced(@nospecialize(T), src::CodeInfo)
+ function is_scalar_replaced(T, src :: CodeInfo)
- function is_self_quoting(@nospecialize(x))
+ function is_self_quoting(x)
- function is_short_function_def(@nospecialize(ex))
+ function is_short_function_def(ex)
- function is_some_union(@nospecialize(t))
+ function is_some_union(t)
- function is_throw_call(e::Expr)
+ function is_throw_call(e :: Expr)
- function is_top_bit_set(x)
+ function is_top_bit_set(x)
- function is_top_bit_set(x::Union{Int8,UInt8})
+ function is_top_bit_set(x :: Union{Int8, UInt8})
- function is_typed_expr(e::Expr)
+ function is_typed_expr(e :: Expr)
- function is_undefref_fieldtype(@nospecialize ftyp)
+ function is_undefref_fieldtype(ftyp)
- function is_union_phi(compact::IncrementalCompact, idx::Int)
+ function is_union_phi(compact :: IncrementalCompact, idx :: Int)
- function is_v1_format_manifest(raw_manifest::Dict{String})
+ function is_v1_format_manifest(raw_manifest :: Dict{String})
- function is_valid_argument(@nospecialize(x))
+ function is_valid_argument(x)
- function is_valid_identifier(sym)
+ function is_valid_identifier(sym)
- function is_valid_phiblock_stmt(@nospecialize(stmt))
+ function is_valid_phiblock_stmt(stmt)
- function is_valid_rvalue(@nospecialize(x))
+ function is_valid_rvalue(x)
- function is_valid_type_for_apply_rewrite(@nospecialize(typ), params::OptimizationParams)
+ function is_valid_type_for_apply_rewrite(typ, params :: OptimizationParams)
- function is_verbose_env(k::String)
+ function is_verbose_env(k :: String)
- function isa_kindtype(T::Type{<:AbstractVector})
+ function isa_kindtype(T :: Type{??? <: AbstractVector})
- function isabstracttype(@nospecialize(t))
+ function isabstracttype(t)
- function isaccessibledir(dir)
+ function isaccessibledir(dir)
- function isaccessiblefile(file)
+ function isaccessiblefile(file)
- function isaccessiblepath(path)
+ function isaccessiblepath(path)
- function isambiguous(m1::Method, m2::Method; ambiguous_bottom::Bool=false)
+ function isambiguous(m1 :: Method, m2 :: Method, ambiguous_bottom :: Bool = false)
- function isascii(cu::AbstractVector{CU}) where {CU <: Integer}
+ function isascii(cu :: AbstractVector{CU}) where CU <: Integer
- function isassigned(A::AbstractArray, i::Union{Integer, CartesianIndex}...)
+ function isassigned(A :: AbstractArray, i :: Union{Integer, CartesianIndex}...)
- function isassigned(V::FastContiguousSubArray, i::Int)
+ function isassigned(V :: FastContiguousSubArray, i :: Int)
- function isassigned(V::FastContiguousSubArray{<:Any, 1}, i::Int)
+ function isassigned(V :: FastContiguousSubArray{??? <: Any, DependentType@119d7047}, i :: Int)
- function isassigned(V::FastSubArray, i::Int)
+ function isassigned(V :: FastSubArray, i :: Int)
- function isassigned(V::FastSubArray{<:Any, 1}, i::Int)
+ function isassigned(V :: FastSubArray{??? <: Any, DependentType@776ec8df}, i :: Int)
- function isassigned(V::SubArray{T,N}, I::Vararg{Int,N}) where {T,N}
+ function isassigned(V :: SubArray{T, N}, I :: Vararg{Int, N}) where T, N
- function isassigned(a::Array, i::Int...)
+ function isassigned(a :: Array, i :: Int...)
- function isassigned(a::Memory, i::Int)
+ function isassigned(a :: Memory, i :: Int)
- function isassigned(a::Vector, i::Int)
+ function isassigned(a :: Vector, i :: Int)
- function isassigned(r::AbstractRange, i::Integer)
+ function isassigned(r :: AbstractRange, i :: Integer)
- function isassigned(v::SimpleVector, i::Int)
+ function isassigned(v :: SimpleVector, i :: Int)
- function isattached(repo::GitRepo)
+ function isattached(repo :: GitRepo)
- function isbare(repo::GitRepo)
+ function isbare(repo :: GitRepo)
- function isbinary(blob::GitBlob)
+ function isbinary(blob :: GitBlob)
- function isbinaryoperator(s::Symbol)
+ function isbinaryoperator(s :: Symbol)
- function isbranch(ref::GitReference)
+ function isbranch(ref :: GitReference)
- function iscall((src, f)::Tuple{IR,Base.Callable}, @nospecialize(x)) where IR<:Union{CodeInfo,IRCode,IncrementalCompact}
+ function iscall((src,f) :: Tuple{IR, Base.Callable}, x) where IR <: Union{CodeInfo, IRCode, IncrementalCompact}
- function iscall(pred::Base.Callable, @nospecialize(x))
+ function iscall(pred :: Base.Callable, x)
- function iscased(c::AbstractChar)
+ function iscased(c :: AbstractChar)
- function iscommit(id::AbstractString, repo::GitRepo)
+ function iscommit(id :: AbstractString, repo :: GitRepo)
- function isconst(@nospecialize(t::Type), s::Int)
+ function isconst(t :: Type, s :: Int)
- function isconst(@nospecialize(t::Type), s::Symbol)
+ function isconst(t :: Type, s :: Symbol)
- function isconst(g::GlobalRef)
+ function isconst(g :: GlobalRef)
- function isdebugbuild()
+ function isdebugbuild
- function isdefined_effects(L::AbstractLattice, argtypes::Vector{Any})
+ function isdefined_effects(L :: AbstractLattice, argtypes :: Vector{Any})
- function isdefined_elim()
+ function isdefined_elim
- function isdefined_globalref(g::GlobalRef)
+ function isdefined_globalref(g :: GlobalRef)
- function isdefined_nothrow(L::AbstractLattice, argtypes::Vector{Any})
+ function isdefined_nothrow(L :: AbstractLattice, argtypes :: Vector{Any})
- function isdiff(repo::GitRepo, treeish::AbstractString, paths::AbstractString=""; cached::Bool=false)
+ function isdiff(repo :: GitRepo, treeish :: AbstractString, paths :: AbstractString = "", cached :: Bool = false)
- function isdisjoint(a, b)
+ function isdisjoint(a, b)
- function isdisjoint(a::AbstractRange{T}, b::AbstractRange{T}) where T
+ function isdisjoint(a :: AbstractRange{T}, b :: AbstractRange{T}) where T
- function isdispatchelem(@nospecialize v)
+ function isdispatchelem(v)
- function isempty(bsbmp::BitSetBoundedMinPrioritySet)
+ function isempty(bsbmp :: BitSetBoundedMinPrioritySet)
- function isempty(itr)
+ function isempty(itr)
- function isempty(trie::HAMT)
+ function isempty(trie :: HAMT)
- function isempty_timeout(c::Channel)
+ function isempty_timeout(c :: Channel)
- function isequal(A::AbstractArray, B::AbstractArray)
+ function isequal(A :: AbstractArray, B :: AbstractArray)
- function isequal(l::AbstractDict, r::AbstractDict)
+ function isequal(l :: AbstractDict, r :: AbstractDict)
- function isequal_normalized(s1::AbstractString, s2::AbstractString; casefold::Bool=false, stripmark::Bool=false, chartransform=identity)
+ function isequal_normalized(s1 :: AbstractString, s2 :: AbstractString, casefold :: Bool = false, stripmark :: Bool = false, chartransform = identity)
- function isexecutable(path::String)
+ function isexecutable(path :: String)
- function isfieldatomic(@nospecialize(t::Type), s::Int)
+ function isfieldatomic(t :: Type, s :: Int)
- function isfieldatomic(@nospecialize(t::Type), s::Symbol)
+ function isfieldatomic(t :: Type, s :: Symbol)
- function isfile_casesensitive(path)
+ function isfile_casesensitive(path)
- function isfilled(cred::GitCredential)
+ function isfilled(cred :: GitCredential)
- function isfilled(cred::SSHCredential)
+ function isfilled(cred :: SSHCredential)
- function isfilled(cred::UserPasswordCredential)
+ function isfilled(cred :: UserPasswordCredential)
- function isgraphemebreak!(state::Ref{Int32}, c1::AbstractChar, c2::AbstractChar)
+ function isgraphemebreak!(state :: Ref{Int32}, c1 :: AbstractChar, c2 :: AbstractChar)
- function ishead(ref::GitReference)
+ function ishead(ref :: GitReference)
- function ishermitian(A::AbstractMatrix)
+ function ishermitian(A :: AbstractMatrix)
- function isidentifier(s::AbstractString)
+ function isidentifier(s :: AbstractString)
- function isidentityfree(@nospecialize(t))
+ function isidentityfree(t)
- function isinf(x::BigFloat)
+ function isinf(x :: BigFloat)
- function isinteger(x::BigFloat)
+ function isinteger(x :: BigFloat)
- function isiterable(T)::Bool
+ function isiterable(T)
- function isknownlength(t::DataType)
+ function isknownlength(t :: DataType)
- function isless(a::VersionNumber, b::VersionNumber)
+ function isless(a :: VersionNumber, b :: VersionNumber)
- function isless(t1::Any32, t2::Any32)
+ function isless(t1 :: Any32, t2 :: Any32)
- function isless(t1::Tuple, t2::Tuple)
+ function isless(t1 :: Tuple, t2 :: Tuple)
- function islinklocaladdr(addr::IPv4)
+ function islinklocaladdr(addr :: IPv4)
- function islinklocaladdr(addr::IPv6)
+ function islinklocaladdr(addr :: IPv6)
- function islocked(l::SpinLock)
+ function islocked(l :: SpinLock)
- function islocked(rl::ReentrantLock)
+ function islocked(rl :: ReentrantLock)
- function ismalformed(c::Char)
+ function ismalformed(c :: Char)
- function ismatch(url::AbstractString, git_cred::GitCredential)
+ function ismatch(url :: AbstractString, git_cred :: GitCredential)
- function ismodulecall(ex::Expr)
+ function ismodulecall(ex :: Expr)
- function ismount(path...)
+ function ismount(path...)
- function ismutabletype(@nospecialize t)
+ function ismutabletype(t)
- function ismutationfree(@nospecialize(t))
+ function ismutationfree(t)
- function isnan(x::BigFloat)
+ function isnan(x :: BigFloat)
- function isnan_type(::Type{T}, x) where T
+ function isnan_type(??? :: Type{T}, x) where T
- function iso_datetime_with_relative(t, tnow)
+ function iso_datetime_with_relative(t, tnow)
- function isone(A::AbstractMatrix)
+ function isone(A :: AbstractMatrix)
- function isopen(x::Union{LibuvStream, LibuvServer})
+ function isopen(x :: Union{LibuvStream, LibuvServer})
- function isorphan(repo::GitRepo)
+ function isorphan(repo :: GitRepo)
- function isoverlong(c::Char)
+ function isoverlong(c :: Char)
- function isperm(P::Tuple)
+ function isperm(P :: Tuple)
- function ispostfixoperator(s::Union{Symbol,AbstractString})
+ function ispostfixoperator(s :: Union{Symbol, AbstractString})
- function ispreserved(@nospecialize(x))
+ function ispreserved(x)
- function isprimitivetype(@nospecialize t)
+ function isprimitivetype(t)
- function isqrt(x::Union{Int64,UInt64,Int128,UInt128})
+ function isqrt(x :: Union{Int64, UInt64, Int128, UInt128})
- function isreadable(io::LibuvStream)
+ function isreadable(io :: LibuvStream)
- function isremote(ref::GitReference)
+ function isremote(ref :: GitReference)
- function issetequal(a, b)
+ function issetequal(a, b)
- function issetequal(a, b::AbstractSet)
+ function issetequal(a, b :: AbstractSet)
- function issimple(@nospecialize val)
+ function issimple(val)
- function issimpleenoughtype(@nospecialize t)
+ function issimpleenoughtype(t)
- function issimplekw(@nospecialize val)
+ function issimplekw(val)
- function issorted(itr, order::Ordering)
+ function issorted(itr, order :: Ordering)
- function isstored(A::AbstractArray{<:Any,N}, I::Vararg{Integer,N}) where {N}
+ function isstored(A :: AbstractArray{??? <: Any, N}, I :: Vararg{Integer, N}) where N
- function isstructtype(@nospecialize t)
+ function isstructtype(t)
- function isstructurepreserving(::typeof(Base.literal_pow), ::Ref{typeof(^)}, ::StructuredMatrix, ::Ref{Val{N}}) where N
+ function isstructurepreserving(??? :: typeof(Base.literal_pow), ??? :: Ref{typeof(^)}, ??? :: StructuredMatrix, ??? :: Ref{Val{N}}) where N
- function issubalias(a::AnyMustAlias, b::AnyMustAlias)
+ function issubalias(a :: AnyMustAlias, b :: AnyMustAlias)
- function issubnormal(x::T) where {T<:IEEEFloat}
+ function issubnormal(x :: T) where T <: IEEEFloat
- function issubset(a, b)
+ function issubset(a, b)
- function issubset(a::BitSet, b::BitSet)
+ function issubset(a :: BitSet, b :: BitSet)
- function issue22582!(a::AbstractArray, b)
+ function issue22582!(a :: AbstractArray, b)
- function issue44732(c::Container44732)
+ function issue44732(c :: Container44732)
- function issue47435()
+ function issue47435
- function issue48067(a::Int, b)
+ function issue48067(a :: Int, b)
- function issue49027(::Type{<:Issue49027{Ty}}) where Ty
+ function issue49027(??? :: Type{??? <: Issue49027{Ty}}) where Ty
- function issue49027_integer(::Type{<:Issue49027{Ty}}) where Ty<:Integer
+ function issue49027_integer(??? :: Type{??? <: Issue49027{Ty}}) where Ty <: Integer
- function issue51548(T, a)
+ function issue51548(T, a)
- function issue51837(; openquotechar::Char, newlinechar::Char)
+ function issue51837(openquotechar :: Char, newlinechar :: Char)
- function issue7897!(data, arr)
+ function issue7897!(data, arr)
- function issymmetric(A::AbstractMatrix)
+ function issymmetric(A :: AbstractMatrix)
- function istag(ref::GitReference)
+ function istag(ref :: GitReference)
- function istopfunction(@nospecialize(f), name::Symbol)
+ function istopfunction(f, name :: Symbol)
- function istril(A::AbstractMatrix, k::Integer = 0)
+ function istril(A :: AbstractMatrix, k :: Integer = 0)
- function istril(A::BitMatrix)
+ function istril(A :: BitMatrix)
- function istril(A::Union{LowerTriangular,UnitLowerTriangular}, k::Integer=0)
+ function istril(A :: Union{LowerTriangular, UnitLowerTriangular}, k :: Integer = 0)
- function istril(M::Bidiagonal, k::Integer=0)
+ function istril(M :: Bidiagonal, k :: Integer = 0)
- function istril(M::Tridiagonal, k::Integer=0)
+ function istril(M :: Tridiagonal, k :: Integer = 0)
- function istriu(A::AbstractMatrix, k::Integer = 0)
+ function istriu(A :: AbstractMatrix, k :: Integer = 0)
- function istriu(A::BitMatrix)
+ function istriu(A :: BitMatrix)
- function istriu(A::Union{UpperTriangular,UnitUpperTriangular}, k::Integer=0)
+ function istriu(A :: Union{UpperTriangular, UnitUpperTriangular}, k :: Integer = 0)
- function istriu(A::UpperHessenberg, k::Integer=0)
+ function istriu(A :: UpperHessenberg, k :: Integer = 0)
- function istriu(M::Bidiagonal, k::Integer=0)
+ function istriu(M :: Bidiagonal, k :: Integer = 0)
- function istriu(M::SymTridiagonal, k::Integer=0)
+ function istriu(M :: SymTridiagonal, k :: Integer = 0)
- function istriu(M::Tridiagonal, k::Integer=0)
+ function istriu(M :: Tridiagonal, k :: Integer = 0)
- function isunix(os::Symbol)
+ function isunix(os :: Symbol)
- function isvalid(s::SubString, i::Integer)
+ function isvalid(s :: SubString, i :: Integer)
- function isvalid_cache_header(f::IOStream)
+ function isvalid_cache_header(f :: IOStream)
- function isvalid_pkgimage_crc(f::IOStream, ocachefile::String)
+ function isvalid_pkgimage_crc(f :: IOStream, ocachefile :: String)
- function isvalidpid(hostname::AbstractString, pid::Cuint)
+ function isvalidpid(hostname :: AbstractString, pid :: Cuint)
- function isvarargtype(@nospecialize(t))
+ function isvarargtype(t)
- function isvatuple(@nospecialize(t))
+ function isvatuple(t)
- function isvisible(sym::Symbol, parent::Module, from::Module)
+ function isvisible(sym :: Symbol, parent :: Module, from :: Module)
- function iswritable(io::LibuvStream)
+ function iswritable(io :: LibuvStream)
- function iszero(id::GitHash)
+ function iszero(id :: GitHash)
- function itask()
+ function itask
- function iterate(::EnvDict, i=0)
+ function iterate(??? :: EnvDict, i = 0)
- function iterate(@nospecialize(t::Tuple), i::Int=1)
+ function iterate(t :: Tuple, i :: Int = 1)
- function iterate(A::AbstractArray, state=(eachindex(A),))
+ function iterate(A :: AbstractArray, state = (eachindex(A),))
- function iterate(A::Reverse, state=(reverse(eachindex(A.itr)),))
+ function iterate(A :: Reverse, state = (reverse(eachindex(A.itr)),))
- function iterate(B::BitArray, i::Int=0)
+ function iterate(B :: BitArray, i :: Int = 0)
- function iterate(I::ANSIIterator, (i, m_st)=(1, iterate(I.captures)))
+ function iterate(I :: ANSIIterator, (i,m_st) = (1,iterate(I.captures)))
- function iterate(c::Channel, state=nothing)
+ function iterate(c :: Channel, state = nothing)
- function iterate(cp::CyclePadding)
+ function iterate(cp :: CyclePadding)
- function iterate(cp::CyclePadding, state::Tuple)
+ function iterate(cp :: CyclePadding, state :: Tuple)
- function iterate(d::IdDict{K,V}, idx=0) where {K, V}
+ function iterate(d :: IdDict{K, V}, idx = 0) where K, V
- function iterate(d::ImmutableDict{K,V}, t=d) where {K, V}
+ function iterate(d :: ImmutableDict{K, V}, t = d) where K, V
- function iterate(doms::DominatedBlocks, state::Nothing=nothing)
+ function iterate(doms :: DominatedBlocks, state :: Nothing = nothing)
- function iterate(ebo::ExponentialBackOff, state= (ebo.n, min(ebo.first_delay, ebo.max_delay)))
+ function iterate(ebo :: ExponentialBackOff, state = (ebo.n,min(ebo.first_delay,ebo.max_delay)))
- function iterate(f::Filter, state...)
+ function iterate(f :: Filter, state...)
- function iterate(g::Generator, s...)
+ function iterate(g :: Generator, s...)
- function iterate(g::GraphemeIterator, i_=(Int32(0),firstindex(g.s)))
+ function iterate(g :: GraphemeIterator, i_ = (Int32(0),firstindex(g.s)))
- function iterate(hash::EnvDict, block::Tuple{Ptr{UInt16},Ptr{UInt16}} = GESW())
+ function iterate(hash :: EnvDict, block :: Tuple{Ptr{UInt16}, Ptr{UInt16}} = GESW())
- function iterate(ibl::DropWhile)
+ function iterate(ibl :: DropWhile)
- function iterate(ibl::TakeWhile, itr...)
+ function iterate(ibl :: TakeWhile, itr...)
- function iterate(it::CompactPeekIterator, (idx, aidx, bidx)::NTuple{3, Int}=(it.start_idx, it.compact.new_nodes_idx, 1))
+ function iterate(it :: CompactPeekIterator, (idx,aidx,bidx) :: NTuple{DependentType@4eec7777, Int} = (it.start_idx,it.compact.new_nodes_idx,1))
- function iterate(it::Cycle, state)
+ function iterate(it :: Cycle, state)
- function iterate(it::Drop)
+ function iterate(it :: Drop)
- function iterate(iter::BackedgeIterator, i::Int=1)
+ function iterate(iter :: BackedgeIterator, i :: Int = 1)
- function iterate(iter::SCartesianIndices2{K}) where {K}
+ function iterate(iter :: SCartesianIndices2{K}) where K
- function iterate(iter::SCartesianIndices2{K}, (state1, item2, state2)) where {K}
+ function iterate(iter :: SCartesianIndices2{K}, (state1,item2,state2)) where K
- function iterate(iter::SplitIterator, (i, k, n)=(firstindex(iter.str), firstindex(iter.str), 0))
+ function iterate(iter :: SplitIterator, (i,k,n) = (firstindex(iter.str),firstindex(iter.str),0))
- function iterate(itr::Accumulate)
+ function iterate(itr :: Accumulate)
- function iterate(itr::Accumulate, state)
+ function iterate(itr :: Accumulate, state)
- function iterate(itr::AsyncCollector)
+ function iterate(itr :: AsyncCollector)
- function iterate(itr::AsyncCollector, state::AsyncCollectorState)
+ function iterate(itr :: AsyncCollector, state :: AsyncCollectorState)
- function iterate(itr::AsyncGenerator, state::AsyncGeneratorState=AsyncGeneratorState(0))
+ function iterate(itr :: AsyncGenerator, state :: AsyncGeneratorState = AsyncGeneratorState(0))
- function iterate(itr::EachLine, state=nothing)
+ function iterate(itr :: EachLine, state = nothing)
- function iterate(itr::PartitionIterator, state...)
+ function iterate(itr :: PartitionIterator, state...)
- function iterate(itr::PartitionIterator{<:AbstractArray}, state = firstindex(itr.c))
+ function iterate(itr :: PartitionIterator{??? <: AbstractArray}, state = firstindex(itr.c))
- function iterate(itr::PartitionIterator{<:AbstractRange}, state = firstindex(itr.c))
+ function iterate(itr :: PartitionIterator{??? <: AbstractRange}, state = firstindex(itr.c))
- function iterate(itr::PartitionIterator{<:AbstractString}, state = firstindex(itr.c))
+ function iterate(itr :: PartitionIterator{??? <: AbstractString}, state = firstindex(itr.c))
- function iterate(itr::RegexMatchIterator, (offset,prevempty)=(1,false))
+ function iterate(itr :: RegexMatchIterator, (offset,prevempty) = (1,false))
- function iterate(itr::SkipMissing, state...)
+ function iterate(itr :: SkipMissing, state...)
- function iterate(r::Iterators.Reverse{<:EachLine})
+ function iterate(r :: Iterators.Reverse{??? <: EachLine})
- function iterate(r::Iterators.Reverse{<:EachLine}, state)
+ function iterate(r :: Iterators.Reverse{??? <: EachLine}, state)
- function iterate(r::OrdinalRange{T}, i) where {T}
+ function iterate(r :: OrdinalRange{T}, i) where T
- function iterate(r::Union{StepRangeLen,LinRange}, i::Integer=zero(length(r)))
+ function iterate(r :: Union{StepRangeLen, LinRange}, i :: Integer = zero(length(r)))
- function iterate(result::MethodLookupResult, args...)
+ function iterate(result :: MethodLookupResult, args...)
- function iterate(s::BitSet, (word, idx) = (CHK0, 0))
+ function iterate(s :: BitSet, (word,idx) = (CHK0,0))
- function iterate(s::IdSet, state...)
+ function iterate(s :: IdSet, state...)
- function iterate(s::SubString, i::Integer=firstindex(s))
+ function iterate(s :: SubString, i :: Integer = firstindex(s))
- function iterate(specs::MethodSpecializations)
+ function iterate(specs :: MethodSpecializations)
- function iterate(specs::MethodSpecializations, i::Int)
+ function iterate(specs :: MethodSpecializations, i :: Int)
- function iterate(t::WeakKeyDict{K,V}, state...) where {K, V}
+ function iterate(t :: WeakKeyDict{K, V}, state...) where K, V
- function iterate(trie::HAMT, state=nothing)
+ function iterate(trie :: HAMT, state = nothing)
- function iterate(unw::AbsIntStackUnwind, (sv, cyclei)::Tuple{AbsIntState, Int})
+ function iterate(unw :: AbsIntStackUnwind, (sv,cyclei) :: Tuple{AbsIntState, Int})
- function iterate(v::Union{KeySet,ValueIterator}, state...)
+ function iterate(v :: Union{KeySet, ValueIterator}, state...)
- function iterate(x::BBIdxIter, (idx, bb)::Tuple{Int, Int}=(1, 1))
+ function iterate(x :: BBIdxIter, (idx,bb) :: Tuple{Int, Int} = (1,1))
- function iterate_compact(compact::IncrementalCompact)
+ function iterate_compact(compact :: IncrementalCompact)
- function iterate_continued(s, i::Int, u::UInt32)
+ function iterate_continued(s, i :: Int, u :: UInt32)
- function iterate_elements(iter)
+ function iterate_elements(iter)
- function iterate_length(iter)
+ function iterate_length(iter)
- function iterate_read(arr)
+ function iterate_read(arr)
- function iterate_write!(arr)
+ function iterate_write!(arr)
- function iterate_write(arr, out)
+ function iterate_write(arr, out)
- function iterated_dominance_frontier(cfg::CFG, liveness::BlockLiveness, domtree::DomTree)
+ function iterated_dominance_frontier(cfg :: CFG, liveness :: BlockLiveness, domtree :: DomTree)
- function iterlength(it)::Signed
+ function iterlength(it)
- function ith_all(i, as)
+ function ith_all(i, as)
- function jit_compile(regex::Ptr{Cvoid})
+ function jit_compile(regex :: Ptr{Cvoid})
- function jit_total_bytes()
+ function jit_total_bytes
- function jitter_channel(f, k, delay, ntasks, schedule)
+ function jitter_channel(f, k, delay, ntasks, schedule)
- function join(io::IO, iterator, delim, last)
+ function join(io :: IO, iterator, delim, last)
- function join(io::IO, iterator, delim="")
+ function join(io :: IO, iterator, delim = "")
- function join_annotated(iterator, delim="", last=delim)
+ function join_annotated(iterator, delim = "", last = delim)
- function joinpath(paths::Union{Tuple, AbstractVector})::String
+ function joinpath(paths :: Union{Tuple, AbstractVector})
- function jointail(dir, tail)
+ function jointail(dir, tail)
- function jsn2data(jsn)
+ function jsn2data(jsn)
- function julia_cmd(julia=joinpath(Sys.BINDIR, julia_exename()); cpu_target::Union{Nothing,String} = nothing)
+ function julia_cmd(julia = joinpath(Sys.BINDIR,julia_exename()), cpu_target :: Union{Nothing, String} = nothing)
- function julia_exename()
+ function julia_exename
- function julian2datetime(f)
+ function julian2datetime(f)
- function jump(r::MersenneTwister, steps::Integer)
+ function jump(r :: MersenneTwister, steps :: Integer)
- function just_fixup!(compact::IncrementalCompact, new_new_nodes_offset::Union{Int, Nothing} = nothing, late_fixup_offset::Union{Int, Nothing} = nothing)
+ function just_fixup!(compact :: IncrementalCompact, new_new_nodes_offset :: Union{Int, Nothing} = nothing, late_fixup_offset :: Union{Int, Nothing} = nothing)
- function k1(a)
+ function k1(a)
- function k17449(r, v)
+ function k17449(r, v)
- function kernel()
+ function kernel
- function keymap(keymaps::Union{Vector{AnyDict},Vector{Dict{Char,Any}}})
+ function keymap(keymaps :: Union{Vector{AnyDict}, Vector{Dict{Char, Any}}})
- function keymap_fcn(keymaps)
+ function keymap_fcn(keymaps)
- function keymap_merge!(target::Dict{Char,Any}, source::Union{Dict{Char,Any},AnyDict})
+ function keymap_merge!(target :: Dict{Char, Any}, source :: Union{Dict{Char, Any}, AnyDict})
- function keymap_merge(target::Dict{Char,Any}, source::Union{Dict{Char,Any},AnyDict})
+ function keymap_merge(target :: Dict{Char, Any}, source :: Union{Dict{Char, Any}, AnyDict})
- function keymap_unify(keymaps)
+ function keymap_unify(keymaps)
- function keypress(m::RadioMenu, i::UInt32)
+ function keypress(m :: RadioMenu, i :: UInt32)
- function keypress(menu::MultiSelectMenu, key::UInt32)
+ function keypress(menu :: MultiSelectMenu, key :: UInt32)
- function keys(m::RegexMatch)
+ function keys(m :: RegexMatch)
- function keys(t::Tuple, t2::Tuple...)
+ function keys(t :: Tuple, t2 :: Tuple...)
- function keyworddoc(__source__, __module__, str, def::Base.BaseDocs.Keyword)
+ function keyworddoc(__source__, __module__, str, def :: Base.BaseDocs.Keyword)
- function kill(p::Process, signum::Integer=SIGTERM)
+ function kill(p :: Process, signum :: Integer = SIGTERM)
- function kill_current_use!(compact::IncrementalCompact, @nospecialize(val))
+ function kill_current_use!(compact :: IncrementalCompact, val)
- function kill_current_uses!(compact::IncrementalCompact, @nospecialize(stmt))
+ function kill_current_uses!(compact :: IncrementalCompact, stmt)
- function kill_def_use!(tpdum::TwoPhaseDefUseMap, def::Int, use::Int)
+ function kill_def_use!(tpdum :: TwoPhaseDefUseMap, def :: Int, use :: Int)
- function kill_edge!(bbs::Vector{BasicBlock}, from::Int, to::Int, callback=nothing)
+ function kill_edge!(bbs :: Vector{BasicBlock}, from :: Int, to :: Int, callback = nothing)
- function kill_edge!(compact::IncrementalCompact, active_bb::Int, from::Int, to::Int)
+ function kill_edge!(compact :: IncrementalCompact, active_bb :: Int, from :: Int, to :: Int)
- function kill_edge!(ir::IRCode, from::Int, to::Int, callback=nothing)
+ function kill_edge!(ir :: IRCode, from :: Int, to :: Int, callback = nothing)
- function kill_terminator_edges!(irsv::IRInterpretationState, term_idx::Int, bb::Int=block_for_inst(irsv.ir, term_idx))
+ function kill_terminator_edges!(irsv :: IRInterpretationState, term_idx :: Int, bb :: Int = block_for_inst(irsv.ir,term_idx))
- function kill_test(t)
+ function kill_test(t)
- function kill_timer(delay)
+ function kill_timer(delay)
- function killjob(d)
+ function killjob(d)
- function kron!(C::AbstractVecOrMat, A::AbstractVecOrMat, B::AbstractVecOrMat)
+ function kron!(C :: AbstractVecOrMat, A :: AbstractVecOrMat, B :: AbstractVecOrMat)
- function kron!(R::BitMatrix, a::BitMatrix, b::BitMatrix)
+ function kron!(R :: BitMatrix, a :: BitMatrix, b :: BitMatrix)
- function kron!(c::AbstractVector, a::AbstractVector, b::AbstractVector)
+ function kron!(c :: AbstractVector, a :: AbstractVector, b :: AbstractVector)
- function kron(A::AbstractVecOrMat{T}, B::AbstractVecOrMat{S}) where {T,S}
+ function kron(A :: AbstractVecOrMat{T}, B :: AbstractVecOrMat{S}) where T, S
- function kron(A::Diagonal, B::Bidiagonal)
+ function kron(A :: Diagonal, B :: Bidiagonal)
- function kron(A::Diagonal, B::SymTridiagonal)
+ function kron(A :: Diagonal, B :: SymTridiagonal)
- function kron(A::Diagonal, B::Tridiagonal)
+ function kron(A :: Diagonal, B :: Tridiagonal)
- function kron(a::AbstractVector{T}, b::AbstractVector{S}) where {T,S}
+ function kron(a :: AbstractVector{T}, b :: AbstractVector{S}) where T, S
- function kron(a::BitMatrix, b::BitMatrix)
+ function kron(a :: BitMatrix, b :: BitMatrix)
- function kron(a::BitVector, b::BitVector)
+ function kron(a :: BitVector, b :: BitVector)
- function kwarg_decl(m::Method, kwtype = nothing)
+ function kwarg_decl(m :: Method, kwtype = nothing)
- function kwerr(kw, args::Vararg{Any,N}) where {N}
+ function kwerr(kw, args :: Vararg{Any, N}) where N
- function kwf_maker()
+ function kwf_maker
- function last(s::BitSet)
+ function last(s :: BitSet)
- function last(v::AbstractVector, n::Integer)
+ function last(v :: AbstractVector, n :: Integer)
- function last(v::Pairs{K, V}) where {K, V}
+ function last(v :: Pairs{K, V}) where K, V
- function last_error()
+ function last_error
- function lastdayofmonth(dt::Date)
+ function lastdayofmonth(dt :: Date)
- function lastdayofquarter(dt::Date)
+ function lastdayofquarter(dt :: Date)
- function lastdayofyear(dt::Date)
+ function lastdayofyear(dt :: Date)
- function latex(io::IO, code::Code)
+ function latex(io :: IO, code :: Code)
- function latex(io::IO, content::Vector)
+ function latex(io :: IO, content :: Vector)
- function latex(io::IO, f::Footnote)
+ function latex(io :: IO, f :: Footnote)
- function latex(io::IO, header::Header{l}) where l
+ function latex(io :: IO, header :: Header{l}) where l
- function latex(io::IO, md::Admonition)
+ function latex(io :: IO, md :: Admonition)
- function latex(io::IO, md::BlockQuote)
+ function latex(io :: IO, md :: BlockQuote)
- function latex(io::IO, md::HorizontalRule)
+ function latex(io :: IO, md :: HorizontalRule)
- function latex(io::IO, md::List)
+ function latex(io :: IO, md :: List)
- function latex(io::IO, md::Paragraph)
+ function latex(io :: IO, md :: Paragraph)
- function latex(io::IO, md::Table)
+ function latex(io :: IO, md :: Table)
- function latexesc(io, s::AbstractString)
+ function latexesc(io, s :: AbstractString)
- function latexinline(io::IO, code::Code)
+ function latexinline(io :: IO, code :: Code)
- function latexinline(io::IO, md::AbstractString)
+ function latexinline(io :: IO, md :: AbstractString)
- function latexinline(io::IO, md::Bold)
+ function latexinline(io :: IO, md :: Bold)
- function latexinline(io::IO, md::Image)
+ function latexinline(io :: IO, md :: Image)
- function latexinline(io::IO, md::Italic)
+ function latexinline(io :: IO, md :: Italic)
- function latexinline(io::IO, md::Link)
+ function latexinline(io :: IO, md :: Link)
- function latexinline(io::IO, md::Vector)
+ function latexinline(io :: IO, md :: Vector)
- function lbt_forward(path::AbstractString; clear::Bool = false, verbose::Bool = false, suffix_hint::Union{String,Nothing} = nothing)
+ function lbt_forward(path :: AbstractString, clear :: Bool = false, verbose :: Bool = false, suffix_hint :: Union{String, Nothing} = nothing)
- function lbt_get_config()
+ function lbt_get_config
- function lbt_get_default_func()
+ function lbt_get_default_func
- function lbt_get_forward(symbol_name, interface, f2c = LBT_F2C_PLAIN)
+ function lbt_get_forward(symbol_name, interface, f2c = LBT_F2C_PLAIN)
- function lbt_get_forward(symbol_name, interface::Symbol, f2c::Symbol = :plain)
+ function lbt_get_forward(symbol_name, interface :: Symbol, f2c :: Symbol = :plain)
- function lbt_get_num_threads()
+ function lbt_get_num_threads
- function lbt_set_default_func(addr)
+ function lbt_set_default_func(addr)
- function lbt_set_num_threads(nthreads)
+ function lbt_set_num_threads(nthreads)
- function lcm(a::T, b::T) where T<:Integer
+ function lcm(a :: T, b :: T) where T <: Integer
- function ld()
+ function ld
- function ldexp(x::BigFloat, n::Clong)
+ function ldexp(x :: BigFloat, n :: Clong)
- function ldexp(x::BigFloat, n::Culong)
+ function ldexp(x :: BigFloat, n :: Culong)
- function ldexp(x::T, e::Integer) where T<:IEEEFloat
+ function ldexp(x :: T, e :: Integer) where T <: IEEEFloat
- function ldflags(doframework)
+ function ldflags(doframework)
- function ldiv!(A::LQ, B::AbstractVecOrMat)
+ function ldiv!(A :: LQ, B :: AbstractVecOrMat)
- function ldiv!(A::LU, B::AbstractVecOrMat)
+ function ldiv!(A :: LU, B :: AbstractVecOrMat)
- function ldiv!(A::LU{T,Tridiagonal{T,V}}, B::AbstractVecOrMat) where {T,V}
+ function ldiv!(A :: LU{T, Tridiagonal{T, V}}, B :: AbstractVecOrMat) where T, V
- function ldiv!(A::QR, B::AbstractVector)
+ function ldiv!(A :: QR, B :: AbstractVector)
- function ldiv!(A::QRCompactWY{T}, B::AbstractMatrix{T}) where {T}
+ function ldiv!(A :: QRCompactWY{T}, B :: AbstractMatrix{T}) where T
- function ldiv!(A::QRCompactWY{T}, b::AbstractVector{T}) where {T}
+ function ldiv!(A :: QRCompactWY{T}, b :: AbstractVector{T}) where T
- function ldiv!(A::QRPivoted, B::AbstractMatrix)
+ function ldiv!(A :: QRPivoted, B :: AbstractMatrix)
- function ldiv!(A::QRPivoted, b::AbstractVector)
+ function ldiv!(A :: QRPivoted, b :: AbstractVector)
- function ldiv!(A::QRPivoted{T,<:StridedMatrix}, B::AbstractMatrix{T}, rcond::Real) where {T<:BlasFloat}
+ function ldiv!(A :: QRPivoted{T, ??? <: StridedMatrix}, B :: AbstractMatrix{T}, rcond :: Real) where T <: BlasFloat
- function ldiv!(A::QR{T}, B::AbstractMatrix{T}) where T
+ function ldiv!(A :: QR{T}, B :: AbstractMatrix{T}) where T
- function ldiv!(A::SVD{T}, B::AbstractVecOrMat) where T
+ function ldiv!(A :: SVD{T}, B :: AbstractVecOrMat) where T
- function ldiv!(A::Tridiagonal, B::AbstractVecOrMat)
+ function ldiv!(A :: Tridiagonal, B :: AbstractVecOrMat)
- function ldiv!(B::AbstractVecOrMat, D::Diagonal, A::AbstractVecOrMat)
+ function ldiv!(B :: AbstractVecOrMat, D :: Diagonal, A :: AbstractVecOrMat)
- function ldiv!(B::BunchKaufman{T,<:StridedMatrix}, R::StridedVecOrMat{T}) where {T<:BlasComplex}
+ function ldiv!(B :: BunchKaufman{T, ??? <: StridedMatrix}, R :: StridedVecOrMat{T}) where T <: BlasComplex
- function ldiv!(B::BunchKaufman{T,<:StridedMatrix}, R::StridedVecOrMat{T}) where {T<:BlasReal}
+ function ldiv!(B :: BunchKaufman{T, ??? <: StridedMatrix}, R :: StridedVecOrMat{T}) where T <: BlasReal
- function ldiv!(C::Cholesky, B::AbstractVecOrMat)
+ function ldiv!(C :: Cholesky, B :: AbstractVecOrMat)
- function ldiv!(C::CholeskyPivoted, B::AbstractMatrix)
+ function ldiv!(C :: CholeskyPivoted, B :: AbstractMatrix)
- function ldiv!(C::CholeskyPivoted, B::AbstractVector)
+ function ldiv!(C :: CholeskyPivoted, B :: AbstractVector)
- function ldiv!(C::CholeskyPivoted{T,<:StridedMatrix}, B::StridedMatrix{T}) where T<:BlasFloat
+ function ldiv!(C :: CholeskyPivoted{T, ??? <: StridedMatrix}, B :: StridedMatrix{T}) where T <: BlasFloat
- function ldiv!(C::CholeskyPivoted{T,<:StridedMatrix}, B::StridedVector{T}) where T<:BlasFloat
+ function ldiv!(C :: CholeskyPivoted{T, ??? <: StridedMatrix}, B :: StridedVector{T}) where T <: BlasFloat
- function ldiv!(F::Hessenberg, B::AbstractVecOrMat)
+ function ldiv!(F :: Hessenberg, B :: AbstractVecOrMat)
- function ldiv!(F::Hessenberg{<:Complex,<:Any,<:AbstractMatrix{<:Real}}, B::AbstractVecOrMat{<:Complex})
+ function ldiv!(F :: Hessenberg{??? <: Complex, ??? <: Any, ??? <: AbstractMatrix{??? <: Real}}, B :: AbstractVecOrMat{??? <: Complex})
- function ldiv!(F::UpperHessenberg, B::AbstractVecOrMat; shift::Number=false)
+ function ldiv!(F :: UpperHessenberg, B :: AbstractVecOrMat, shift :: Number = false)
- function ldiv!(Fadj::AdjointFactorization{<:Any,<:LQ}, B::AbstractVecOrMat)
+ function ldiv!(Fadj :: AdjointFactorization{??? <: Any, ??? <: LQ}, B :: AbstractVecOrMat)
- function ldiv!(Fadj::AdjointFactorization{<:Any,<:Union{QR,QRCompactWY,QRPivoted}}, B::AbstractVecOrMat)
+ function ldiv!(Fadj :: AdjointFactorization{??? <: Any, ??? <: Union{QR, QRCompactWY, QRPivoted}}, B :: AbstractVecOrMat)
- function ldiv!(S::LDLt{<:Any,<:SymTridiagonal}, B::AbstractVecOrMat)
+ function ldiv!(S :: LDLt{??? <: Any, ??? <: SymTridiagonal}, B :: AbstractVecOrMat)
- function ldiv!(T::Tridiagonal, D::Diagonal, S::Union{SymTridiagonal,Tridiagonal})
+ function ldiv!(T :: Tridiagonal, D :: Diagonal, S :: Union{SymTridiagonal, Tridiagonal})
- function ldiv!(Y::AbstractMatrix, A::Factorization, B::AbstractMatrix)
+ function ldiv!(Y :: AbstractMatrix, A :: Factorization, B :: AbstractMatrix)
- function ldiv!(Y::AbstractVector, A::Factorization, B::AbstractVector)
+ function ldiv!(Y :: AbstractVector, A :: Factorization, B :: AbstractVector)
- function ldiv!(adjA::AdjointFactorization{<:Any,<:LU{T,Tridiagonal{T,V}}}, B::AbstractVecOrMat) where {T,V}
+ function ldiv!(adjA :: AdjointFactorization{??? <: Any, ??? <: LU{T, Tridiagonal{T, V}}}, B :: AbstractVecOrMat) where T, V
- function ldiv!(adjA::AdjointFactorization{<:Any,<:LU}, B::AbstractVecOrMat)
+ function ldiv!(adjA :: AdjointFactorization{??? <: Any, ??? <: LU}, B :: AbstractVecOrMat)
- function ldiv!(c::AbstractVecOrMat, A::Bidiagonal, b::AbstractVecOrMat)
+ function ldiv!(c :: AbstractVecOrMat, A :: Bidiagonal, b :: AbstractVecOrMat)
- function ldiv!(s::Number, X::AbstractArray)
+ function ldiv!(s :: Number, X :: AbstractArray)
- function ldiv!(transA::TransposeFactorization{<:Any,<:LU{T,Tridiagonal{T,V}}}, B::AbstractVecOrMat) where {T,V}
+ function ldiv!(transA :: TransposeFactorization{??? <: Any, ??? <: LU{T, Tridiagonal{T, V}}}, B :: AbstractVecOrMat) where T, V
- function ldiv!(transA::TransposeFactorization{<:Any,<:LU}, B::AbstractVecOrMat)
+ function ldiv!(transA :: TransposeFactorization{??? <: Any, ??? <: LU}, B :: AbstractVecOrMat)
- function ldiv(F::Factorization, B::AbstractVecOrMat)
+ function ldiv(F :: Factorization, B :: AbstractVecOrMat)
- function ldlibs(doframework)
+ function ldlibs(doframework)
- function ldlt!(S::SymTridiagonal{T,V}) where {T,V}
+ function ldlt!(S :: SymTridiagonal{T, V}) where T, V
- function ldlt(M::SymTridiagonal{T}; shift::Number=false) where T
+ function ldlt(M :: SymTridiagonal{T}, shift :: Number = false) where T
- function leadingspaces(buf::IOBuffer, b::Int)
+ function leadingspaces(buf :: IOBuffer, b :: Int)
- function legalize_bb_drop_pred!(ir::IRCode, bb::BasicBlock, bbidx::Int, bbs::Vector{BasicBlock}, dropped_bbs::Vector{Int})
+ function legalize_bb_drop_pred!(ir :: IRCode, bb :: BasicBlock, bbidx :: Int, bbs :: Vector{BasicBlock}, dropped_bbs :: Vector{Int})
- function len(a, b, c)
+ function len(a, b, c)
- function length(::EnvDict)
+ function length(??? :: EnvDict)
- function length(g::GraphemeIterator{S}) where {S}
+ function length(g :: GraphemeIterator{S}) where S
- function length(itr::PartitionIterator)
+ function length(itr :: PartitionIterator)
- function length(mt::Core.MethodTable)
+ function length(mt :: Core.MethodTable)
- function length(q::IntrusiveLinkedList)
+ function length(q :: IntrusiveLinkedList)
- function length(r::AbstractUnitRange{T}) where T
+ function length(r :: AbstractUnitRange{T}) where T
- function length(r::AbstractUnitRange{T}) where T<:Rational
+ function length(r :: AbstractUnitRange{T}) where T <: Rational
- function length(r::OrdinalRange{<:smallints})
+ function length(r :: OrdinalRange{??? <: smallints})
- function length(r::OrdinalRange{T}) where T
+ function length(r :: OrdinalRange{T}) where T
- function length(r::OrdinalRange{T}) where T<:bigints
+ function length(r :: OrdinalRange{T}) where T <: bigints
- function length(s::AbstractString, i::Int, j::Int)
+ function length(s :: AbstractString, i :: Int, j :: Int)
- function length(s::Stateful)
+ function length(s :: Stateful)
- function length(t::WeakKeyDict)
+ function length(t :: WeakKeyDict)
- function length(v::SimpleVector)
+ function length(v :: SimpleVector)
- function length(z::Zip)
+ function length(z :: Zip)
- function lerpi(j::Integer, d::Integer, a::BigFloat, b::BigFloat)
+ function lerpi(j :: Integer, d :: Integer, a :: BigFloat, b :: BigFloat)
- function lerpi(j::Integer, d::Integer, a::Rational, b::Rational)
+ function lerpi(j :: Integer, d :: Integer, a :: Rational, b :: Rational)
- function lerpi(j::Integer, d::Integer, a::T, b::T) where T
+ function lerpi(j :: Integer, d :: Integer, a :: T, b :: T) where T
- function less(file::AbstractString, line::Integer)
+ function less(file :: AbstractString, line :: Integer)
- function less_than_constraint(a::String, b::String, a_requested::Bool, b_requested::Bool)
+ function less_than_constraint(a :: String, b :: String, a_requested :: Bool, b_requested :: Bool)
- function let_Box1()
+ function let_Box1
- function let_Box2()
+ function let_Box2
- function let_Box3()
+ function let_Box3
- function let_Box4()
+ function let_Box4
- function let_Box5()
+ function let_Box5
- function let_noBox()
+ function let_noBox
- function let_undef()
+ function let_undef
- function levenshtein(s1, s2)
+ function levenshtein(s1, s2)
- function levsort(search::String, candidates::Vector{String})
+ function levsort(search :: String, candidates :: Vector{String})
- function libDir()
+ function libDir
- function libc_str(p::AbstractPlatform)
+ function libc_str(p :: AbstractPlatform)
- function libjulia_codegen_name()
+ function libjulia_codegen_name
- function lift_svec_ref!(compact::IncrementalCompact, idx::Int, stmt::Expr)
+ function lift_svec_ref!(compact :: IncrementalCompact, idx :: Int, stmt :: Expr)
- function limit_type_size(@nospecialize(t), @nospecialize(compare), @nospecialize(source), allowed_tupledepth::Int, allowed_tuplelen::Int)
+ function limit_type_size(t, compare, source, allowed_tupledepth :: Int, allowed_tuplelen :: Int)
- function linear_foo()
+ function linear_foo
- function linear_inline_eligible(ir::IRCode)
+ function linear_inline_eligible(ir :: IRCode)
- function linebreak(stream::IO, md::MD)
+ function linebreak(stream :: IO, md :: MD)
- function linesplitter(str)
+ function linesplitter(str)
- function link(stream::IO, md::MD)
+ function link(stream :: IO, md :: MD)
- function link_image(path, out, internal_stderr::IO=stderr, internal_stdout::IO=stdout)
+ function link_image(path, out, internal_stderr :: IO = stderr, internal_stdout :: IO = stdout)
- function link_image_cmd(path, out)
+ function link_image_cmd(path, out)
- function link_pipe(reader_supports_async::Bool, writer_supports_async::Bool)
+ function link_pipe(reader_supports_async :: Bool, writer_supports_async :: Bool)
- function liperm(lilist::Vector{StackFrame})
+ function liperm(lilist :: Vector{StackFrame})
- function list(N=16*1024^2)
+ function list(N = 16*1024^2)
- function list(stream::IO, block::MD)
+ function list(stream :: IO, block :: MD)
- function list_append!!(q::IntrusiveLinkedList{T}, q2::IntrusiveLinkedList{T}) where T
+ function list_append!!(q :: IntrusiveLinkedList{T}, q2 :: IntrusiveLinkedList{T}) where T
- function list_deletefirst!(W::IntrusiveLinkedListSynchronized{T}, t::T) where T
+ function list_deletefirst!(W :: IntrusiveLinkedListSynchronized{T}, t :: T) where T
- function list_deletefirst!(q::IntrusiveLinkedList{T}, val::T) where T
+ function list_deletefirst!(q :: IntrusiveLinkedList{T}, val :: T) where T
- function list_deletefirst!(q::LinkedList{T}, val::T) where T
+ function list_deletefirst!(q :: LinkedList{T}, val :: T) where T
- function listen(addr; backlog::Integer=BACKLOG_DEFAULT)
+ function listen(addr, backlog :: Integer = BACKLOG_DEFAULT)
- function listen(path::AbstractString)
+ function listen(path :: AbstractString)
- function listen(sock::LibuvServer; backlog::Integer=BACKLOG_DEFAULT)
+ function listen(sock :: LibuvServer, backlog :: Integer = BACKLOG_DEFAULT)
- function listenany(host::IPAddr, default_port; backlog::Integer=BACKLOG_DEFAULT)
+ function listenany(host :: IPAddr, default_port, backlog :: Integer = BACKLOG_DEFAULT)
- function lld(; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
+ function lld(adjust_PATH :: Bool = true, adjust_LIBPATH :: Bool = true)
- function lld(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
+ function lld(f :: Function, adjust_PATH :: Bool = true, adjust_LIBPATH :: Bool = true)
- function lmul!(A::LQ, B::AbstractVecOrMat)
+ function lmul!(A :: LQ, B :: AbstractVecOrMat)
- function lmul!(A::QRPackedQ, B::AbstractVecOrMat)
+ function lmul!(A :: QRPackedQ, B :: AbstractVecOrMat)
- function lmul!(G::Givens, R::Rotation)
+ function lmul!(G :: Givens, R :: Rotation)
- function lmul!(R::Rotation, A::AbstractVecOrMat)
+ function lmul!(R :: Rotation, A :: AbstractVecOrMat)
- function lmul!(adjA::AdjointQ{<:Any,<:QRPackedQ}, B::AbstractVecOrMat)
+ function lmul!(adjA :: AdjointQ{??? <: Any, ??? <: QRPackedQ}, B :: AbstractVecOrMat)
- function lmul!(adjR::AdjointRotation{<:Any,<:Rotation}, A::AbstractVecOrMat)
+ function lmul!(adjR :: AdjointRotation{??? <: Any, ??? <: Rotation}, A :: AbstractVecOrMat)
- function lmul!(s::Number, X::AbstractArray)
+ function lmul!(s :: Number, X :: AbstractArray)
- function lmul_triu!(x, M::AbstractMatrix, k::Integer=0)
+ function lmul_triu!(x, M :: AbstractMatrix, k :: Integer = 0)
- function load_InteractiveUtils(mod::Module=Main)
+ function load_InteractiveUtils(mod :: Module = Main)
- function load_REPL()
+ function load_REPL
- function load_backtrace(trace::RawBacktrace)::Vector{BTElement}
+ function load_backtrace(trace :: RawBacktrace)
- function load_dummy_ref(x::Int)
+ function load_dummy_ref(x :: Int)
- function load_julia_startup()
+ function load_julia_startup
- function load_overrides(;force::Bool = false)::Dict{Symbol, Any}
+ function load_overrides(force :: Bool = false)
- function load_path()
+ function load_path
- function load_path_expand(env::AbstractString)::Union{String, Nothing}
+ function load_path_expand(env :: AbstractString)
- function load_path_setup_code(load_path::Bool=true)
+ function load_path_setup_code(load_path :: Bool = true)
- function load_terminfo(term::String)
+ function load_terminfo(term :: String)
- function load_type(ptr::Ptr{Type})
+ function load_type(ptr :: Ptr{Type})
- function loadavg()
+ function loadavg
- function loaddocs(docs::Vector{Core.SimpleVector})
+ function loaddocs(docs :: Vector{Core.SimpleVector})
- function loadtriplet!(buffer::Buffer, ptr::Ptr{UInt8}, n::UInt)
+ function loadtriplet!(buffer :: Buffer, ptr :: Ptr{UInt8}, n :: UInt)
- function local_array_by_id(refid)
+ function local_array_by_id(refid)
- function locale_dict(names::Vector{<:AbstractString})
+ function locale_dict(names :: Vector{??? <: AbstractString})
- function locate_package(pkg::PkgId, stopenv::Union{String, Nothing}=nothing)::Union{Nothing,String}
+ function locate_package(pkg :: PkgId, stopenv :: Union{String, Nothing} = nothing)
- function locate_package_env(pkg::PkgId, stopenv::Union{String, Nothing}=nothing)
+ function locate_package_env(pkg :: PkgId, stopenv :: Union{String, Nothing} = nothing)
- function locate_project_file(env::String)
+ function locate_project_file(env :: String)
- function lock(f, l::AbstractLock)
+ function lock(f, l :: AbstractLock)
- function lock(l::SpinLock)
+ function lock(l :: SpinLock)
- function log(A::AbstractMatrix)
+ function log(A :: AbstractMatrix)
- function log(z::Complex)
+ function log(z :: Complex)
- function log10(z::Complex)
+ function log10(z :: Complex)
- function log1p(x::BigFloat)
+ function log1p(x :: BigFloat)
- function log1p(x::Float32)
+ function log1p(x :: Float32)
- function log1p(x::Float64)
+ function log1p(x :: Float64)
- function log1p(z::Complex{T}) where T
+ function log1p(z :: Complex{T}) where T
- function log2(z::Complex)
+ function log2(z :: Complex)
- function log_nonpublic_access(expr::Expr, mod::Module, internal_access::Set{Pair{Module,Symbol}})
+ function log_nonpublic_access(expr :: Expr, mod :: Module, internal_access :: Set{Pair{Module, Symbol}})
- function log_quasitriu(A0::AbstractMatrix{T}) where T<:BlasFloat
+ function log_quasitriu(A0 :: AbstractMatrix{T}) where T <: BlasFloat
- function log_record_id(_module, level, message, log_kws)
+ function log_record_id(_module, level, message, log_kws)
- function logabsdet(A::AbstractMatrix)
+ function logabsdet(A :: AbstractMatrix)
- function logabsdet(A::Diagonal)
+ function logabsdet(A :: Diagonal)
- function logabsdet(A::Union{UpperTriangular{T},LowerTriangular{T}}) where T
+ function logabsdet(A :: Union{UpperTriangular{T}, LowerTriangular{T}}) where T
- function logabsdet(F::BunchKaufman)
+ function logabsdet(F :: BunchKaufman)
- function logabsdet(F::LDLt{<:Any,<:SymTridiagonal})
+ function logabsdet(F :: LDLt{??? <: Any, ??? <: SymTridiagonal})
- function logabsdet(F::LU{T}) where T
+ function logabsdet(F :: LU{T}) where T
- function logabsdet(F::UpperHessenberg; shift::Number=false)
+ function logabsdet(F :: UpperHessenberg, shift :: Number = false)
- function logacc(x::Float64,expected::Float64)
+ function logacc(x :: Float64, expected :: Float64)
- function logdet(A::AbstractMatrix)
+ function logdet(A :: AbstractMatrix)
- function logdet(A::AbstractQ)
+ function logdet(A :: AbstractQ)
- function logdet(C::Cholesky)
+ function logdet(C :: Cholesky)
- function logdet(C::CholeskyPivoted)
+ function logdet(C :: CholeskyPivoted)
- function logdet(D::Diagonal{<:Complex})
+ function logdet(D :: Diagonal{??? <: Complex})
- function logdet(F::Factorization)
+ function logdet(F :: Factorization)
- function logdet(F::Hessenberg)
+ function logdet(F :: Hessenberg)
- function logmsg_code(_module, file, line, level, message, exs...)
+ function logmsg_code(_module, file, line, level, message, exs...)
- function logmsg_shim(level, message, _module, group, id, file, line, kwargs)
+ function logmsg_shim(level, message, _module, group, id, file, line, kwargs)
- function longdef(x)
+ function longdef(x)
- function longpath(path::AbstractString)
+ function longpath(path :: AbstractString)
- function lookup(ip::Union{Base.InterpreterIP,Core.Compiler.InterpreterIP})
+ function lookup(ip :: Union{Base.InterpreterIP, Core.Compiler.InterpreterIP})
- function lookup_doc(ex)
+ function lookup_doc(ex)
- function lookup_inline_frame_info(func::Symbol, file::Symbol, linenum::Int, inlinetable::Vector{Core.LineInfoNode})
+ function lookup_inline_frame_info(func :: Symbol, file :: Symbol, linenum :: Int, inlinetable :: Vector{Core.LineInfoNode})
- function lookup_inline_frame_info(func::Symbol, file::Symbol, miroots::Vector{Any})
+ function lookup_inline_frame_info(func :: Symbol, file :: Symbol, miroots :: Vector{Any})
- function lookup_object_number(s::Serializer, n::UInt64)
+ function lookup_object_number(s :: Serializer, n :: UInt64)
- function lookup_remote(repo::GitRepo, remote_name::AbstractString)
+ function lookup_remote(repo :: GitRepo, remote_name :: AbstractString)
- function loop()
+ function loop
- function loop_alloc(N)
+ function loop_alloc(N)
- function loop_const()
+ function loop_const
- function loop_range_values(::Type{T}) where T
+ function loop_range_values(??? :: Type{T}) where T
- function loopedlength(arr)
+ function loopedlength(arr)
- function lowercasefirst(s::AbstractString)
+ function lowercasefirst(s :: AbstractString)
- function lowrankdowndate!(C::Cholesky, v::AbstractVector)
+ function lowrankdowndate!(C :: Cholesky, v :: AbstractVector)
- function lowrankupdate!(C::Cholesky, v::AbstractVector)
+ function lowrankupdate!(C :: Cholesky, v :: AbstractVector)
- function lreplace!(ex::Expr, r::LReplace)
+ function lreplace!(ex :: Expr, r :: LReplace)
- function lreplace!(str::AbstractString, r::LReplace)
+ function lreplace!(str :: AbstractString, r :: LReplace)
- function lreplace!(sym::Symbol, r::LReplace)
+ function lreplace!(sym :: Symbol, r :: LReplace)
- function ls(rmt::GitRemote)
+ function ls(rmt :: GitRemote)
- function lstrip(f, s::AbstractString)
+ function lstrip(f, s :: AbstractString)
- function lt(a::StackFrame, b::StackFrame)
+ function lt(a :: StackFrame, b :: StackFrame)
- function ltruncto(str::String, w::Int)
+ function ltruncto(str :: String, w :: Int)
- function lu!(A::HermOrSym{T}, pivot::Union{RowMaximum,NoPivot,RowNonZero} = lupivottype(T); check::Bool = true) where {T}
+ function lu!(A :: HermOrSym{T}, pivot :: Union{RowMaximum, NoPivot, RowNonZero} = lupivottype(T), check :: Bool = true) where T
- function lu!(A::StridedMatrix{T}, ::RowMaximum; check::Bool = true) where {T<:BlasFloat}
+ function lu!(A :: StridedMatrix{T}, ??? :: RowMaximum, check :: Bool = true) where T <: BlasFloat
- function lu!(A::Tridiagonal{T,V}, pivot::Union{RowMaximum,NoPivot} = RowMaximum(); check::Bool = true) where {T,V}
+ function lu!(A :: Tridiagonal{T, V}, pivot :: Union{RowMaximum, NoPivot} = RowMaximum(), check :: Bool = true) where T, V
- function lu!(F::LU{<:Any,<:Tridiagonal}, A::Tridiagonal, pivot::Union{RowMaximum,NoPivot} = RowMaximum(); check::Bool = true)
+ function lu!(F :: LU{??? <: Any, ??? <: Tridiagonal}, A :: Tridiagonal, pivot :: Union{RowMaximum, NoPivot} = RowMaximum(), check :: Bool = true)
- function lu(x::Number; check::Bool=true)
+ function lu(x :: Number, check :: Bool = true)
- function lutype(T::Type)
+ function lutype(T :: Type)
- function lyap(A::AbstractMatrix, C::AbstractMatrix)
+ function lyap(A :: AbstractMatrix, C :: AbstractMatrix)
- function lyap(A::AbstractMatrix{T}, C::AbstractMatrix{T}) where {T<:BlasFloat}
+ function lyap(A :: AbstractMatrix{T}, C :: AbstractMatrix{T}) where T <: BlasFloat
- function macroexpand(m::Module, @nospecialize(x); recursive=true)
+ function macroexpand(m :: Module, x, recursive = true)
- function madvise!(m::Array, flag::Integer=MADV_NORMAL)
+ function madvise!(m :: Array, flag :: Integer = MADV_NORMAL)
- function main()
+ function main
- function main(ARGS)
+ function main(ARGS)
- function main(args = ARGS)::Int
+ function main(args = ARGS)
- function make()
+ function make
- function make(n::Int)
+ function make(n :: Int)
- function make_atomic(order, a1, op, a2)
+ function make_atomic(order, a1, op, a2)
- function make_atomic(order, ex)
+ function make_atomic(order, ex)
- function make_atomicreplace(success_order, fail_order, ex, old_new)
+ function make_atomicreplace(success_order, fail_order, ex, old_new)
- function make_atomicswap(order, ex)
+ function make_atomicswap(order, ex)
- function make_ci(code)
+ function make_ci(code)
- function make_cwgc38727(wkd, i)
+ function make_cwgc38727(wkd, i)
- function make_entry_point(path::String, name::String, uuid::UUID)
+ function make_entry_point(path :: String, name :: String, uuid :: UUID)
- function make_env(flat, root, roots, graph, paths, dummies)
+ function make_env(flat, root, roots, graph, paths, dummies)
- function make_fastmath(expr::Expr)
+ function make_fastmath(expr :: Expr)
- function make_fastmath(symb::Symbol)
+ function make_fastmath(symb :: Symbol)
- function make_issue47349(::Val{N}) where {N}
+ function make_issue47349(??? :: Val{N}) where N
- function make_oc_and_collect_bt()
+ function make_oc_and_collect_bt
- function make_scratch(scratch::Nothing, T::Type, len::Integer)
+ function make_scratch(scratch :: Nothing, T :: Type, len :: Integer)
- function make_scratch(scratch::Vector, T::Type, len::Integer)
+ function make_scratch(scratch :: Vector, T :: Type, len :: Integer)
- function make_scratch(scratch::Vector{T}, ::Type{T}, len::Integer) where T
+ function make_scratch(scratch :: Vector{T}, ??? :: Type{T}, len :: Integer) where T
- function make_ssa!(ci::CodeInfo, code::Vector{Any}, idx::Int, @nospecialize(typ))
+ function make_ssa!(ci :: CodeInfo, code :: Vector{Any}, idx :: Int, typ)
- function make_typealias(@nospecialize(x::Type))
+ function make_typealias(x :: Type)
- function make_typealiases(@nospecialize(x::Type))
+ function make_typealiases(x :: Type)
- function make_wheres(io::IO, env::SimpleVector, @nospecialize(x::Type))
+ function make_wheres(io :: IO, env :: SimpleVector, x :: Type)
- function makeproper(io::IO, @nospecialize(x::Type))
+ function makeproper(io :: IO, x :: Type)
- function manifest_deps_get(env::String, where::PkgId, name::String)::Union{Nothing,PkgId}
+ function manifest_deps_get(env :: String, where :: PkgId, name :: String)
- function manifest_uuid_path(env::String, pkg::PkgId)::Union{Nothing,String,Missing}
+ function manifest_uuid_path(env :: String, pkg :: PkgId)
- function map!(f, S::SharedArray, Q::SharedArray)
+ function map!(f, S :: SharedArray, Q :: SharedArray)
- function map!(f, iter::ValueIterator)
+ function map!(f, iter :: ValueIterator)
- function map!(f, iter::ValueIterator{<:Dict})
+ function map!(f, iter :: ValueIterator{??? <: Dict})
- function map!(f::F, dest::AbstractArray, A::AbstractArray) where F
+ function map!(f :: F, dest :: AbstractArray, A :: AbstractArray) where F
- function map!(f::F, dest::AbstractArray, A::AbstractArray, B::AbstractArray) where F
+ function map!(f :: F, dest :: AbstractArray, A :: AbstractArray, B :: AbstractArray) where F
- function map!(f::F, dest::AbstractArray, As::AbstractArray...) where {F}
+ function map!(f :: F, dest :: AbstractArray, As :: AbstractArray...) where F
- function map(::Type{T}, r::LinRange) where T<:AbstractFloat
+ function map(??? :: Type{T}, r :: LinRange) where T <: AbstractFloat
- function map(f, A::StructuredMatrix, Bs::StructuredMatrix...)
+ function map(f, A :: StructuredMatrix, Bs :: StructuredMatrix...)
- function map(f, nt::NamedTuple{names}, nts::NamedTuple...) where names
+ function map(f, nt :: NamedTuple{names}, nts :: NamedTuple...) where names
- function map(f, s::AbstractString)
+ function map(f, s :: AbstractString)
- function map(f, t1::Any32, t2::Any32, ts::Any32...)
+ function map(f, t1 :: Any32, t2 :: Any32, ts :: Any32...)
- function map(f, t1::Tuple, t2::Tuple, ts::Tuple...)
+ function map(f, t1 :: Tuple, t2 :: Tuple, ts :: Tuple...)
- function map(f, t::Any32)
+ function map(f, t :: Any32)
- function map(f, t::Any32, s::Any32)
+ function map(f, t :: Any32, s :: Any32)
- function map(f, t::Tuple, s::Tuple)
+ function map(f, t :: Tuple, s :: Tuple)
- function map_completion_text(completions)
+ function map_completion_text(completions)
- function map_n!(f::F, dest::AbstractArray, As) where F
+ function map_n!(f :: F, dest :: AbstractArray, As) where F
- function mapfilter(pred, f, itr, res)
+ function mapfilter(pred, f, itr, res)
- function mapfirst!(f::F, R::AbstractArray, A::AbstractArray{<:Any,N}) where {N, F}
+ function mapfirst!(f :: F, R :: AbstractArray, A :: AbstractArray{??? <: Any, N}) where N, F
- function mapfoldl_impl(f::F, op::OP, nt, itr) where {F,OP}
+ function mapfoldl_impl(f :: F, op :: OP, nt, itr) where F, OP
- function mapfoldr_impl(f, op, nt, itr)
+ function mapfoldr_impl(f, op, nt, itr)
- function mapslices(f, A::AbstractArray; dims)
+ function mapslices(f, A :: AbstractArray, dims)
- function maptwice(wrapped_f, chnl, worker_tasks, c...)
+ function maptwice(wrapped_f, chnl, worker_tasks, c...)
- function mark(io::IO)
+ function mark(io :: IO)
- function mark_phi_cycles!(compact::IncrementalCompact, safe_phis::SPCSet, phi::Int)
+ function mark_phi_cycles!(compact :: IncrementalCompact, safe_phis :: SPCSet, phi :: Int)
- function mark_throw_blocks!(src::CodeInfo, handler_at::Vector{Int})
+ function mark_throw_blocks!(src :: CodeInfo, handler_at :: Vector{Int})
- function mark_unindexable!(astate::AnalysisState, @nospecialize(ary))
+ function mark_unindexable!(astate :: AnalysisState, ary)
- function match(re::Regex, str::AnnotatedString)
+ function match(re :: Regex, str :: AnnotatedString)
- function match(re::Regex, str::AnnotatedString, idx::Integer, add_opts::UInt32=UInt32(0))
+ function match(re :: Regex, str :: AnnotatedString, idx :: Integer, add_opts :: UInt32 = UInt32(0))
- function match_input(f::Function, s::Union{Nothing,MIState}, term, cs::Vector{Char}, keymap)
+ function match_input(f :: Function, s :: Union{Nothing, MIState}, term, cs :: Vector{Char}, keymap)
- function match_input(k::Dict{Char}, s::Union{Nothing,MIState}, term::Union{AbstractTerminal,IOBuffer}=terminal(s), cs::Vector{Char}=Char[], keymap::Dict{Char} = k)
+ function match_input(k :: Dict{Char}, s :: Union{Nothing, MIState}, term :: Union{AbstractTerminal, IOBuffer} = terminal(s), cs :: Vector{Char} = Char[], keymap :: Dict{Char} = k)
- function match_logs(f, patterns...; match_mode::Symbol=:all, kwargs...)
+ function match_logs(f, patterns..., match_mode :: Symbol = :all, kwargs...)
- function match_loss(a, b)
+ function match_loss(a, b)
- function matches_oddness(a::String, b::String, a_requested::Bool, b_requested::Bool)
+ function matches_oddness(a :: String, b :: String, a_requested :: Bool, b_requested :: Bool)
- function matches_sv(parent::AbsIntState, sv::AbsIntState)
+ function matches_sv(parent :: AbsIntState, sv :: AbsIntState)
- function matchinds(needle, haystack; acronym::Bool = false)
+ function matchinds(needle, haystack, acronym :: Bool = false)
- function matching_cache_argtypes(L::AbstractLattice, linfo::MethodInstance)
+ function matching_cache_argtypes(L :: AbstractLattice, linfo :: MethodInstance)
- function matching_cache_argtypes(L::AbstractLattice, linfo::MethodInstance, simple_argtypes::SimpleArgtypes)
+ function matching_cache_argtypes(L :: AbstractLattice, linfo :: MethodInstance, simple_argtypes :: SimpleArgtypes)
- function matmul2x2(tA, tB, A::AbstractMatrix{T}, B::AbstractMatrix{S}) where {T,S}
+ function matmul2x2(tA, tB, A :: AbstractMatrix{T}, B :: AbstractMatrix{S}) where T, S
- function matmul3x3(tA, tB, A::AbstractMatrix{T}, B::AbstractMatrix{S}) where {T,S}
+ function matmul3x3(tA, tB, A :: AbstractMatrix{T}, B :: AbstractMatrix{S}) where T, S
- function max(x::T, y::T) where {T<:Union{Float32,Float64}}
+ function max(x :: T, y :: T) where T <: Union{Float32, Float64}
- function max_values(T::Union)
+ function max_values(T :: Union)
- function maxstats(root::StackFrameTree)
+ function maxstats(root :: StackFrameTree)
- function may_have_fcalls(m::Method)
+ function may_have_fcalls(m :: Method)
- function may_invoke_generator(method::Method, @nospecialize(atype), sparams::SimpleVector)
+ function may_invoke_generator(method :: Method, atype, sparams :: SimpleVector)
- function may_invoke_generator(mi::MethodInstance)
+ function may_invoke_generator(mi :: MethodInstance)
- function maybe_cachefile_lock(f, pkg::PkgId, srcpath::String; stale_age=compilecache_pidlock_stale_age)
+ function maybe_cachefile_lock(f, pkg :: PkgId, srcpath :: String, stale_age = compilecache_pidlock_stale_age)
- function maybe_compress_codeinfo(interp::AbstractInterpreter, linfo::MethodInstance, ci::CodeInfo)
+ function maybe_compress_codeinfo(interp :: AbstractInterpreter, linfo :: MethodInstance, ci :: CodeInfo)
- function maybe_error_int(x::Int)
+ function maybe_error_int(x :: Int)
- function maybe_extract_const_bool(c::AnyConditional)
+ function maybe_extract_const_bool(c :: AnyConditional)
- function maybe_kws_nt(x::DataType)
+ function maybe_kws_nt(x :: DataType)
- function maybe_revise(ex)
+ function maybe_revise(ex)
- function maybe_show_hint(s::PromptState)
+ function maybe_show_hint(s :: PromptState)
- function maybe_show_ir(ir::IRCode)
+ function maybe_show_ir(ir :: IRCode)
- function maybe_vararg(isva::Bool)
+ function maybe_vararg(isva :: Bool)
- function maybe_vararg_tuple_1()
+ function maybe_vararg_tuple_1
- function maybe_vararg_tuple_2()
+ function maybe_vararg_tuple_2
- function mcc48954(container, y)
+ function mcc48954(container, y)
- function mdexpr(s, flavor = :julia)
+ function mdexpr(s, flavor = :julia)
- function mdsum(A)
+ function mdsum(A)
- function mdsum2(A)
+ function mdsum2(A)
- function membershiptest(expr, values)
+ function membershiptest(expr, values)
- function memcmp(a::Ptr, b::Ptr, n::Integer)
+ function memcmp(a :: Ptr, b :: Ptr, n :: Integer)
- function memcpy(dst::Ptr, src::Ptr, n::Integer)
+ function memcpy(dst :: Ptr, src :: Ptr, n :: Integer)
- function memmove(dst::Ptr, src::Ptr, n::Integer)
+ function memmove(dst :: Ptr, src :: Ptr, n :: Integer)
- function memoryref_builtin_common_nothrow(argtypes::Vector{Any})
+ function memoryref_builtin_common_nothrow(argtypes :: Vector{Any})
- function memoryref_elemtype(@nospecialize mem)
+ function memoryref_elemtype(mem)
- function memoryrefop_builtin_common_nothrow(argtypes::Vector{Any}, @nospecialize f)
+ function memoryrefop_builtin_common_nothrow(argtypes :: Vector{Any}, f)
- function memset(p::Ptr, val, n::Integer)
+ function memset(p :: Ptr, val, n :: Integer)
- function merge!(d::AbstractDict, others::AbstractDict...)
+ function merge!(d :: AbstractDict, others :: AbstractDict...)
- function merge(a::NamedTuple, itr)
+ function merge(a :: NamedTuple, itr)
- function merge(a::NamedTuple{an}, b::NamedTuple{bn}) where {an, bn}
+ function merge(a :: NamedTuple{an}, b :: NamedTuple{bn}) where an, bn
- function merge_adjacent_dim(apsz::Dims{N}, apst::Dims{N}, n::Int = 1) where {N}
+ function merge_adjacent_dim(apsz :: Dims{N}, apst :: Dims{N}, n :: Int = 1) where N
- function merge_alias_info(@nospecialize(xa), @nospecialize(ya))
+ function merge_alias_info(xa, ya)
- function merge_analysis(repo::GitRepo, anns::Vector{GitAnnotated})
+ function merge_analysis(repo :: GitRepo, anns :: Vector{GitAnnotated})
- function merge_base(repo::GitRepo, one::AbstractString, two::AbstractString)
+ function merge_base(repo :: GitRepo, one :: AbstractString, two :: AbstractString)
- function merge_call_chain!(interp::AbstractInterpreter, parent::InferenceState, ancestor::InferenceState, child::InferenceState)
+ function merge_call_chain!(interp :: AbstractInterpreter, parent :: InferenceState, ancestor :: InferenceState, child :: InferenceState)
- function merge_causes(causesa::IdSet{InferenceState}, causesb::IdSet{InferenceState})
+ function merge_causes(causesa :: IdSet{InferenceState}, causesb :: IdSet{InferenceState})
- function merge_effectbits(old::UInt8, new::UInt8)
+ function merge_effectbits(old :: UInt8, new :: UInt8)
- function merge_effects!(::AbstractInterpreter, caller::InferenceState, effects::Effects)
+ function merge_effects!(??? :: AbstractInterpreter, caller :: InferenceState, effects :: Effects)
- function merge_effects(old::Effects, new::Effects)
+ function merge_effects(old :: Effects, new :: Effects)
- function merge_to_unindexable(info::AInfo, infos::IdDict{Int,AInfo})
+ function merge_to_unindexable(info :: AInfo, infos :: IdDict{Int, AInfo})
- function merge_to_unindexable(info::AInfo, infos::Vector{AInfo})
+ function merge_to_unindexable(info :: AInfo, infos :: Vector{AInfo})
- function mergewith!(combine, d1::AbstractDict, d2::AbstractDict)
+ function mergewith!(combine, d1 :: AbstractDict, d2 :: AbstractDict)
- function mergewith!(combine, d1::Dict{K, V}, d2::AbstractDict) where {K, V}
+ function mergewith!(combine, d1 :: Dict{K, V}, d2 :: AbstractDict) where K, V
- function mergewith!(combine, d::AbstractDict, others::AbstractDict...)
+ function mergewith!(combine, d :: AbstractDict, others :: AbstractDict...)
- function mergewith51009(combine, a::NamedTuple{an}, b::NamedTuple{bn}) where {an, bn}
+ function mergewith51009(combine, a :: NamedTuple{an}, b :: NamedTuple{bn}) where an, bn
- function message(c::GitCommit, raw::Bool=false)
+ function message(c :: GitCommit, raw :: Bool = false)
- function meta(m::Module; autoinit::Bool=true)
+ function meta(m :: Module, autoinit :: Bool = true)
- function metadata(__source__, __module__, expr, ismodule)
+ function metadata(__source__, __module__, expr, ismodule)
- function metadata_matches(ast::Core.CodeInfo)
+ function metadata_matches(ast :: Core.CodeInfo)
- function method_argnames(m::Method)
+ function method_argnames(m :: Method)
- function method_for_inference_heuristics(method::Method, @nospecialize(sig), sparams::SimpleVector, world::UInt)
+ function method_for_inference_heuristics(method :: Method, sig, sparams :: SimpleVector, world :: UInt)
- function method_instance(f, types=Base.default_tt(f))
+ function method_instance(f, types = Base.default_tt(f))
- function method_instances(@nospecialize(f), @nospecialize(t), world::UInt)
+ function method_instances(f, t, world :: UInt)
- function methods_including_ambiguous(@nospecialize(f), @nospecialize(t))
+ function methods_including_ambiguous(f, t)
- function methodswith(@nospecialize(t::Type), @nospecialize(f::Base.Callable), meths = Method[]; supertypes::Bool=false)
+ function methodswith(t :: Type, f :: Base.Callable, meths = Method[], supertypes :: Bool = false)
- function methodswith(@nospecialize(t::Type); supertypes::Bool=false)
+ function methodswith(t :: Type, supertypes :: Bool = false)
- function micro_ker!(AB, Ac, Bc, kc, offSetA, offSetB)
+ function micro_ker!(AB, Ac, Bc, kc, offSetA, offSetB)
- function mightalias(A::SubArray{T,<:Any,P}, B::SubArray{T,<:Any,P}) where {T,P}
+ function mightalias(A :: SubArray{T, ??? <: Any, P}, B :: SubArray{T, ??? <: Any, P}) where T, P
- function min(x::T, y::T) where {T<:Union{Float32,Float64}}
+ function min(x :: T, y :: T) where T <: Union{Float32, Float64}
- function minmax(x::BigFloat, y::BigFloat)
+ function minmax(x :: BigFloat, y :: BigFloat)
- function minmax(x::T, y::T) where {T<:Union{Float32,Float64}}
+ function minmax(x :: T, y :: T) where T <: Union{Float32, Float64}
- function mk_wr(r, wr)
+ function mk_wr(r, wr)
- function mkdir(path::AbstractString; mode::Integer = 0o777)
+ function mkdir(path :: AbstractString, mode :: Integer = 0o777)
- function mkpath(path::AbstractString; mode::Integer = 0o777)
+ function mkpath(path :: AbstractString, mode :: Integer = 0o777)
- function mkpidlock(at::String, proc::Process; kwopts...)
+ function mkpidlock(at :: String, proc :: Process, kwopts...)
- function mkpidlock(f::Function, at::String, pid::Cint; kwopts...)
+ function mkpidlock(f :: Function, at :: String, pid :: Cint, kwopts...)
- function mktemp(fn::Function, parent::AbstractString=tempdir())
+ function mktemp(fn :: Function, parent :: AbstractString = tempdir())
- function mktemp(parent::AbstractString=tempdir(); cleanup::Bool=true)
+ function mktemp(parent :: AbstractString = tempdir(), cleanup :: Bool = true)
- function mktempfile(; cleanup=true)
+ function mktempfile(cleanup = true)
- function mod(x::Int128, y::Int128)
+ function mod(x :: Int128, y :: Int128)
- function mod(x::T, y::T) where T<:Integer
+ function mod(x :: T, y :: T) where T <: Integer
- function mod(x::T, y::T) where {T<:AbstractFloat}
+ function mod(x :: T, y :: T) where T <: AbstractFloat
- function mode_idx(hist::HistoryProvider, mode::TextInterface)
+ function mode_idx(hist :: HistoryProvider, mode :: TextInterface)
- function mode_keymap(julia_prompt::Prompt)
+ function mode_keymap(julia_prompt :: Prompt)
- function modf(x::BigFloat)
+ function modf(x :: BigFloat)
- function modf(x::T) where T<:IEEEFloat
+ function modf(x :: T) where T <: IEEEFloat
- function modifyproperty!(x, f::Symbol, op, v, order::Symbol=:not_atomic)
+ function modifyproperty!(x, f :: Symbol, op, v, order :: Symbol = :not_atomic)
- function module_build_id(m::Module)
+ function module_build_id(m :: Module)
- function module_depth(from::Module, to::Module)
+ function module_depth(from :: Module, to :: Module)
- function moduledoc(__source__, __module__, meta, def, def′::Expr)
+ function moduledoc(__source__, __module__, meta, def, def′ :: Expr)
- function moduleroot(m::Module)
+ function moduleroot(m :: Module)
- function modules_to_be_loaded(ast::Expr, mods::Vector{Symbol} = Symbol[])
+ function modules_to_be_loaded(ast :: Expr, mods :: Vector{Symbol} = Symbol[])
- function modulesof!(s::Set{Module}, x::Type)
+ function modulesof!(s :: Set{Module}, x :: Type)
- function month(days)
+ function month(days)
- function monthabbr(dt::TimeType; locale::AbstractString="english")
+ function monthabbr(dt :: TimeType, locale :: AbstractString = "english")
- function monthday(days)
+ function monthday(days)
- function monthname(dt::TimeType; locale::AbstractString="english")
+ function monthname(dt :: TimeType, locale :: AbstractString = "english")
- function most_general_argtypes(closure::PartialOpaque)
+ function most_general_argtypes(closure :: PartialOpaque)
- function move_cursor!(menu, direction, selected)
+ function move_cursor!(menu, direction, selected)
- function move_down!(m::AbstractMenu, cursor::Int, lastoption::Int=numoptions(m))
+ function move_down!(m :: AbstractMenu, cursor :: Int, lastoption :: Int = numoptions(m))
- function move_line_end(buf::IOBuffer)
+ function move_line_end(buf :: IOBuffer)
- function move_line_end(s::MIState)
+ function move_line_end(s :: MIState)
- function move_line_start(s::MIState)
+ function move_line_start(s :: MIState)
- function move_to_node1(t)
+ function move_to_node1(t)
- function move_up!(m::AbstractMenu, cursor::Int, lastoption::Int=numoptions(m))
+ function move_up!(m :: AbstractMenu, cursor :: Int, lastoption :: Int = numoptions(m))
- function mpfr_to_ieee(::Type{Float32}, x::BigFloat, r::MPFRRM)
+ function mpfr_to_ieee(??? :: Type{Float32}, x :: BigFloat, r :: MPFRRM)
- function mpfr_to_ieee(::Type{Float64}, x::BigFloat, r::MPFRRM)
+ function mpfr_to_ieee(??? :: Type{Float64}, x :: BigFloat, r :: MPFRRM)
- function mpfr_to_ieee(::Type{G}, x::BigFloat, r::RoundingMode) where {G}
+ function mpfr_to_ieee(??? :: Type{G}, x :: BigFloat, r :: RoundingMode) where G
- function mre34206(a, n)
+ function mre34206(a, n)
- function mt_pop!(r::MersenneTwister, ::Type{T}) where T<:BitInteger
+ function mt_pop!(r :: MersenneTwister, ??? :: Type{T}) where T <: BitInteger
- function mt_pop!(r::MersenneTwister, ::Type{T}) where {T<:Union{Int128,UInt128}}
+ function mt_pop!(r :: MersenneTwister, ??? :: Type{T}) where T <: Union{Int128, UInt128}
- function mt_setfull!(r::MersenneTwister, ::Type{<:BitInteger})
+ function mt_setfull!(r :: MersenneTwister, ??? :: Type{??? <: BitInteger})
- function mtest_create_strings()
+ function mtest_create_strings
- function mtest_remotecall_fetch()
+ function mtest_remotecall_fetch
- function mul!(C::AbstractVecOrMat{T}, A::AbstractVecOrMat, Q::AbstractQ{T}) where {T}
+ function mul!(C :: AbstractVecOrMat{T}, A :: AbstractVecOrMat, Q :: AbstractQ{T}) where T
- function mul!(C::AbstractVecOrMat{T}, Q::AbstractQ{T}, B::Union{AbstractVecOrMat,AbstractQ}) where {T}
+ function mul!(C :: AbstractVecOrMat{T}, Q :: AbstractQ{T}, B :: Union{AbstractVecOrMat, AbstractQ}) where T
- function mul!(out::AbstractMatrix{T}, a::Number, B::UniformScaling, alpha::Number, β::Number) where {T}
+ function mul!(out :: AbstractMatrix{T}, a :: Number, B :: UniformScaling, alpha :: Number, β :: Number) where T
- function mul!(z::Rational{BigInt}, x::Rational{BigInt}, y::Rational{BigInt})
+ function mul!(z :: Rational{BigInt}, x :: Rational{BigInt}, y :: Rational{BigInt})
- function mul(a::Vector{BigInt}, b::Vector{BigInt})
+ function mul(a :: Vector{BigInt}, b :: Vector{BigInt})
- function mul12(x::T, y::T) where {T<:AbstractFloat}
+ function mul12(x :: T, y :: T) where T <: AbstractFloat
- function mul_with_overflow(x::T, y::T) where T<:BrokenSignedIntMul
+ function mul_with_overflow(x :: T, y :: T) where T <: BrokenSignedIntMul
- function mul_with_overflow(x::T, y::T) where T<:BrokenUnsignedIntMul
+ function mul_with_overflow(x :: T, y :: T) where T <: BrokenUnsignedIntMul
- function mul_with_overflow(x::T, y::T) where T<:Int128
+ function mul_with_overflow(x :: T, y :: T) where T <: Int128
- function mul_with_overflow(x::T, y::T) where T<:UInt128
+ function mul_with_overflow(x :: T, y :: T) where T <: UInt128
- function mulshift(m::U, mul, j) where {U<:Unsigned}
+ function mulshift(m :: U, mul, j) where U <: Unsigned
- function mulshiftinvsplit(::Type{T}, mv, mp, mm, i, j) where {T}
+ function mulshiftinvsplit(??? :: Type{T}, mv, mp, mm, i, j) where T
- function mulshiftmod1e9(m, mula, mulb, mulc, j)
+ function mulshiftmod1e9(m, mula, mulb, mulc, j)
- function mulshiftsplit(::Type{T}, mv, mp, mm, i, j) where {T}
+ function mulshiftsplit(??? :: Type{T}, mv, mp, mm, i, j) where T
- function multidoc(__source__, __module__, meta, ex::Expr, define::Bool)
+ function multidoc(__source__, __module__, meta, ex :: Expr, define :: Bool)
- function multiiterate_read(arr1, arr2)
+ function multiiterate_read(arr1, arr2)
- function multiiterate_write!(arr1, arr2)
+ function multiiterate_write!(arr1, arr2)
- function multiiterate_write(arr1, arr2, arr3)
+ function multiiterate_write(arr1, arr2, arr3)
- function multiple_uv_errors(pfx::AbstractString, codes::AbstractVector{<:Integer})
+ function multiple_uv_errors(pfx :: AbstractString, codes :: AbstractVector{??? <: Integer})
- function multiq_check_empty()
+ function multiq_check_empty
- function multiq_deletemin()
+ function multiq_deletemin
- function multiq_insert(task::Task, priority::UInt16)
+ function multiq_insert(task :: Task, priority :: UInt16)
- function multiq_sift_down(heap::taskheap, idx::Int32)
+ function multiq_sift_down(heap :: taskheap, idx :: Int32)
- function multiq_sift_up(heap::taskheap, idx::Int32)
+ function multiq_sift_up(heap :: taskheap, idx :: Int32)
- function multiq_size(tpid::Int8)
+ function multiq_size(tpid :: Int8)
- function mulxmod!(f::GF2X, m::GF2X, deg=degree(m))::GF2X
+ function mulxmod!(f :: GF2X, m :: GF2X, deg = degree(m))
- function mut50285(b, x, y)
+ function mut50285(b, x, y)
- function mutable_consistent(s)
+ function mutable_consistent(s)
- function mv(src::AbstractString, dst::AbstractString; force::Bool=false)
+ function mv(src :: AbstractString, dst :: AbstractString, force :: Bool = false)
- function mv_check(s, d, d_mv, file_txt; force=true)
+ function mv_check(s, d, d_mv, file_txt, force = true)
- function mv_check(s, d, d_mv; force=true)
+ function mv_check(s, d, d_mv, force = true)
- function my_simple_count(pred, g::Vector{T}) where {T}
+ function my_simple_count(pred, g :: Vector{T}) where T
- function myapp()
+ function myapp
- function mycompare(a, b)::Cint
+ function mycompare(a, b)
- function mytype(vec)
+ function mytype(vec)
- function n_avail(c::Channel)
+ function n_avail(c :: Channel)
- function nagle(sock::Union{TCPServer, TCPSocket}, enable::Bool)
+ function nagle(sock :: Union{TCPServer, TCPSocket}, enable :: Bool)
- function naive_idoms(blocks::Vector{BasicBlock}, is_post_dominator::Bool=false)
+ function naive_idoms(blocks :: Vector{BasicBlock}, is_post_dominator :: Bool = false)
- function name(ref::GitReference)
+ function name(ref :: GitReference)
- function name(rmt::GitRemote)
+ function name(rmt :: GitRemote)
- function name(tag::GitTag)
+ function name(tag :: GitTag)
- function nameof(f::Core.IntrinsicFunction)
+ function nameof(f :: Core.IntrinsicFunction)
- function nameof(f::Function)
+ function nameof(f :: Function)
- function narguments(sv::InferenceState, include_va::Bool=true)
+ function narguments(sv :: InferenceState, include_va :: Bool = true)
- function narrow_opaque_closure!(ir::IRCode, stmt::Expr, @nospecialize(info::CallInfo), state::InliningState)
+ function narrow_opaque_closure!(ir :: IRCode, stmt :: Expr, info :: CallInfo, state :: InliningState)
- function ncalls_in_lowered(ex, fname)
+ function ncalls_in_lowered(ex, fname)
- function ndigits0z(x::Integer, b::Integer)
+ function ndigits0z(x :: Integer, b :: Integer)
- function ndigits0znb(x::Integer, b::Integer)
+ function ndigits0znb(x :: Integer, b :: Integer)
- function ndigits0zpb(x::BigInt, b::Integer)
+ function ndigits0zpb(x :: BigInt, b :: Integer)
- function ndigits0zpb(x::Integer, b::Integer)
+ function ndigits0zpb(x :: Integer, b :: Integer)
- function nearest_common_dominator(domtree::GenericDomTree, a::BBNumber, b::BBNumber)
+ function nearest_common_dominator(domtree :: GenericDomTree, a :: BBNumber, b :: BBNumber)
- function need_update(repo::GitRepo)
+ function need_update(repo :: GitRepo)
- function nested_mutable_consistent(s)
+ function nested_mutable_consistent(s)
- function new_expr_effect_flags(Lₒ::AbstractLattice, args::Vector{Any}, src::Union{IRCode,IncrementalCompact}, pattern_match=nothing)
+ function new_expr_effect_flags(Lₒ :: AbstractLattice, args :: Vector{Any}, src :: Union{IRCode, IncrementalCompact}, pattern_match = nothing)
- function new_genericmemory_nothrow(@nospecialize(abstract_eval), args::Vector{Any})
+ function new_genericmemory_nothrow(abstract_eval, args :: Vector{Any})
- function new_nodes_iter(compact::IncrementalCompact)
+ function new_nodes_iter(compact :: IncrementalCompact)
- function new_nodes_iter(ir::IRCode, new_nodes_idx=1)
+ function new_nodes_iter(ir :: IRCode, new_nodes_idx = 1)
- function new_state()
+ function new_state
- function new_to_regular(@nospecialize(stmt), new_offset::Int)
+ function new_to_regular(stmt, new_offset :: Int)
- function newexpand41096(gen, name::Symbol)
+ function newexpand41096(gen, name :: Symbol)
- function next(h::HashState)
+ function next(h :: HashState)
- function nextfloat!(x::BigFloat, n::Integer=1)
+ function nextfloat!(x :: BigFloat, n :: Integer = 1)
- function nextfloat(f::IEEEFloat, d::Integer)
+ function nextfloat(f :: IEEEFloat, d :: Integer)
- function nextind(s::AbstractString, i::Int, n::Int)
+ function nextind(s :: AbstractString, i :: Int, n :: Int)
- function nextpow(a::Real, x::Real)
+ function nextpow(a :: Real, x :: Real)
- function nextprod(a::Union{Tuple{Vararg{Integer}},AbstractVector{<:Integer}}, x::Real)
+ function nextprod(a :: Union{Tuple{Vararg{Integer}}, AbstractVector{??? <: Integer}}, x :: Real)
- function nmatches(info::UnionSplitInfo)
+ function nmatches(info :: UnionSplitInfo)
- function no_op_refint(r)
+ function no_op_refint(r)
- function noinline_finalizer(d)
+ function noinline_finalizer(d)
- function non_dce_finish!(compact::IncrementalCompact)
+ function non_dce_finish!(compact :: IncrementalCompact)
- function noncallable_number_hint_handler(io, ex, arg_types, kwargs)
+ function noncallable_number_hint_handler(io, ex, arg_types, kwargs)
- function nonmissingtype_checked(T::Type)
+ function nonmissingtype_checked(T :: Type)
- function nonnothingtype_checked(T::Type)
+ function nonnothingtype_checked(T :: Type)
- function nonzero_chunks(chunks::Vector{UInt64}, pos0::Int, pos1::Int)
+ function nonzero_chunks(chunks :: Vector{UInt64}, pos0 :: Int, pos1 :: Int)
- function nopreserve()
+ function nopreserve
- function norm(itr, p::Real=2)
+ function norm(itr, p :: Real = 2)
- function norm(x::StridedVector{T}, rx::Union{UnitRange{TI},AbstractRange{TI}}) where {T<:BlasFloat,TI<:Integer}
+ function norm(x :: StridedVector{T}, rx :: Union{UnitRange{TI}, AbstractRange{TI}}) where T <: BlasFloat, TI <: Integer
- function normalize!(a::AbstractArray, p::Real=2)
+ function normalize!(a :: AbstractArray, p :: Real = 2)
- function normalize(a::AbstractArray, p::Real = 2)
+ function normalize(a :: AbstractArray, p :: Real = 2)
- function normalize(s::AbstractString, nf::Symbol)
+ function normalize(s :: AbstractString, nf :: Symbol)
- function normalize_arch(arch::String)
+ function normalize_arch(arch :: String)
- function normalize_key(key::Union{String,SubString{String}})
+ function normalize_key(key :: Union{String, SubString{String}})
- function normalize_keys(keymap::Union{Dict{Char,Any},AnyDict})
+ function normalize_keys(keymap :: Union{Dict{Char, Any}, AnyDict})
- function normalize_method_name(m)
+ function normalize_method_name(m)
- function normalize_typevars(method::Method, @nospecialize(atype), sparams::SimpleVector)
+ function normalize_typevars(method :: Method, atype, sparams :: SimpleVector)
- function normpath(path::String)
+ function normpath(path :: String)
- function note_block_use!(usebb::Int, useidx::Int)
+ function note_block_use!(usebb :: Int, useidx :: Int)
- function nothrow_try_catch()
+ function nothrow_try_catch
- function notify(c::GenericCondition, @nospecialize(arg), all, error)
+ function notify(c :: GenericCondition, arg, all, error)
- function notify(e::Event)
+ function notify(e :: Event)
- function notify_filled(buffer::IOBuffer, nread::Int)
+ function notify_filled(buffer :: IOBuffer, nread :: Int)
- function now()
+ function now
- function nrm2(x::AbstractArray)
+ function nrm2(x :: AbstractArray)
- function nt_from_abstractly_typed_array()
+ function nt_from_abstractly_typed_array
- function nt_splat_const()
+ function nt_splat_const
- function nt_splat_partial(x::Int)
+ function nt_splat_partial(x :: Int)
- function nth_with(f, n)
+ function nth_with(f, n)
- function ntupleany(f, n)
+ function ntupleany(f, n)
- function nullspace(A::AbstractVecOrMat; atol::Real = 0.0, rtol::Real = (min(size(A, 1), size(A, 2))*eps(real(float(oneunit(eltype(A))))))*iszero(atol))
+ function nullspace(A :: AbstractVecOrMat, atol :: Real = 0.0, rtol :: Real = (min(size(A,1),size(A,2))*eps(real(float(oneunit(eltype(A))))))*iszero(atol))
- function num_obj_sweeps()
+ function num_obj_sweeps
- function numbered_prompt!(repl::LineEditREPL=Base.active_repl, backend=nothing)
+ function numbered_prompt!(repl :: LineEditREPL = Base.active_repl, backend = nothing)
- function nvalid(mi::Core.MethodInstance)
+ function nvalid(mi :: Core.MethodInstance)
- function object_number(s::AbstractSerializer, @nospecialize(l))
+ function object_number(s :: AbstractSerializer, l)
- function objectdoc(__source__, __module__, str, def, expr, sig = :(Union{}))
+ function objectdoc(__source__, __module__, str, def, expr, sig = :(Union{}))
- function objectid(x)
+ function objectid(x)
- function objtype(obj_type::Consts.OBJECT)
+ function objtype(obj_type :: Consts.OBJECT)
- function oc_capture_oc(z)
+ function oc_capture_oc(z)
- function oc_varargs_constprop()
+ function oc_varargs_constprop
- function occursin(delim::UInt8, buf::GenericIOBuffer)
+ function occursin(delim :: UInt8, buf :: GenericIOBuffer)
- function occursin(delim::UInt8, buf::IOBuffer)
+ function occursin(delim :: UInt8, buf :: IOBuffer)
- function occursin(pattern::Tuple, r::LogRecord)
+ function occursin(pattern :: Tuple, r :: LogRecord)
- function occursin(r::Regex, s::AbstractString; offset::Integer=0)
+ function occursin(r :: Regex, s :: AbstractString, offset :: Integer = 0)
- function occursin(r::Regex, s::SubString{String}; offset::Integer=0)
+ function occursin(r :: Regex, s :: SubString{String}, offset :: Integer = 0)
- function oct(x::Unsigned, pad::Int, neg::Bool)
+ function oct(x :: Unsigned, pad :: Int, neg :: Bool)
- function offset_coerce(::Type{Base.OneTo{T}}, r::AbstractUnitRange) where T<:Integer
+ function offset_coerce(??? :: Type{Base.OneTo{T}}, r :: AbstractUnitRange) where T <: Integer
- function oldvect(X...)
+ function oldvect(X...)
- function on_semidominator_path(domtree::DomTree, x::BBNumber, y::BBNumber)
+ function on_semidominator_path(domtree :: DomTree, x :: BBNumber, y :: BBNumber)
- function once_removed()
+ function once_removed
- function one(x::BitMatrix)
+ function one(x :: BitMatrix)
- function onediag(T::Type, m::Integer, n::Integer)
+ function onediag(T :: Type, m :: Integer, n :: Integer)
- function onediag_sparse(T::Type, n::Integer)
+ function onediag_sparse(T :: Type, n :: Integer)
- function open(cmds::AbstractCmd, mode::AbstractString, stdio::Redirectable=devnull)
+ function open(cmds :: AbstractCmd, mode :: AbstractString, stdio :: Redirectable = devnull)
- function open(cmds::AbstractCmd, stdio::Redirectable=devnull; write::Bool=false, read::Bool=!write)
+ function open(cmds :: AbstractCmd, stdio :: Redirectable = devnull, write :: Bool = false, read :: Bool = !write)
- function open(f::Function, args...; kwargs...)
+ function open(f :: Function, args..., kwargs...)
- function open(f::Function, cmds::AbstractCmd, args...; kwargs...)
+ function open(f :: Function, cmds :: AbstractCmd, args..., kwargs...)
- function open(fd::RawFD)
+ function open(fd :: RawFD)
- function open(fname::AbstractString, mode::AbstractString; lock = true)
+ function open(fname :: AbstractString, mode :: AbstractString, lock = true)
- function open(h::OS_HANDLE)
+ function open(h :: OS_HANDLE)
- function open(path::AbstractString, flags::Integer, mode::Integer=0)
+ function open(path :: AbstractString, flags :: Integer, mode :: Integer = 0)
- function open_fake_pty()
+ function open_fake_pty
- function open_libllvm(f::Function)
+ function open_libllvm(f :: Function)
- function open_pipe!(p::PipeEndpoint, handle::OS_HANDLE)
+ function open_pipe!(p :: PipeEndpoint, handle :: OS_HANDLE)
- function operator_associativity(s::Symbol)
+ function operator_associativity(s :: Symbol)
- function opnorm(A::AbstractMatrix, p::Real=2)
+ function opnorm(A :: AbstractMatrix, p :: Real = 2)
- function opnorm1(A::AbstractMatrix{T}) where T
+ function opnorm1(A :: AbstractMatrix{T}) where T
- function opnorm2(A::AbstractMatrix{T}) where T
+ function opnorm2(A :: AbstractMatrix{T}) where T
- function opnormInf(A::AbstractMatrix{T}) where T
+ function opnormInf(A :: AbstractMatrix{T}) where T
- function optimize(interp::AbstractInterpreter, opt::OptimizationState, caller::InferenceResult)
+ function optimize(interp :: AbstractInterpreter, opt :: OptimizationState, caller :: InferenceResult)
- function optimize_throw_block_for_effects(x)
+ function optimize_throw_block_for_effects(x)
- function oracle_check(compact::IncrementalCompact)
+ function oracle_check(compact :: IncrementalCompact)
- function ord(lt, by, rev::Bool, order::Ordering=Forward)
+ function ord(lt, by, rev :: Bool, order :: Ordering = Forward)
- function ordschur!(gschur::GeneralizedSchur, select::Union{Vector{Bool},BitVector})
+ function ordschur!(gschur :: GeneralizedSchur, select :: Union{Vector{Bool}, BitVector})
- function ordschur!(schur::Schur, select::Union{Vector{Bool},BitVector})
+ function ordschur!(schur :: Schur, select :: Union{Vector{Bool}, BitVector})
- function os()
+ function os
- function os_str(p::AbstractPlatform)
+ function os_str(p :: AbstractPlatform)
- function out_transform(@nospecialize(x), n::Ref{Int})
+ function out_transform(x, n :: Ref{Int})
- function output(b)
+ function output(b)
- function outputline(io, name)
+ function outputline(io, name)
- function ovec_length(match_data)
+ function ovec_length(match_data)
- function ovec_ptr(match_data)
+ function ovec_ptr(match_data)
- function overallocation(maxsize)
+ function overallocation(maxsize)
- function overdub_generator(world::UInt, source, self, c, f, args)
+ function overdub_generator(world :: UInt, source, self, c, f, args)
- function overflow_check(r::AbstractUnitRange, offset::Integer)
+ function overflow_check(r :: AbstractUnitRange, offset :: Integer)
- function overlay_def!(mt, @nospecialize ex)
+ function overlay_def!(mt, ex)
- function p7zip(; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
+ function p7zip(adjust_PATH :: Bool = true, adjust_LIBPATH :: Bool = true)
- function p7zip(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
+ function p7zip(f :: Function, adjust_PATH :: Bool = true, adjust_LIBPATH :: Bool = true)
- function pack(A, uplo)
+ function pack(A, uplo)
- function pack8bools(z::UInt64)
+ function pack8bools(z :: UInt64)
- function pack_platform!(meta::Dict, p::AbstractPlatform)
+ function pack_platform!(meta :: Dict, p :: AbstractPlatform)
- function package_slug(uuid::UUID, p::Int=5)
+ function package_slug(uuid :: UUID, p :: Int = 5)
- function pad(a, b)
+ function pad(a, b)
- function pad(a, b, c)
+ function pad(a, b, c)
- function padcells!(rows, align; len = length, min = 0)
+ function padcells!(rows, align, len = length, min = 0)
- function padded_nonzero_print(value, str, always_print = true)
+ function padded_nonzero_print(value, str, always_print = true)
- function page_down!(m::AbstractMenu, cursor::Int, lastoption::Int=numoptions(m))
+ function page_down!(m :: AbstractMenu, cursor :: Int, lastoption :: Int = numoptions(m))
- function page_up!(m::AbstractMenu, cursor::Int, lastoption::Int=numoptions(m))
+ function page_up!(m :: AbstractMenu, cursor :: Int, lastoption :: Int = numoptions(m))
- function pager(terminal, object)
+ function pager(terminal, object)
- function paragraph(stream::IO, md::MD)
+ function paragraph(stream :: IO, md :: MD)
- function parameter_upper_bound(t::UnionAll, idx)
+ function parameter_upper_bound(t :: UnionAll, idx)
- function parent(c::GitCommit, n)
+ function parent(c :: GitCommit, n)
- function parent_call(f, x)
+ function parent_call(f, x)
- function parent_id(c::GitCommit, n)
+ function parent_id(c :: GitCommit, n)
- function parentmodule(@nospecialize(f), @nospecialize(types))
+ function parentmodule(f, types)
- function parentmodule_before_main(m::Module)
+ function parentmodule_before_main(m :: Module)
- function parse(::Type{IPAddr}, str::AbstractString)
+ function parse(??? :: Type{IPAddr}, str :: AbstractString)
- function parse(::Type{IPv4}, str::AbstractString)
+ function parse(??? :: Type{IPv4}, str :: AbstractString)
- function parse(::Type{IPv6}, str::AbstractString)
+ function parse(??? :: Type{IPv6}, str :: AbstractString)
- function parse(::Type{Rational{T}}, s::AbstractString) where T<:Integer
+ function parse(??? :: Type{Rational{T}}, s :: AbstractString) where T <: Integer
- function parse(::Type{T}, c::AbstractChar; base::Integer = 10) where T<:Integer
+ function parse(??? :: Type{T}, c :: AbstractChar, base :: Integer = 10) where T <: Integer
- function parse(::Type{T}, s::AbstractString; base::Union{Nothing,Integer} = nothing) where {T<:Integer}
+ function parse(??? :: Type{T}, s :: AbstractString, base :: Union{Nothing, Integer} = nothing) where T <: Integer
- function parse(::Type{VersionNumber}, v::AbstractString)
+ function parse(??? :: Type{VersionNumber}, v :: AbstractString)
- function parse(l::Parser)::TOMLDict
+ function parse(l :: Parser)
- function parse(stream::IO, block::MD, config::Config; breaking = false)
+ function parse(stream :: IO, block :: MD, config :: Config, breaking = false)
- function parse(stream::IO; flavor = julia)
+ function parse(stream :: IO, flavor = julia)
- function parse_array(l::Parser)::Err{Vector}
+ function parse_array(l :: Parser)
- function parse_array_table(l)::Union{Nothing, ParserError}
+ function parse_array_table(l)
- function parse_bool(l::Parser, v::Bool)::Union{Bool, Nothing}
+ function parse_bool(l :: Parser, v :: Bool)
- function parse_cache_header(cachefile::String)
+ function parse_cache_header(cachefile :: String)
- function parse_cache_header(f::IO, cachefile::AbstractString)
+ function parse_cache_header(f :: IO, cachefile :: AbstractString)
- function parse_datetime(l)
+ function parse_datetime(l)
- function parse_dl_name_version(path::AbstractString, os::AbstractString)
+ function parse_dl_name_version(path :: AbstractString, os :: AbstractString)
- function parse_dl_name_version(path::String, os::String)
+ function parse_dl_name_version(path :: String, os :: String)
- function parse_entry(l::Parser, d)::Union{Nothing, ParserError}
+ function parse_entry(l :: Parser, d)
- function parse_flat(::Type{T}, data::Vector{Alloc}, C::Bool) where T
+ function parse_flat(??? :: Type{T}, data :: Vector{Alloc}, C :: Bool) where T
- function parse_float(l::Parser, contains_underscore)::Err{Float64}
+ function parse_float(l :: Parser, contains_underscore)
- function parse_image_target(io::IO)
+ function parse_image_target(io :: IO)
- function parse_image_targets(targets::Vector{UInt8})
+ function parse_image_targets(targets :: Vector{UInt8})
- function parse_inline_table(l::Parser)::Err{TOMLDict}
+ function parse_inline_table(l :: Parser)
- function parse_inline_wrapper(stream::IO, delimiter::AbstractString; rep = false)
+ function parse_inline_wrapper(stream :: IO, delimiter :: AbstractString, rep = false)
- function parse_input_line(s::String; filename::String="none", depwarn=true)
+ function parse_input_line(s :: String, filename :: String = "none", depwarn = true)
- function parse_iteration_space(x)
+ function parse_iteration_space(x)
- function parse_key(l::Parser)
+ function parse_key(l :: Parser)
- function parse_level(level::Symbol)
+ function parse_level(level :: Symbol)
- function parse_load_path(str::String)
+ function parse_load_path(str :: String)
- function parse_local_time(l::Parser)
+ function parse_local_time(l :: Parser)
- function parse_mapping(mapping::Dict, name::String, override_file::String)
+ function parse_mapping(mapping :: Dict, name :: String, override_file :: String)
- function parse_mapping(mapping::String, name::String, override_file::String)
+ function parse_mapping(mapping :: String, name :: String, override_file :: String)
- function parse_number_or_date_start(l::Parser)
+ function parse_number_or_date_start(l :: Parser)
- function parse_pidfile(io::IO)
+ function parse_pidfile(io :: IO)
- function parse_pidfile(path::String)
+ function parse_pidfile(path :: String)
- function parse_string_continue(l::Parser, multiline::Bool, quoted::Bool)::Err{String}
+ function parse_string_continue(l :: Parser, multiline :: Bool, quoted :: Bool)
- function parse_string_start(l::Parser, quoted::Bool)::Err{String}
+ function parse_string_start(l :: Parser, quoted :: Bool)
- function parse_table(l)
+ function parse_table(l)
- function parse_testset_args(args)
+ function parse_testset_args(args)
- function parse_toml(path::String)
+ function parse_toml(path :: String)
- function parse_toplevel(l::Parser)::Err{Nothing}
+ function parse_toplevel(l :: Parser)
- function parse_value(l::Parser)
+ function parse_value(l :: Parser)
- function parsealign(row)
+ function parsealign(row)
- function parseall(text::AbstractString; filename="none", lineno=1)
+ function parseall(text :: AbstractString, filename = "none", lineno = 1)
- function parseall_nolines(str)
+ function parseall_nolines(str)
- function parseatom(text::AbstractString, pos::Integer; filename="none", lineno=1)
+ function parseatom(text :: AbstractString, pos :: Integer, filename = "none", lineno = 1)
- function parsed_toml(project_file::AbstractString, toml_cache::TOMLCache, toml_lock::ReentrantLock)
+ function parsed_toml(project_file :: AbstractString, toml_cache :: TOMLCache, toml_lock :: ReentrantLock)
- function parsedoc(d::DocStr)
+ function parsedoc(d :: DocStr)
- function parseinline(stream::IO, md::MD, config::Config)
+ function parseinline(stream :: IO, md :: MD, config :: Config)
- function parseinline(stream::IO, md::MD, parsers::Vector{Function})
+ function parseinline(stream :: IO, md :: MD, parsers :: Vector{Function})
- function parseint_iterate(s::AbstractString, startpos::Int, endpos::Int)
+ function parseint_iterate(s :: AbstractString, startpos :: Int, endpos :: Int)
- function parseint_preamble(signed::Bool, base::Int, s::AbstractString, startpos::Int, endpos::Int)
+ function parseint_preamble(signed :: Bool, base :: Int, s :: AbstractString, startpos :: Int, endpos :: Int)
- function parseipv6fields(fields,num_fields)
+ function parseipv6fields(fields, num_fields)
- function parserow(stream::IO)
+ function parserow(stream :: IO)
- function partialsort!(v::AbstractVector, k::Union{Integer,OrdinalRange}, o::Ordering)
+ function partialsort!(v :: AbstractVector, k :: Union{Integer, OrdinalRange}, o :: Ordering)
- function partition!(v::AbstractVector, lo::Integer, hi::Integer, o::Ordering)
+ function partition!(v :: AbstractVector, lo :: Integer, hi :: Integer, o :: Ordering)
- function path(repo::GitRepo)
+ function path(repo :: GitRepo)
- function pathof(m::Module)
+ function pathof(m :: Module)
- function peakflops(n::Integer=4096; eltype::DataType=Float64, ntrials::Integer=3, parallel::Bool=false)
+ function peakflops(n :: Integer = 4096, eltype :: DataType = Float64, ntrials :: Integer = 3, parallel :: Bool = false)
- function peek(from::GenericIOBuffer, ::Type{UInt8})
+ function peek(from :: GenericIOBuffer, ??? :: Type{UInt8})
- function peek(from::GenericIOBuffer, T::Union{Type{Int16},Type{UInt16},Type{Int32},Type{UInt32},Type{Int64},Type{UInt64},Type{Int128},Type{UInt128},Type{Float16},Type{Float32},Type{Float64}})
+ function peek(from :: GenericIOBuffer, T :: Union{Type{Int16}, Type{UInt16}, Type{Int32}, Type{UInt32}, Type{Int64}, Type{UInt64}, Type{Int128}, Type{UInt128}, Type{Float16}, Type{Float32}, Type{Float64}})
- function peek(io::SecretBuffer, ::Type{UInt8})
+ function peek(io :: SecretBuffer, ??? :: Type{UInt8})
- function peek(s::IO, ::Type{T}) where T
+ function peek(s :: IO, ??? :: Type{T}) where T
- function peek(s::IOStream, ::Type{UInt8})
+ function peek(s :: IOStream, ??? :: Type{UInt8})
- function peek(s::LibuvStream, ::Type{T}) where T
+ function peek(s :: LibuvStream, ??? :: Type{T}) where T
- function peel(::Type{T}, obj::GitObject) where T<:GitObject
+ function peel(??? :: Type{T}, obj :: GitObject) where T <: GitObject
- function peel(::Type{T}, ref::GitReference) where T<:GitObject
+ function peel(??? :: Type{T}, ref :: GitReference) where T <: GitObject
- function peel(itr)
+ function peel(itr)
- function percolate_down!(xs::Vector, i::Integer, x, o::Ordering, len::Integer=length(xs))
+ function percolate_down!(xs :: Vector, i :: Integer, x, o :: Ordering, len :: Integer = length(xs))
- function percolate_up!(xs::Vector, i::Integer, x, o::Ordering)
+ function percolate_up!(xs :: Vector, i :: Integer, x, o :: Ordering)
- function permutecols!!(a::AbstractMatrix, p::AbstractVector{<:Integer})
+ function permutecols!!(a :: AbstractMatrix, p :: AbstractVector{??? <: Integer})
- function permutedims!(dest, src::AbstractArray, perm)
+ function permutedims!(dest, src :: AbstractArray, perm)
- function permutedims(A::AbstractArray, perm)
+ function permutedims(A :: AbstractArray, perm)
- function permutedims(B::Bidiagonal, perm)
+ function permutedims(B :: Bidiagonal, perm)
- function permutedims(B::StridedArray, perm)
+ function permutedims(B :: StridedArray, perm)
- function permutedims(S::SymTridiagonal, perm)
+ function permutedims(S :: SymTridiagonal, perm)
- function permutedims(T::Tridiagonal, perm)
+ function permutedims(T :: Tridiagonal, perm)
- function pfd_tst_reads(idx, intvl)
+ function pfd_tst_reads(idx, intvl)
- function pfd_tst_timeout(idx, intvl)
+ function pfd_tst_timeout(idx, intvl)
- function pfib(n::Int)
+ function pfib(n :: Int)
- function phi_or_ifelse_predecessors(@nospecialize(def), compact::IncrementalCompact)
+ function phi_or_ifelse_predecessors(def, compact :: IncrementalCompact)
- function phic_type1()
+ function phic_type1
- function phic_type10()
+ function phic_type10
- function phic_type2()
+ function phic_type2
- function phic_type3()
+ function phic_type3
- function phic_type4()
+ function phic_type4
- function phic_type5()
+ function phic_type5
- function phic_type6()
+ function phic_type6
- function phic_type7()
+ function phic_type7
- function phic_type8()
+ function phic_type8
- function phic_type9()
+ function phic_type9
- function pi_on_argument(x)
+ function pi_on_argument(x)
- function pick(menu::MultiSelectMenu, cursor::Int)
+ function pick(menu :: MultiSelectMenu, cursor :: Int)
- function pick(menu::RadioMenu, cursor::Int)
+ function pick(menu :: RadioMenu, cursor :: Int)
- function pick_const_args!(L::AbstractLattice, cache_argtypes::Vector{Any}, overridden_by_const::BitVector, given_argtypes::Vector{Any})
+ function pick_const_args!(L :: AbstractLattice, cache_argtypes :: Vector{Any}, overridden_by_const :: BitVector, given_argtypes :: Vector{Any})
- function pick_const_args(L::AbstractLattice, linfo::MethodInstance, given_argtypes::Vector{Any})
+ function pick_const_args(L :: AbstractLattice, linfo :: MethodInstance, given_argtypes :: Vector{Any})
- function pickvarnames(x::Vector{Any})
+ function pickvarnames(x :: Vector{Any})
- function pickvarnames2(x::Vector{Any})
+ function pickvarnames2(x :: Vector{Any})
- function pinv(A::AbstractMatrix{T}; atol::Real = 0.0, rtol::Real = (eps(real(float(oneunit(T))))*min(size(A)...))*iszero(atol)) where T
+ function pinv(A :: AbstractMatrix{T}, atol :: Real = 0.0, rtol :: Real = (eps(real(float(oneunit(T))))*min(size(A)...))*iszero(atol)) where T
- function pinv(D::Diagonal{T}) where T
+ function pinv(D :: Diagonal{T}) where T
- function pinv(D::Diagonal{T}, tol::Real) where T
+ function pinv(D :: Diagonal{T}, tol :: Real) where T
- function pinv(x::Number)
+ function pinv(x :: Number)
- function pipeline(cmd::AbstractCmd; stdin=nothing, stdout=nothing, stderr=nothing, append::Bool=false)
+ function pipeline(cmd :: AbstractCmd, stdin = nothing, stdout = nothing, stderr = nothing, append :: Bool = false)
- function pipeline_error(proc::Process)
+ function pipeline_error(proc :: Process)
- function pipeline_error(procs::ProcessChain)
+ function pipeline_error(procs :: ProcessChain)
- function pkg_str(_pkg::PkgId)
+ function pkg_str(_pkg :: PkgId)
- function pkgdir(m::Module, paths::String...)
+ function pkgdir(m :: Module, paths :: String...)
- function pkgversion(m::Module)
+ function pkgversion(m :: Module)
- function plain(io::IO, code::Code)
+ function plain(io :: IO, code :: Code)
- function plain(io::IO, content::Vector)
+ function plain(io :: IO, content :: Vector)
- function plain(io::IO, f::Footnote)
+ function plain(io :: IO, f :: Footnote)
- function plain(io::IO, header::Header{l}) where l
+ function plain(io :: IO, header :: Header{l}) where l
- function plain(io::IO, l::LaTeX)
+ function plain(io :: IO, l :: LaTeX)
- function plain(io::IO, list::List)
+ function plain(io :: IO, list :: List)
- function plain(io::IO, md)
+ function plain(io :: IO, md)
- function plain(io::IO, md::Admonition)
+ function plain(io :: IO, md :: Admonition)
- function plain(io::IO, md::HorizontalRule)
+ function plain(io :: IO, md :: HorizontalRule)
- function plain(io::IO, md::Table)
+ function plain(io :: IO, md :: Table)
- function plain(io::IO, p::Paragraph)
+ function plain(io :: IO, p :: Paragraph)
- function plain(io::IO, q::BlockQuote)
+ function plain(io :: IO, q :: BlockQuote)
- function plaininline(io::IO, md...)
+ function plaininline(io :: IO, md...)
- function plaininline(io::IO, md::Code)
+ function plaininline(io :: IO, md :: Code)
- function platform_dlext(p::AbstractPlatform = HostPlatform())
+ function platform_dlext(p :: AbstractPlatform = HostPlatform())
- function platform_name(p::AbstractPlatform)
+ function platform_name(p :: AbstractPlatform)
- function platforms_match(a::AbstractPlatform, b::AbstractPlatform)
+ function platforms_match(a :: AbstractPlatform, b :: AbstractPlatform)
- function platforms_match(a::AbstractPlatform, b::String)
+ function platforms_match(a :: AbstractPlatform, b :: String)
- function platforms_match(a::String, b::AbstractPlatform)
+ function platforms_match(a :: String, b :: AbstractPlatform)
- function plength(f::Spec{T}, x) where {T <: Chars}
+ function plength(f :: Spec{T}, x) where T <: Chars
- function plength(f::Spec{T}, x) where {T <: Ints}
+ function plength(f :: Spec{T}, x) where T <: Ints
- function plength(f::Spec{T}, x) where {T <: Strings}
+ function plength(f :: Spec{T}, x) where T <: Strings
- function point_to_line(str::AbstractString, a::Int, b::Int, context)
+ function point_to_line(str :: AbstractString, a :: Int, b :: Int, context)
- function pointer(V::SubArray{<:Any,<:Any,<:Array,<:Tuple{Vararg{RangeIndex}}}, is::AbstractCartesianIndex{N}) where {N}
+ function pointer(V :: SubArray{??? <: Any, ??? <: Any, ??? <: Array, ??? <: Tuple{Vararg{RangeIndex}}}, is :: AbstractCartesianIndex{N}) where N
- function pointer(x::AbstractArray{T}, i::Integer) where T
+ function pointer(x :: AbstractArray{T}, i :: Integer) where T
- function pointer_eltype(@nospecialize(ptr))
+ function pointer_eltype(ptr)
- function pointer_from_objref(@nospecialize(x))
+ function pointer_from_objref(x)
- function pointer_not_safepoint()
+ function pointer_not_safepoint
- function poison_callstack!(infstate::InferenceState, topmost::InferenceState)
+ function poison_callstack!(infstate :: InferenceState, topmost :: InferenceState)
- function poll_fd(s::Union{RawFD, Sys.iswindows() ? WindowsRawSocket : Union{}}, timeout_s::Real=-1; readable=false, writable=false)
+ function poll_fd(s :: Union{RawFD, Sys.iswindows, (, ), ?, WindowsRawSocket, :, Union}, timeout_s :: Real = -1, readable = false, writable = false)
- function poll_file(s::AbstractString, interval_seconds::Real=5.007, timeout_s::Real=-1)
+ function poll_file(s :: AbstractString, interval_seconds :: Real = 5.007, timeout_s :: Real = -1)
- function pop!(B::BitVector)
+ function pop!(B :: BitVector)
- function pop!(W::IntrusiveLinkedListSynchronized)
+ function pop!(W :: IntrusiveLinkedListSynchronized)
- function pop!(a::Vector)
+ function pop!(a :: Vector)
- function pop!(d::IdDict{K,V}, @nospecialize(key)) where {K, V}
+ function pop!(d :: IdDict{K, V}, key) where K, V
- function pop!(d::IdDict{K,V}, @nospecialize(key), @nospecialize(default)) where {K, V}
+ function pop!(d :: IdDict{K, V}, key, default) where K, V
- function pop!(h::Dict)
+ function pop!(h :: Dict)
- function pop!(h::Dict, key)
+ function pop!(h :: Dict, key)
- function pop!(h::Dict, key, default)
+ function pop!(h :: Dict, key, default)
- function pop!(q::IntrusiveLinkedList{T}) where {T}
+ function pop!(q :: IntrusiveLinkedList{T}) where T
- function pop!(s::Set)
+ function pop!(s :: Set)
- function pop!(s::Set, x)
+ function pop!(s :: Set, x)
- function pop!(wkh::WeakKeyDict{K}, key) where {K}
+ function pop!(wkh :: WeakKeyDict{K}, key) where K
- function pop!(wkh::WeakKeyDict{K}, key, default) where {K}
+ function pop!(wkh :: WeakKeyDict{K}, key, default) where K
- function pop(stack :: Stack)
+ function pop(stack :: Stack)
- function pop_testset()
+ function pop_testset
- function pop_undo(s::PromptState)
+ function pop_undo(s :: PromptState)
- function popat!(a::Vector, i::Integer)
+ function popat!(a :: Vector, i :: Integer)
- function popat!(a::Vector, i::Integer, default)
+ function popat!(a :: Vector, i :: Integer, default)
- function popdisplay(d::AbstractDisplay)
+ function popdisplay(d :: AbstractDisplay)
- function popfirst!(B::BitVector)
+ function popfirst!(B :: BitVector)
- function popfirst!(W::IntrusiveLinkedListSynchronized)
+ function popfirst!(W :: IntrusiveLinkedListSynchronized)
- function popfirst!(a::Vector)
+ function popfirst!(a :: Vector)
- function popfirst!(bsbmp::BitSetBoundedMinPrioritySet)
+ function popfirst!(bsbmp :: BitSetBoundedMinPrioritySet)
- function popfirst!(q::IntrusiveLinkedList{T}) where {T}
+ function popfirst!(q :: IntrusiveLinkedList{T}) where T
- function poplinenum(ex::Expr)
+ function poplinenum(ex :: Expr)
- function poptask(W::StickyWorkqueue)
+ function poptask(W :: StickyWorkqueue)
- function populate_def_use_map!(tpdum::TwoPhaseDefUseMap, scanner::BBScanner)
+ function populate_def_use_map!(tpdum :: TwoPhaseDefUseMap, scanner :: BBScanner)
- function position(f::File)
+ function position(f :: File)
- function position(s::IOStream)
+ function position(s :: IOStream)
- function post_opt_refine_effect_free(y, c=true)
+ function post_opt_refine_effect_free(y, c = true)
- function postprocess!(dict::Dict{Char,Any})
+ function postprocess!(dict :: Dict{Char, Any})
- function pow5invsplit(::Type{T}, i) where {T<:AbstractFloat}
+ function pow5invsplit(??? :: Type{T}, i) where T <: AbstractFloat
- function pow5split(::Type{T}, i) where {T<:AbstractFloat}
+ function pow5split(??? :: Type{T}, i) where T <: AbstractFloat
- function power_by_squaring(x::Bool, p::Integer)
+ function power_by_squaring(x :: Bool, p :: Integer)
- function powermod(x::BigInt, p::BigInt, m::BigInt)
+ function powermod(x :: BigInt, p :: BigInt, m :: BigInt)
- function powermod(x::Integer, p::Integer, m::T) where T<:Integer
+ function powermod(x :: Integer, p :: Integer, m :: T) where T <: Integer
- function powm!(A0::UpperTriangular{<:BlasFloat}, p::Real)
+ function powm!(A0 :: UpperTriangular{??? <: BlasFloat}, p :: Real)
- function powxmod(e::BigInt, m::GF2X)::GF2X
+ function powxmod(e :: BigInt, m :: GF2X)
- function pr9256()
+ function pr9256
- function precompile(@nospecialize(argt::Type))
+ function precompile(argt :: Type)
- function precompile(@nospecialize(argt::Type), m::Method)
+ function precompile(argt :: Type, m :: Method)
- function precompile(@nospecialize(f), @nospecialize(argtypes::Tuple))
+ function precompile(f, argtypes :: Tuple)
- function precompile(@nospecialize(f), @nospecialize(argtypes::Tuple), m::Method)
+ function precompile(f, argtypes :: Tuple, m :: Method)
- function precompile_test_harness(@nospecialize(f), separate::Bool)
+ function precompile_test_harness(f, separate :: Bool)
- function precompile_test_harness(@nospecialize(f), testset::String)
+ function precompile_test_harness(f, testset :: String)
- function preferences_hash(cachefile::String)
+ function preferences_hash(cachefile :: String)
- function prepare_for_deletion(path::AbstractString)
+ function prepare_for_deletion(path :: AbstractString)
- function prepare_next(repl::LineEditREPL)
+ function prepare_next(repl :: LineEditREPL)
- function prepend!(B::BitVector, items::BitVector)
+ function prepend!(B :: BitVector, items :: BitVector)
- function prepend!(a::Vector, items::AbstractVector)
+ function prepend!(a :: Vector, items :: AbstractVector)
- function preprint(io::IO)
+ function preprint(io :: IO)
- function preprint(io::IO, idx::Int)
+ function preprint(io :: IO, idx :: Int)
- function preserve_active(command::Symbol)
+ function preserve_active(command :: Symbol)
- function preserve_handle(x)
+ function preserve_handle(x)
- function prettyprint_getunits(value, numunits, factor)
+ function prettyprint_getunits(value, numunits, factor)
- function prevfloat!(x::BigFloat, n::Integer=1)
+ function prevfloat!(x :: BigFloat, n :: Integer = 1)
- function prevind(s::AbstractString, i::Int, n::Int)
+ function prevind(s :: AbstractString, i :: Int, n :: Int)
- function prevpow(a::T, x::Real) where T <: Real
+ function prevpow(a :: T, x :: Real) where T <: Real
- function print(io::IO, v::VersionNumber)
+ function print(io :: IO, v :: VersionNumber)
- function print(io::IO, x)
+ function print(io :: IO, x)
- function print(io::IO, xs...)
+ function print(io :: IO, xs...)
- function print(io::IO,ip::IPv6)
+ function print(io :: IO, ip :: IPv6)
- function print_bit_chunk(io::IO, c::UInt64, l::Integer = 64)
+ function print_bit_chunk(io :: IO, c :: UInt64, l :: Integer = 64)
- function print_callstack(sv::InferenceState)
+ function print_callstack(sv :: InferenceState)
- function print_correction(io::IO, word::String, mod::Module)
+ function print_correction(io :: IO, word :: String, mod :: Module)
- function print_fullname(io::IO, m::Module)
+ function print_fullname(io :: IO, m :: Module)
- function print_indentation(final::Bool=true)
+ function print_indentation(final :: Bool = true)
- function print_inline_table(f::MbyFunc, io::IO, value::AbstractDict)
+ function print_inline_table(f :: MbyFunc, io :: IO, value :: AbstractDict)
- function print_integer(io::IO, value::Integer)
+ function print_integer(io :: IO, value :: Integer)
- function print_joined_cols(io::IO, ss::Vector{String}, delim = "", last = delim; cols::Int = _displaysize(io)[2])
+ function print_joined_cols(io :: IO, ss :: Vector{String}, delim = "", last = delim, cols :: Int = _displaysize(io)[2])
- function print_llvm(io::IO, code::String)
+ function print_llvm(io :: IO, code :: String)
- function print_llvm_operand(io, tokens)
+ function print_llvm_operand(io, tokens)
- function print_llvm_operands(io, tokens)
+ function print_llvm_operands(io, tokens)
- function print_llvm_tokens(io, tokens)
+ function print_llvm_tokens(io, tokens)
- function print_module_path_file(io, modul, file, line; modulecolor = :light_black, digit_align_width = 0)
+ function print_module_path_file(io, modul, file, line, modulecolor = :light_black, digit_align_width = 0)
- function print_native(io::IO, code::String, arch::Symbol=sys_arch_category())
+ function print_native(io :: IO, code :: String, arch :: Symbol = sys_arch_category())
- function print_native_tokens(io, tokens, arch::Union{Val{:x86}, Val{:arm}})
+ function print_native_tokens(io, tokens, arch :: Union{Val{:, x86}, Val{:, arm}})
- function print_new_node(node; final::Bool=true)
+ function print_new_node(node, final :: Bool = true)
- function print_process_affinity()
+ function print_process_affinity
- function print_quoted(io, s::AbstractString)
+ function print_quoted(io, s :: AbstractString)
- function print_response(errio::IO, response, show_value::Bool, have_color::Bool, specialdisplay::Union{AbstractDisplay,Nothing}=nothing)
+ function print_response(errio :: IO, response, show_value :: Bool, have_color :: Bool, specialdisplay :: Union{AbstractDisplay, Nothing} = nothing)
- function print_response(repl::AbstractREPL, response, show_value::Bool, have_color::Bool)
+ function print_response(repl :: AbstractREPL, response, show_value :: Bool, have_color :: Bool)
- function print_row(row, row_sep, col_sep)
+ function print_row(row, row_sep, col_sep)
- function print_shell_escaped_posixly(io::IO, args::AbstractString...)
+ function print_shell_escaped_posixly(io :: IO, args :: AbstractString...)
- function print_shell_word(io::IO, word::AbstractString, special::AbstractString = "")
+ function print_shell_word(io :: IO, word :: AbstractString, special :: AbstractString = "")
- function print_shmem_limits(slen)
+ function print_shmem_limits(slen)
- function print_stackframe(io, i, frame::StackFrame, n::Int, ndigits_max, modulecolor)
+ function print_stackframe(io, i, frame :: StackFrame, n :: Int, ndigits_max, modulecolor)
- function print_stackframe(io, i, frame::StackFrame, n::Int, ndigits_max, modulecolordict, modulecolorcycler)
+ function print_stackframe(io, i, frame :: StackFrame, n :: Int, ndigits_max, modulecolordict, modulecolorcycler)
- function print_state(args::Pair{String,String}...)
+ function print_state(args :: Pair{String, String}...)
- function print_statement_costs(io::IO, @nospecialize(f), @nospecialize(t); kwargs...)
+ function print_statement_costs(io :: IO, f, t, kwargs...)
- function print_status(key::String)
+ function print_status(key :: String)
- function print_stmt(io::IO, idx::Int, @nospecialize(stmt), used::BitSet, maxlength_idx::Int, color::Bool, show_type::Bool)
+ function print_stmt(io :: IO, idx :: Int, stmt, used :: BitSet, maxlength_idx :: Int, color :: Bool, show_type :: Bool)
- function print_test_errors(ts::DefaultTestSet)
+ function print_test_errors(ts :: DefaultTestSet)
- function print_test_results(ts::DefaultTestSet, depth_pad=0)
+ function print_test_results(ts :: DefaultTestSet, depth_pad = 0)
- function print_testworker_errored(name, wrkr, @nospecialize(e))
+ function print_testworker_errored(name, wrkr, e)
- function print_testworker_stats(test, wrkr, resp)
+ function print_testworker_stats(test, wrkr, resp)
- function print_to_string(xs...)
+ function print_to_string(xs...)
- function print_toml_escaped(io::IO, s::AbstractString)
+ function print_toml_escaped(io :: IO, s :: AbstractString)
- function print_tree(io::IO, alg::Algorithm, cols::Int)
+ function print_tree(io :: IO, alg :: Algorithm, cols :: Int)
- function print_tree(io::IO, bt::StackFrameTree{T}, cols::Int, fmt::ProfileFormat, is_subsection::Bool) where T
+ function print_tree(io :: IO, bt :: StackFrameTree{T}, cols :: Int, fmt :: ProfileFormat, is_subsection :: Bool) where T
- function print_type_bicolor(io, str::String; color=:normal, inner_color=:light_black, use_color::Bool=true)
+ function print_type_bicolor(io, str :: String, color = :normal, inner_color = :light_black, use_color :: Bool = true)
- function print_type_bicolor(io, type; kwargs...)
+ function print_type_bicolor(io, type, kwargs...)
- function print_with_compare(io::IO, @nospecialize(a), @nospecialize(b), color::Symbol)
+ function print_with_compare(io :: IO, a, b, color :: Symbol)
- function print_with_compare(io::IO, @nospecialize(a::DataType), @nospecialize(b::DataType), color::Symbol)
+ function print_with_compare(io :: IO, a :: DataType, b :: DataType, color :: Symbol)
- function print_with_info(io::IO, result::EscapeResult)
+ function print_with_info(io :: IO, result :: EscapeResult)
- function print_with_info(preprint, postprint, io::IO, ir::IRCode, source::Bool)
+ function print_with_info(preprint, postprint, io :: IO, ir :: IRCode, source :: Bool)
- function print_within_stacktrace(io, s...; color=:normal, bold=false)
+ function print_within_stacktrace(io, s..., color = :normal, bold = false)
- function print_without_params(@nospecialize(x))
+ function print_without_params(x)
- function print_wrapped(io::IO, s...; width = 80, pre = "", i = 0)
+ function print_wrapped(io :: IO, s..., width = 80, pre = "", i = 0)
- function printkey(io::IO, keys::Vector{String})
+ function printkey(io :: IO, keys :: Vector{String})
- function printmatch(io::IO, word, match)
+ function printmatch(io :: IO, word, match)
- function printmatches(io::IO, word, matches; cols::Int = _displaysize(io)[2])
+ function printmatches(io :: IO, word, matches, cols :: Int = _displaysize(io)[2])
- function printmenu(out::IO, m::AbstractMenu, cursoridx::Int; oldstate=nothing, init::Bool=false)
+ function printmenu(out :: IO, m :: AbstractMenu, cursoridx :: Int, oldstate = nothing, init :: Bool = false)
- function printstyled_ll(io::IO, x, s::Symbol, trailing_spaces="")
+ function printstyled_ll(io :: IO, x, s :: Symbol, trailing_spaces = "")
- function printvalue(f::MbyFunc, io::IO, value)
+ function printvalue(f :: MbyFunc, io :: IO, value)
- function printvalue(f::MbyFunc, io::IO, value::AbstractVector)
+ function printvalue(f :: MbyFunc, io :: IO, value :: AbstractVector)
- function printvalue(f::MbyFunc, io::IO, value::TOMLValue)
+ function printvalue(f :: MbyFunc, io :: IO, value :: TOMLValue)
- function probe(y)
+ function probe(y)
- function process_backtrace(t::Vector, limit::Int=typemax(Int); skipC = true)
+ function process_backtrace(t :: Vector, limit :: Int = typemax(Int), skipC = true)
- function process_events()
+ function process_events
- function process_logmsg_exs(_orig_module, _file, _line, level, message, exs...)
+ function process_logmsg_exs(_orig_module, _file, _line, level, message, exs...)
- function process_meta!(meta::Vector{Expr}, @nospecialize stmt)
+ function process_meta!(meta :: Vector{Expr}, stmt)
- function process_newnode!(compact::IncrementalCompact, new_idx::Int, new_node_entry::Instruction, new_node_info::NewNodeInfo, idx::Int, active_bb::Int, do_rename_ssa::Bool)
+ function process_newnode!(compact :: IncrementalCompact, new_idx :: Int, new_node_entry :: Instruction, new_node_info :: NewNodeInfo, idx :: Int, active_bb :: Int, do_rename_ssa :: Bool)
- function process_node!(compact::IncrementalCompact, result_idx::Int, inst::Instruction, idx::Int, processed_idx::Int, active_bb::Int, do_rename_ssa::Bool)
+ function process_node!(compact :: IncrementalCompact, result_idx :: Int, inst :: Instruction, idx :: Int, processed_idx :: Int, active_bb :: Int, do_rename_ssa :: Bool)
- function process_overrides(artifact_dict::Dict, pkg_uuid::Base.UUID)
+ function process_overrides(artifact_dict :: Dict, pkg_uuid :: Base.UUID)
- function process_simple!(todo::Vector{Pair{Int,Any}}, ir::IRCode, idx::Int, state::InliningState)
+ function process_simple!(todo :: Vector{Pair{Int, Any}}, ir :: IRCode, idx :: Int, state :: InliningState)
- function process_status(s::Process)
+ function process_status(s :: Process)
- function process_terminator!(@nospecialize(stmt), bb::Int, bb_ip::BitSetBoundedMinPrioritySet)
+ function process_terminator!(stmt, bb :: Int, bb_ip :: BitSetBoundedMinPrioritySet)
- function prod(arr::AbstractArray{BigInt})
+ function prod(arr :: AbstractArray{BigInt})
- function prod_vT_v(R, x, y)
+ function prod_vT_v(R, x, y)
- function prod_v_M_vT(R, x, M, y)
+ function prod_v_M_vT(R, x, M, y)
- function prod_v_vT(R, x, y)
+ function prod_v_vT(R, x, y)
- function profile_printing_listener()
+ function profile_printing_listener
- function project_deps_get(env::String, name::String)::Union{Nothing,PkgId}
+ function project_deps_get(env :: String, name :: String)
- function project_deps_get_completion_candidates(pkgstarts::String, project_file::String)
+ function project_deps_get_completion_candidates(pkgstarts :: String, project_file :: String)
- function project_depth(project)
+ function project_depth(project)
- function project_file_ext_path(project_file::String, name::String)
+ function project_file_ext_path(project_file :: String, name :: String)
- function project_file_manifest_path(project_file::String)::Union{Nothing,String}
+ function project_file_manifest_path(project_file :: String)
- function project_file_name_uuid(project_file::String, name::String)::PkgId
+ function project_file_name_uuid(project_file :: String, name :: String)
- function project_file_path(project_file::String)
+ function project_file_path(project_file :: String)
- function project_isless(p1, p2)
+ function project_isless(p1, p2)
- function promote(x, y)
+ function promote(x, y)
- function promote(x, y, z)
+ function promote(x, y, z)
- function promote(x, y, z, a...)
+ function promote(x, y, z, a...)
- function promote_op(f, S::Type...)
+ function promote_op(f, S :: Type...)
- function promote_rule(::Type{StepRangeLen{T1,R1,S1,L1}},::Type{StepRangeLen{T2,R2,S2,L2}}) where {T1,T2,R1,R2,S1,S2,L1,L2}
+ function promote_rule(??? :: Type{StepRangeLen{T1, R1, S1, L1}}, ??? :: Type{StepRangeLen{T2, R2, S2, L2}}) where T1, T2, R1, R2, S1, S2, L1, L2
- function promote_rule(::Type{StepRange{T1a,T1b}}, ::Type{StepRange{T2a,T2b}}) where {T1a,T1b,T2a,T2b}
+ function promote_rule(??? :: Type{StepRange{T1a, T1b}}, ??? :: Type{StepRange{T2a, T2b}}) where T1a, T1b, T2a, T2b
- function promote_rule(T::Type{>:Missing}, S::Type)
+ function promote_rule(T :: Type{>:, Missing}, S :: Type)
- function promote_rule(T::Type{>:Nothing}, S::Type)
+ function promote_rule(T :: Type{>:, Nothing}, S :: Type)
- function promote_rule(T::Type{>:Union{Nothing, Missing}}, S::Type)
+ function promote_rule(T :: Type{>:, Union{Nothing, Missing}}, S :: Type)
- function promote_rule(a::Type{LinRange{T1,L1}}, b::Type{LinRange{T2,L2}}) where {T1,T2,L1,L2}
+ function promote_rule(a :: Type{LinRange{T1, L1}}, b :: Type{LinRange{T2, L2}}) where T1, T2, L1, L2
- function promote_shape(a::AbstractArray, b::AbstractArray)
+ function promote_shape(a :: AbstractArray, b :: AbstractArray)
- function promote_shape(a::Dims, b::Dims)
+ function promote_shape(a :: Dims, b :: Dims)
- function promote_shape(a::Indices, b::Indices)
+ function promote_shape(a :: Indices, b :: Indices)
- function promote_shape(a::Tuple{Int, Int}, b::Tuple{Int, Int})
+ function promote_shape(a :: Tuple{Int, Int}, b :: Tuple{Int, Int})
- function promote_shape(a::Tuple{Int,Int}, b::Tuple{Int,})
+ function promote_shape(a :: Tuple{Int, Int}, b :: Tuple{Int})
- function promote_shape(a::Tuple{Int,}, b::Tuple{Int,})
+ function promote_shape(a :: Tuple{Int}, b :: Tuple{Int})
- function promote_type(::Type{T}, ::Type{S}) where {T,S}
+ function promote_type(??? :: Type{T}, ??? :: Type{S}) where T, S
- function promote_typejoin(@nospecialize(a), @nospecialize(b))
+ function promote_typejoin(a, b)
- function promote_typejoin_union(::Type{T}) where T
+ function promote_typejoin_union(??? :: Type{T}) where T
- function prompt!(term::TextTerminal, prompt::ModalInterface, s::MIState = init_state(term, prompt))
+ function prompt!(term :: TextTerminal, prompt :: ModalInterface, s :: MIState = init_state(term,prompt))
- function prompt(input::IO, output::IO, message::AbstractString; default::AbstractString="")
+ function prompt(input :: IO, output :: IO, message :: AbstractString, default :: AbstractString = "")
- function prompt_limit()
+ function prompt_limit
- function propagate_changes!(estate::EscapeState, changes::Changes)
+ function propagate_changes!(estate :: EscapeState, changes :: Changes)
- function propagate_to_error_handler!(frame::InferenceState, currpc::Int, W::BitSet, Lᵢ::AbstractLattice, currstate::VarTable)
+ function propagate_to_error_handler!(frame :: InferenceState, currpc :: Int, W :: BitSet, Lᵢ :: AbstractLattice, currstate :: VarTable)
- function push!!(v::Vector, el)
+ function push!!(v :: Vector, el)
- function push!(B::BitVector, item)
+ function push!(B :: BitVector, item)
- function push!(W::IntrusiveLinkedListSynchronized{T}, t::T) where T
+ function push!(W :: IntrusiveLinkedListSynchronized{T}, t :: T) where T
- function push!(a::Vector{Any}, @nospecialize x)
+ function push!(a :: Vector{Any}, x)
- function push!(a::Vector{Any}, @nospecialize x...)
+ function push!(a :: Vector{Any}, x...)
- function push!(a::Vector{T}, item) where T
+ function push!(a :: Vector{T}, item) where T
- function push!(bsbmp::BitSetBoundedMinPrioritySet, idx::Int)
+ function push!(bsbmp :: BitSetBoundedMinPrioritySet, idx :: Int)
- function push!(q::IntrusiveLinkedList{T}, val::T) where T
+ function push!(q :: IntrusiveLinkedList{T}, val :: T) where T
- function push!(s::IntDisjointSet{T}) where {T<:Integer}
+ function push!(s :: IntDisjointSet{T}) where T <: Integer
- function push!(tpvv::TwoPhaseVectorView, v::Int)
+ function push!(tpvv :: TwoPhaseVectorView, v :: Int)
- function push!(w::GitRevWalker, cid::GitHash)
+ function push!(w :: GitRevWalker, cid :: GitHash)
- function push!(w::GitRevWalker, range::AbstractString)
+ function push!(w :: GitRevWalker, range :: AbstractString)
- function push(stack :: Stack, val :: String)
+ function push(stack :: Stack, val :: String)
- function push_head!(w::GitRevWalker)
+ function push_head!(w :: GitRevWalker)
- function push_kill!(s::MIState, killed::String, concat::Bool = s.key_repeats > 0; rev::Bool=false)
+ function push_kill!(s :: MIState, killed :: String, concat :: Bool = s.key_repeats>0, rev :: Bool = false)
- function push_nonempty!(list, x)
+ function push_nonempty!(list, x)
- function push_refspecs(rmt::GitRemote)
+ function push_refspecs(rmt :: GitRemote)
- function push_testset(ts::AbstractTestSet)
+ function push_testset(ts :: AbstractTestSet)
- function push_undo(s::PromptState, advance::Bool=true)
+ function push_undo(s :: PromptState, advance :: Bool = true)
- function push_url(rmt::GitRemote)
+ function push_url(rmt :: GitRemote)
- function push_widen(dest, el)
+ function push_widen(dest, el)
- function pusharg!(arg)
+ function pusharg!(arg)
- function pushdisplay(d::AbstractDisplay)
+ function pushdisplay(d :: AbstractDisplay)
- function pushfirst!(B::BitVector, item)
+ function pushfirst!(B :: BitVector, item)
- function pushfirst!(W::IntrusiveLinkedListSynchronized{T}, t::T) where T
+ function pushfirst!(W :: IntrusiveLinkedListSynchronized{T}, t :: T) where T
- function pushfirst!(a::Vector{Any}, @nospecialize x)
+ function pushfirst!(a :: Vector{Any}, x)
- function pushfirst!(a::Vector{Any}, @nospecialize x...)
+ function pushfirst!(a :: Vector{Any}, x...)
- function pushfirst!(a::Vector{T}, item) where T
+ function pushfirst!(a :: Vector{T}, item) where T
- function pushfirst!(q::IntrusiveLinkedList{T}, val::T) where T
+ function pushfirst!(q :: IntrusiveLinkedList{T}, val :: T) where T
- function pushmeta!(ex::Expr, sym::Symbol, args::Any...)
+ function pushmeta!(ex :: Expr, sym :: Symbol, args :: Any...)
- function put!(c::Channel{T}, v) where T
+ function put!(c :: Channel{T}, v) where T
- function put_8x8_chunk(Bc::Vector{UInt64}, i1::Int, i2::Int, x::UInt64, m::Int, cgap::Int, cinc::Int, nc::Int, msk8::UInt64)
+ function put_8x8_chunk(Bc :: Vector{UInt64}, i1 :: Int, i2 :: Int, x :: UInt64, m :: Int, cgap :: Int, cinc :: Int, nc :: Int, msk8 :: UInt64)
- function put_buffered(c::Channel, v)
+ function put_buffered(c :: Channel, v)
- function put_n_take!(v...)
+ function put_n_take!(v...)
- function put_unbuffered(c::Channel, v)
+ function put_unbuffered(c :: Channel, v)
- function pwd()
+ function pwd
- function qr(A::AbstractMatrix{T}, arg...; kwargs...) where T
+ function qr(A :: AbstractMatrix{T}, arg..., kwargs...) where T
- function qr(v::AbstractVector)
+ function qr(v :: AbstractVector)
- function qrfactPivotedUnblocked!(A::AbstractMatrix)
+ function qrfactPivotedUnblocked!(A :: AbstractMatrix)
- function qrfactUnblocked!(A::AbstractMatrix{T}) where {T}
+ function qrfactUnblocked!(A :: AbstractMatrix{T}) where T
- function quarter(days)
+ function quarter(days)
- function query_override(hash::SHA1; overrides::Dict{Symbol,Any} = load_overrides())
+ function query_override(hash :: SHA1, overrides :: Dict{Symbol, Any} = load_overrides())
- function query_override(pkg::Base.UUID, artifact_name::String; overrides::Dict{Symbol,Any} = load_overrides())
+ function query_override(pkg :: Base.UUID, artifact_name :: String, overrides :: Dict{Symbol, Any} = load_overrides())
- function quickack(sock::Union{TCPServer, TCPSocket}, enable::Bool)
+ function quickack(sock :: Union{TCPServer, TCPSocket}, enable :: Bool)
- function quoted(@nospecialize(x))
+ function quoted(x)
- function radix_chunk_size_heuristic(lo::Integer, hi::Integer, bits::Unsigned)
+ function radix_chunk_size_heuristic(lo :: Integer, hi :: Integer, bits :: Unsigned)
- function radix_sort_pass!(t, lo, hi, offset, counts, v, shift, chunk_size)
+ function radix_sort_pass!(t, lo, hi, offset, counts, v, shift, chunk_size)
- function rand!(r::MersenneTwister, A1::Array{Bool}, sp::SamplerType{Bool})
+ function rand!(r :: MersenneTwister, A1 :: Array{Bool}, sp :: SamplerType{Bool})
- function rand!(r::MersenneTwister, A::UnsafeView{UInt128}, ::SamplerType{UInt128})
+ function rand!(r :: MersenneTwister, A :: UnsafeView{UInt128}, ??? :: SamplerType{UInt128})
- function rand!(rd::RandomDevice, A::Array{Bool}, ::SamplerType{Bool})
+ function rand!(rd :: RandomDevice, A :: Array{Bool}, ??? :: SamplerType{Bool})
- function rand!(rng::AbstractRNG, A::AbstractArray{T}, sp::Sampler) where T
+ function rand!(rng :: AbstractRNG, A :: AbstractArray{T}, sp :: Sampler) where T
- function rand!(rng::AbstractRNG, B::BitArray, ::SamplerType{Bool})
+ function rand!(rng :: AbstractRNG, B :: BitArray, ??? :: SamplerType{Bool})
- function rand!(rng::AbstractRNG, x::BigInt, sp::SamplerBigInt)
+ function rand!(rng :: AbstractRNG, x :: BigInt, sp :: SamplerBigInt)
- function rand!(rng::Union{TaskLocalRNG, Xoshiro}, dst::Array{Bool}, ::SamplerType{Bool})
+ function rand!(rng :: Union{TaskLocalRNG, Xoshiro}, dst :: Array{Bool}, ??? :: SamplerType{Bool})
- function rand!(rng::Union{TaskLocalRNG, Xoshiro}, dst::Array{Float32}, ::SamplerTrivial{CloseOpen01{Float32}})
+ function rand!(rng :: Union{TaskLocalRNG, Xoshiro}, dst :: Array{Float32}, ??? :: SamplerTrivial{CloseOpen01{Float32}})
- function rand!(rng::Union{TaskLocalRNG, Xoshiro}, dst::Array{Float64}, ::SamplerTrivial{CloseOpen01{Float64}})
+ function rand!(rng :: Union{TaskLocalRNG, Xoshiro}, dst :: Array{Float64}, ??? :: SamplerTrivial{CloseOpen01{Float64}})
- function rand(r::AbstractRNG, ::SamplerType{T}) where {T<:AbstractChar}
+ function rand(r :: AbstractRNG, ??? :: SamplerType{T}) where T <: AbstractChar
- function rand(r::MersenneTwister, ::SamplerTrivial{UInt104Raw{UInt128}})
+ function rand(r :: MersenneTwister, ??? :: SamplerTrivial{UInt104Raw{UInt128}})
- function rand(r::MersenneTwister, ::SamplerTrivial{UInt2x52Raw{UInt128}})
+ function rand(r :: MersenneTwister, ??? :: SamplerTrivial{UInt2x52Raw{UInt128}})
- function rand(r::MersenneTwister, x::SamplerTrivial{UInt52Raw{UInt64}})
+ function rand(r :: MersenneTwister, x :: SamplerTrivial{UInt52Raw{UInt64}})
- function rand(rng::AbstractRNG, sp::LessThan)
+ function rand(rng :: AbstractRNG, sp :: LessThan)
- function rand(rng::AbstractRNG, sp::SamplerRangeFast{UInt128,T}) where T
+ function rand(rng :: AbstractRNG, sp :: SamplerRangeFast{UInt128, T}) where T
- function rand(rng::AbstractRNG, sp::SamplerRangeFast{UInt32,T}) where T
+ function rand(rng :: AbstractRNG, sp :: SamplerRangeFast{UInt32, T}) where T
- function rand(rng::AbstractRNG, sp::SamplerRangeFast{UInt64,T}) where T
+ function rand(rng :: AbstractRNG, sp :: SamplerRangeFast{UInt64, T}) where T
- function rand(rng::AbstractRNG, sp::SamplerRangeInt{T,UInt128}) where T<:BitInteger
+ function rand(rng :: AbstractRNG, sp :: SamplerRangeInt{T, UInt128}) where T <: BitInteger
- function rand(rng::AbstractRNG, sp::SamplerRangeInt{T,UInt64}) where T<:BitInteger
+ function rand(rng :: AbstractRNG, sp :: SamplerRangeInt{T, UInt64}) where T <: BitInteger
- function rand(rng::AbstractRNG, sp::SamplerRangeNDL{U,T}) where {U,T}
+ function rand(rng :: AbstractRNG, sp :: SamplerRangeNDL{U, T}) where U, T
- function rand(rng::AbstractRNG, sp::SamplerSimple{<:AbstractString,<:Sampler})::Char
+ function rand(rng :: AbstractRNG, sp :: SamplerSimple{??? <: AbstractString, ??? <: Sampler})
- function rand(rng::AbstractRNG, sp::SamplerSimple{<:Dict,<:Sampler})
+ function rand(rng :: AbstractRNG, sp :: SamplerSimple{??? <: Dict, ??? <: Sampler})
- function rand(rng::AbstractRNG, sp::SamplerSimple{BitSet,<:Sampler})
+ function rand(rng :: AbstractRNG, sp :: SamplerSimple{BitSet, ??? <: Sampler})
- function rand(rng::AbstractRNG, sp::SamplerSimple{Tuple{A,B,C}}) where {A,B,C}
+ function rand(rng :: AbstractRNG, sp :: SamplerSimple{Tuple{A, B, C}}) where A, B, C
- function rand(rng::AbstractRNG, sp::SamplerTag{Ref{T}}) where T<:Tuple
+ function rand(rng :: AbstractRNG, sp :: SamplerTag{Ref{T}}) where T <: Tuple
- function randcycle!(r::AbstractRNG, a::Array{<:Integer})
+ function randcycle!(r :: AbstractRNG, a :: Array{??? <: Integer})
- function randexp_unlikely(rng, idx, x)
+ function randexp_unlikely(rng, idx, x)
- function randjump(r::MersenneTwister, steps::Integer)
+ function randjump(r :: MersenneTwister, steps :: Integer)
- function randjumpvec(m, steps, len) 
+ function randjumpvec(m, steps, len)
- function randmtzig_fill_ziggurat_tables()
+ function randmtzig_fill_ziggurat_tables
- function randn(rng::AbstractRNG, ::Type{T}) where {T<:AbstractFloat}
+ function randn(rng :: AbstractRNG, ??? :: Type{T}) where T <: AbstractFloat
- function randn_unlikely(rng, idx, rabs, x)
+ function randn_unlikely(rng, idx, rabs, x)
- function randn_with_nans(n,p)
+ function randn_with_nans(n, p)
- function random_seed()
+ function random_seed
- function randperm!(r::AbstractRNG, a::Array{<:Integer})
+ function randperm!(r :: AbstractRNG, a :: Array{??? <: Integer})
- function randstring(r::AbstractRNG, chars=b, n::Integer=8)
+ function randstring(r :: AbstractRNG, chars = b, n :: Integer = 8)
- function randsubseq!(r::AbstractRNG, S::AbstractArray, A::AbstractArray, p::Real)
+ function randsubseq!(r :: AbstractRNG, S :: AbstractArray, A :: AbstractArray, p :: Real)
- function range_1dim(S::SharedArray, pidx)
+ function range_1dim(S :: SharedArray, pidx)
- function range_error(start, step, stop, length)
+ function range_error(start, step, stop, length)
- function range_fuzztests(::Type{T}, niter, nrange) where {T}
+ function range_fuzztests(??? :: Type{T}, niter, nrange) where T
- function range_start_length(a, len::Integer)
+ function range_start_length(a, len :: Integer)
- function range_start_step_length(a, step, len::Integer)
+ function range_start_step_length(a, step, len :: Integer)
- function range_start_step_length(a::T, st::T, len::Integer) where T<:IEEEFloat
+ function range_start_step_length(a :: T, st :: T, len :: Integer) where T <: IEEEFloat
- function range_start_stop_length(start::T, stop::T, len::Integer) where {T<:IEEEFloat}
+ function range_start_stop_length(start :: T, stop :: T, len :: Integer) where T <: IEEEFloat
- function range_step_stop_length(step, a, len::Integer)
+ function range_step_stop_length(step, a, len :: Integer)
- function range_step_stop_length(step::IEEEFloat, stop::IEEEFloat, len::Integer)
+ function range_step_stop_length(step :: IEEEFloat, stop :: IEEEFloat, len :: Integer)
- function range_stop_length(a, len::Integer)
+ function range_stop_length(a, len :: Integer)
- function rank(A::AbstractMatrix; atol::Real = 0.0, rtol::Real = (min(size(A)...)*eps(real(float(one(eltype(A))))))*iszero(atol))
+ function rank(A :: AbstractMatrix, atol :: Real = 0.0, rtol :: Real = (min(size(A)...)*eps(real(float(one(eltype(A))))))*iszero(atol))
- function rat(x)
+ function rat(x)
- function rationalize(::Type{T}, x::Integer; kvs...) where {T<:Integer}
+ function rationalize(??? :: Type{T}, x :: Integer, kvs...) where T <: Integer
- function rationalize(::Type{T}, x::Union{AbstractFloat, Rational}, tol::Real) where T<:Integer
+ function rationalize(??? :: Type{T}, x :: Union{AbstractFloat, Rational}, tol :: Real) where T <: Integer
- function raw!(t::TTYTerminal, raw::Bool)
+ function raw!(t :: TTYTerminal, raw :: Bool)
- function raw!(t::TTYTerminal,raw::Bool)
+ function raw!(t :: TTYTerminal, raw :: Bool)
- function rawcontent(blob::GitBlob)
+ function rawcontent(blob :: GitBlob)
- function rcswap!(i::Integer, j::Integer, X::AbstractMatrix{<:Number})
+ function rcswap!(i :: Integer, j :: Integer, X :: AbstractMatrix{??? <: Number})
- function rdiv!(A::AbstractVecOrMat, B::LU)
+ function rdiv!(A :: AbstractVecOrMat, B :: LU)
- function rdiv!(B::AbstractMatrix, C::Cholesky)
+ function rdiv!(B :: AbstractMatrix, C :: Cholesky)
- function rdiv!(B::AbstractMatrix, F::Hessenberg)
+ function rdiv!(B :: AbstractMatrix, F :: Hessenberg)
- function rdiv!(B::AbstractMatrix, F::UpperHessenberg; shift::Number=false)
+ function rdiv!(B :: AbstractMatrix, F :: UpperHessenberg, shift :: Number = false)
- function rdiv!(B::AbstractVecOrMat{<:Complex}, F::Hessenberg{<:Complex,<:Any,<:AbstractMatrix{<:Real}})
+ function rdiv!(B :: AbstractVecOrMat{??? <: Complex}, F :: Hessenberg{??? <: Complex, ??? <: Any, ??? <: AbstractMatrix{??? <: Real}})
- function rdiv!(X::AbstractArray, s::Number)
+ function rdiv!(X :: AbstractArray, s :: Number)
- function rdiv_quasitriu!(A, B)
+ function rdiv_quasitriu!(A, B)
- function reachable_blocks(cfg::CFG, from_bb::Int, to_bb::Union{Nothing,Int} = nothing)
+ function reachable_blocks(cfg :: CFG, from_bb :: Int, to_bb :: Union{Nothing, Int} = nothing)
- function read!(idx::GitIndex, force::Bool = false)
+ function read!(idx :: GitIndex, force :: Bool = false)
- function read!(repo::GitRepo, force::Bool = false)
+ function read!(repo :: GitRepo, force :: Bool = false)
- function read!(s::IO, A::AbstractArray{T}) where {T}
+ function read!(s :: IO, A :: AbstractArray{T}) where T
- function read!(s::IO, A::StridedArray{T}) where {T}
+ function read!(s :: IO, A :: StridedArray{T}) where T
- function read!(s::IO, B::BitArray)
+ function read!(s :: IO, B :: BitArray)
- function read!(s::IO, x::Ref{T}) where {T}
+ function read!(s :: IO, x :: Ref{T}) where T
- function read(cmd::AbstractCmd)
+ function read(cmd :: AbstractCmd)
- function read(data::IO, ::Type{TermInfoRaw})
+ function read(data :: IO, ??? :: Type{TermInfoRaw})
- function read(f::File, ::Type{Char})
+ function read(f :: File, ??? :: Type{Char})
- function read(f::File, ::Type{UInt8})
+ function read(f :: File, ??? :: Type{UInt8})
- function read(from::GenericIOBuffer, T::Union{Type{Int16},Type{UInt16},Type{Int32},Type{UInt32},Type{Int64},Type{UInt64},Type{Int128},Type{UInt128},Type{Float16},Type{Float32},Type{Float64}})
+ function read(from :: GenericIOBuffer, T :: Union{Type{Int16}, Type{UInt16}, Type{Int32}, Type{UInt32}, Type{Int64}, Type{UInt64}, Type{Int128}, Type{UInt128}, Type{Float16}, Type{Float32}, Type{Float64}})
- function read(io::IO, ::Type{Char})
+ function read(io :: IO, ??? :: Type{Char})
- function read(io::SecretBuffer, ::Type{UInt8})
+ function read(io :: SecretBuffer, ??? :: Type{UInt8})
- function read(s::BufferStream, ::Type{UInt8})
+ function read(s :: BufferStream, ??? :: Type{UInt8})
- function read(s::IO, ::Type{Complex{T}}) where T<:Real
+ function read(s :: IO, ??? :: Type{Complex{T}}) where T <: Real
- function read(s::IO, ::Type{Rational{T}}) where T<:Integer
+ function read(s :: IO, ??? :: Type{Rational{T}}) where T <: Integer
- function read(s::IO, T::Union{Type{Int16},Type{UInt16},Type{Int32},Type{UInt32},Type{Int64},Type{UInt64},Type{Int128},Type{UInt128},Type{Float16},Type{Float32},Type{Float64}})
+ function read(s :: IO, T :: Union{Type{Int16}, Type{UInt16}, Type{Int32}, Type{UInt32}, Type{Int64}, Type{UInt64}, Type{Int128}, Type{UInt128}, Type{Float16}, Type{Float32}, Type{Float64}})
- function read(s::IO, nb::Integer = typemax(Int))
+ function read(s :: IO, nb :: Integer = typemax(Int))
- function read(s::IOStream)
+ function read(s :: IOStream)
- function read(s::IOStream, ::Type{UInt8})
+ function read(s :: IOStream, ??? :: Type{UInt8})
- function read(s::IOStream, T::Union{Type{Int16},Type{UInt16},Type{Int32},Type{UInt32},Type{Int64},Type{UInt64}})
+ function read(s :: IOStream, T :: Union{Type{Int16}, Type{UInt16}, Type{Int32}, Type{UInt32}, Type{Int64}, Type{UInt64}})
- function read(s::IOStream, nb::Integer; all::Bool=true)
+ function read(s :: IOStream, nb :: Integer, all :: Bool = true)
- function read(stream::LibuvStream)
+ function read(stream :: LibuvStream)
- function read(this::LibuvStream, ::Type{UInt8})
+ function read(this :: LibuvStream, ??? :: Type{UInt8})
- function read21311()
+ function read21311
- function read_dependency_src(cachefile::String, filename::AbstractString)
+ function read_dependency_src(cachefile :: String, filename :: AbstractString)
- function read_dependency_src(io::IO, cachefile::AbstractString, filename::AbstractString)
+ function read_dependency_src(io :: IO, cachefile :: AbstractString, filename :: AbstractString)
- function read_file5374(fileobj)
+ function read_file5374(fileobj)
- function read_sub(from::GenericIOBuffer, a::AbstractArray{T}, offs, nel) where T
+ function read_sub(from :: GenericIOBuffer, a :: AbstractArray{T}, offs, nel) where T
- function read_to_buffer(io::IO, buffer::Buffer)
+ function read_to_buffer(io :: IO, buffer :: Buffer)
- function read_tree!(idx::GitIndex, tree::GitTree)
+ function read_tree!(idx :: GitIndex, tree :: GitTree)
- function read_until_end(pipe::Base64DecodePipe, ptr::Ptr{UInt8}, n::UInt)
+ function read_until_end(pipe :: Base64DecodePipe, ptr :: Ptr{UInt8}, n :: UInt)
- function readavailable(s::IOStream)
+ function readavailable(s :: IOStream)
- function readavailable(this::LibuvStream)
+ function readavailable(this :: LibuvStream)
- function readbytes!(f::File, b::Array{UInt8}, nb=length(b))
+ function readbytes!(f :: File, b :: Array{UInt8}, nb = length(b))
- function readbytes!(io::GenericIOBuffer, b::Array{UInt8}, nb::Int)
+ function readbytes!(io :: GenericIOBuffer, b :: Array{UInt8}, nb :: Int)
- function readbytes!(s::IO, b::AbstractArray{UInt8}, nb=length(b))
+ function readbytes!(s :: IO, b :: AbstractArray{UInt8}, nb = length(b))
- function readbytes!(s::LibuvStream, a::Vector{UInt8}, nb::Int)
+ function readbytes!(s :: LibuvStream, a :: Vector{UInt8}, nb :: Int)
- function readcb_specialized(stream::LibuvStream, nread::Int, nrequested::UInt)
+ function readcb_specialized(stream :: LibuvStream, nread :: Int, nrequested :: UInt)
- function readchomperrors(exename::Cmd)
+ function readchomperrors(exename :: Cmd)
- function readdir(dir::AbstractString; join::Bool=false, sort::Bool=true)
+ function readdir(dir :: AbstractString, join :: Bool = false, sort :: Bool = true)
- function readheader(s::AbstractSerializer)
+ function readheader(s :: AbstractSerializer)
- function readline(s::IOStream; keep::Bool=false)
+ function readline(s :: IOStream, keep :: Bool = false)
- function readlines(filename::AbstractString; kw...)
+ function readlines(filename :: AbstractString, kw...)
- function readlink(path::AbstractString)
+ function readlink(path :: AbstractString)
- function readuntil(io::IO, target::AbstractVector{T}; keep::Bool=false) where T
+ function readuntil(io :: IO, target :: AbstractVector{T}, keep :: Bool = false) where T
- function readuntil(s::BufferStream, c::UInt8; keep::Bool=false)
+ function readuntil(s :: BufferStream, c :: UInt8, keep :: Bool = false)
- function readuntil(s::IOStream, delim::UInt8; keep::Bool=false)
+ function readuntil(s :: IOStream, delim :: UInt8, keep :: Bool = false)
- function readuntil(stream::IO, delimiter; newlines = false, match = nothing)
+ function readuntil(stream :: IO, delimiter, newlines = false, match = nothing)
- function readuntil(x::LibuvStream, c::UInt8; keep::Bool=false)
+ function readuntil(x :: LibuvStream, c :: UInt8, keep :: Bool = false)
- function readuntil_string(s::IOStream, delim::UInt8, keep::Bool)
+ function readuntil_string(s :: IOStream, delim :: UInt8, keep :: Bool)
- function readuntil_vector!(io::IO, target::AbstractVector{T}, keep::Bool, out) where {T}
+ function readuntil_vector!(io :: IO, target :: AbstractVector{T}, keep :: Bool, out) where T
- function realpath(path::AbstractString)
+ function realpath(path :: AbstractString)
- function reanalyze_fields(ir::IRCode, AliasInfo::IndexableFields, @nospecialize(typ), @nospecialize(fld))
+ function reanalyze_fields(ir :: IRCode, AliasInfo :: IndexableFields, typ, fld)
- function rebase!(repo::GitRepo, upstream::AbstractString="", newbase::AbstractString="")
+ function rebase!(repo :: GitRepo, upstream :: AbstractString = "", newbase :: AbstractString = "")
- function recommend_oneunit(io, ex, arg_types, kwargs)
+ function recommend_oneunit(io, ex, arg_types, kwargs)
- function recompute_inst_flag(newinst::NewInstruction, src::Union{IRCode,IncrementalCompact})
+ function recompute_inst_flag(newinst :: NewInstruction, src :: Union{IRCode, IncrementalCompact})
- function record(::FallbackTestSet, t::LogTestFailure)
+ function record(??? :: FallbackTestSet, t :: LogTestFailure)
- function record(c::ContextTestSet, t::Fail)
+ function record(c :: ContextTestSet, t :: Fail)
- function record(ts::DefaultTestSet, t::LogTestFailure)
+ function record(ts :: DefaultTestSet, t :: LogTestFailure)
- function record(ts::DefaultTestSet, t::Union{Fail, Error}; print_result::Bool=TESTSET_PRINT_ENABLE[])
+ function record(ts :: DefaultTestSet, t :: Union{Fail, Error}, print_result :: Bool = TESTSET_PRINT_ENABLE[])
- function record(ts::FallbackTestSet, t::Union{Fail, Error})
+ function record(ts :: FallbackTestSet, t :: Union{Fail, Error})
- function record_bestguess!(sv::InferenceState)
+ function record_bestguess!(sv :: InferenceState)
- function record_compiletime_preference(uuid::UUID, key::String)
+ function record_compiletime_preference(uuid :: UUID, key :: String)
- function record_immutable_preserve!(new_preserves::Vector{Any}, def::Expr, compact::IncrementalCompact)
+ function record_immutable_preserve!(new_preserves :: Vector{Any}, def :: Expr, compact :: IncrementalCompact)
- function record_slot_assign!(sv::InferenceState)
+ function record_slot_assign!(sv :: InferenceState)
- function record_ssa_assign!(Lᵢ::AbstractLattice, ssa_id::Int, @nospecialize(new), frame::InferenceState)
+ function record_ssa_assign!(Lᵢ :: AbstractLattice, ssa_id :: Int, new, frame :: InferenceState)
- function recur_termination2()
+ function recur_termination2
- function recur_termination2x()
+ function recur_termination2x
- function recurse_dict!(l::Parser, d::Dict, dotted_keys::AbstractVector{String}, check=true)::Err{TOMLDict}
+ function recurse_dict!(l :: Parser, d :: Dict, dotted_keys :: AbstractVector{String}, check = true)
- function recurse_package(name::String, names::String...)
+ function recurse_package(name :: String, names :: String...)
- function recurse_package(where::PkgId, name::String, names::String...)
+ function recurse_package(where :: PkgId, name :: String, names :: String...)
- function recursive_dotcalls!(ex, args, i=1)
+ function recursive_dotcalls!(ex, args, i = 1)
- function recursive_prefs_merge(base::Dict{String, Any}, overrides::Dict{String, Any}...)
+ function recursive_prefs_merge(base :: Dict{String, Any}, overrides :: Dict{String, Any}...)
- function recv(sock::UDPSocket)
+ function recv(sock :: UDPSocket)
- function recvfrom(sock::UDPSocket)
+ function recvfrom(sock :: UDPSocket)
- function redirect_stdio(;stdin=nothing, stderr=nothing, stdout=nothing)
+ function redirect_stdio(stdin = nothing, stderr = nothing, stdout = nothing)
- function redirect_stdio(f; stdin=nothing, stderr=nothing, stdout=nothing)
+ function redirect_stdio(f, stdin = nothing, stderr = nothing, stdout = nothing)
- function redisplay(@nospecialize x)
+ function redisplay(x)
- function redisplay(m::Union{MIME,AbstractString}, @nospecialize x)
+ function redisplay(m :: Union{MIME, AbstractString}, x)
- function reduce(::typeof(merge), items::Vector{<:Dict})
+ function reduce(??? :: typeof(merge), items :: Vector{??? <: Dict})
- function reduced_indices(inds::Indices{N}, d::Int) where N
+ function reduced_indices(inds :: Indices{N}, d :: Int) where N
- function reduced_indices(inds::Indices{N}, region) where N
+ function reduced_indices(inds :: Indices{N}, region) where N
- function reduced_indices0(inds::Indices{N}, d::Int) where N
+ function reduced_indices0(inds :: Indices{N}, d :: Int) where N
- function reduced_indices0(inds::Indices{N}, region) where N
+ function reduced_indices0(inds :: Indices{N}, region) where N
- function reducedim_init(f, op::Union{typeof(*),typeof(mul_prod)}, A::AbstractArray, region)
+ function reducedim_init(f, op :: Union{typeof(*), typeof(mul_prod)}, A :: AbstractArray, region)
- function reducedim_init(f, op::Union{typeof(+),typeof(add_sum)}, A::AbstractArray, region)
+ function reducedim_init(f, op :: Union{typeof(+), typeof(add_sum)}, A :: AbstractArray, region)
- function reducedim_init(f::ExtremaMap, op::typeof(_extrema_rf), A::AbstractArray, region)
+ function reducedim_init(f :: ExtremaMap, op :: typeof(_extrema_rf), A :: AbstractArray, region)
- function reenable_sigint(f::Function)
+ function reenable_sigint(f :: Function)
- function ref_list(repo::GitRepo)
+ function ref_list(repo :: GitRepo)
- function refine_effects!(sv::PostOptAnalysisState)
+ function refine_effects!(sv :: PostOptAnalysisState)
- function refine_new_effects!(Lₒ::AbstractLattice, compact::IncrementalCompact, idx::Int, stmt::Expr)
+ function refine_new_effects!(Lₒ :: AbstractLattice, compact :: IncrementalCompact, idx :: Int, stmt :: Expr)
- function refine_partial_struct2(xs::Union{Int,String,Symbol}...)
+ function refine_partial_struct2(xs :: Union{Int, String, Symbol}...)
- function refine_partial_type(@nospecialize t)
+ function refine_partial_type(t)
- function reflect!(x::AbstractVector, y::AbstractVector, c, s)
+ function reflect!(x :: AbstractVector, y :: AbstractVector, c, s)
- function refresh_multi_line(s::PromptState; kw...)
+ function refresh_multi_line(s :: PromptState, kw...)
- function refresh_multi_line(termbuf::TerminalBuffer, s::SearchState)
+ function refresh_multi_line(termbuf :: TerminalBuffer, s :: SearchState)
- function refresh_multi_line(terminal::UnixTerminal, args...; kwargs...)
+ function refresh_multi_line(terminal :: UnixTerminal, args..., kwargs...)
- function reftype(ref::GitReference)
+ function reftype(ref :: GitReference)
- function register_error_hint(@nospecialize(handler), @nospecialize(exct::Type))
+ function register_error_hint(handler, exct :: Type)
- function register_finalizer!(obj)
+ function register_finalizer!(obj)
- function register_finalizer!(obj::DoAllocWithFieldInter)
+ function register_finalizer!(obj :: DoAllocWithFieldInter)
- function register_restored_modules(sv::SimpleVector, pkg::PkgId, path::String)
+ function register_restored_modules(sv :: SimpleVector, pkg :: PkgId, path :: String)
- function rehash!(d::IdDict, newsz = length(d.ht)%UInt)
+ function rehash!(d :: IdDict, newsz = length(d.ht)%UInt)
- function reinit!(p::Parser, str::String; filepath::Union{Nothing, String}=nothing)
+ function reinit!(p :: Parser, str :: String, filepath :: Union{Nothing, String} = nothing)
- function reinit_displays()
+ function reinit_displays
- function reinit_stdio()
+ function reinit_stdio
- function reinterpret(::Type{Out}, x) where {Out}
+ function reinterpret(??? :: Type{Out}, x) where Out
- function reinterpret(::Type{T}, a::A) where {T,N,S,A<:AbstractArray{S, N}}
+ function reinterpret(??? :: Type{T}, a :: A) where T, N, S, A <: AbstractArray{S, N}
- function reinterpret(::typeof(reshape), ::Type{T}, a::A) where {T,S,A<:AbstractArray{S}}
+ function reinterpret(??? :: typeof(reshape), ??? :: Type{T}, a :: A) where T, S, A <: AbstractArray{S}
- function reject(cache::CachedCredentials, cred::AbstractCredential, url::AbstractString)
+ function reject(cache :: CachedCredentials, cred :: AbstractCredential, url :: AbstractString)
- function reject(cfg::GitConfig, cred::UserPasswordCredential, url::AbstractString)
+ function reject(cfg :: GitConfig, cred :: UserPasswordCredential, url :: AbstractString)
- function reject(p::CredentialPayload; shred::Bool=true)
+ function reject(p :: CredentialPayload, shred :: Bool = true)
- function release(s::Semaphore)
+ function release(s :: Semaphore)
- function relockall(rl::ReentrantLock, n::UInt32)
+ function relockall(rl :: ReentrantLock, n :: UInt32)
- function relpath(path::String, startpath::String = ".")
+ function relpath(path :: String, startpath :: String = ".")
- function rem(x, y, ::typeof(RoundFromZero))
+ function rem(x, y, ??? :: typeof(RoundFromZero))
- function rem(x::BigFloat, y::BigFloat)
+ function rem(x :: BigFloat, y :: BigFloat)
- function rem(x::BigFloat, y::BigFloat, ::RoundingMode{:Nearest})
+ function rem(x :: BigFloat, y :: BigFloat, ??? :: RoundingMode{:, Nearest})
- function rem(x::BigInt, ::Type{T}) where T<:Union{Base.BitUnsigned,Base.BitSigned}
+ function rem(x :: BigInt, ??? :: Type{T}) where T <: Union{Base.BitUnsigned, Base.BitSigned}
- function rem(x::Int128, y::Int128)
+ function rem(x :: Int128, y :: Int128)
- function rem(x::T, p::T, ::RoundingMode{:Nearest}) where T<:IEEEFloat
+ function rem(x :: T, p :: T, ??? :: RoundingMode{:, Nearest}) where T <: IEEEFloat
- function rem(x::T, y::T) where {T<:IEEEFloat}
+ function rem(x :: T, y :: T) where T <: IEEEFloat
- function rem(x::UInt128, y::UInt128)
+ function rem(x :: UInt128, y :: UInt128)
- function rem2pi(x::Float64, ::RoundingMode{:Down})
+ function rem2pi(x :: Float64, ??? :: RoundingMode{:, Down})
- function rem2pi(x::Float64, ::RoundingMode{:Nearest})
+ function rem2pi(x :: Float64, ??? :: RoundingMode{:, Nearest})
- function rem2pi(x::Float64, ::RoundingMode{:ToZero})
+ function rem2pi(x :: Float64, ??? :: RoundingMode{:, ToZero})
- function rem2pi(x::Float64, ::RoundingMode{:Up})
+ function rem2pi(x :: Float64, ??? :: RoundingMode{:, Up})
- function rem2pi(x::Int64, r::RoundingMode)
+ function rem2pi(x :: Int64, r :: RoundingMode)
- function rem_fast(x::T, y::T) where {T<:FloatTypes}
+ function rem_fast(x :: T, y :: T) where T <: FloatTypes
- function remember_object(s::Serializer, @nospecialize(o), n::UInt64)
+ function remember_object(s :: Serializer, o, n :: UInt64)
- function remote_delete(repo::GitRepo, remote_name::AbstractString)
+ function remote_delete(repo :: GitRepo, remote_name :: AbstractString)
- function remotes(repo::GitRepo)
+ function remotes(repo :: GitRepo)
- function removable_if_unused1()
+ function removable_if_unused1
- function removable_if_unused2()
+ function removable_if_unused2
- function removable_if_unused3(v)
+ function removable_if_unused3(v)
- function remove!(idx::GitIndex, files::AbstractString...)
+ function remove!(idx :: GitIndex, files :: AbstractString...)
- function remove!(repo::GitRepo, files::AbstractString...)
+ function remove!(repo :: GitRepo, files :: AbstractString...)
- function remove_frames!(stack::StackTrace, m::Module)
+ function remove_frames!(stack :: StackTrace, m :: Module)
- function remove_frames!(stack::StackTrace, name::Symbol)
+ function remove_frames!(stack :: StackTrace, name :: Symbol)
- function remove_frames!(stack::StackTrace, names::Vector{Symbol})
+ function remove_frames!(stack :: StackTrace, names :: Vector{Symbol})
- function remove_linenums!(ex::Expr)
+ function remove_linenums!(ex :: Expr)
- function remove_linenums!(src::CodeInfo)
+ function remove_linenums!(src :: CodeInfo)
- function rename(src::AbstractString, dst::AbstractString; force::Bool=false)
+ function rename(src :: AbstractString, dst :: AbstractString, force :: Bool = false)
- function rename_incoming_edge(old_edge::Int, old_to::Int, result_order::Vector{Int}, bb_rename::Vector{Int})
+ function rename_incoming_edge(old_edge :: Int, old_to :: Int, result_order :: Vector{Int}, bb_rename :: Vector{Int})
- function rename_nodes!(D::DFSTree, rename_bb::Vector{BBNumber})
+ function rename_nodes!(D :: DFSTree, rename_bb :: Vector{BBNumber})
- function rename_nodes!(domtree::DomTree, rename_bb::Vector{BBNumber})
+ function rename_nodes!(domtree :: DomTree, rename_bb :: Vector{BBNumber})
- function rename_outgoing_edge(old_to::Int, old_from::Int, result_order::Vector{Int}, bb_rename::Vector{Int})
+ function rename_outgoing_edge(old_to :: Int, old_from :: Int, result_order :: Vector{Int}, bb_rename :: Vector{Int})
- function rename_phinode_edges(node::PhiNode, bb::Int, result_order::Vector{Int}, bb_rename::Vector{Int})
+ function rename_phinode_edges(node :: PhiNode, bb :: Int, result_order :: Vector{Int}, bb_rename :: Vector{Int})
- function rename_unionall(@nospecialize(u))
+ function rename_unionall(u)
- function rename_uses!(ir::IRCode, ci::CodeInfo, idx::Int, @nospecialize(stmt), renames::Vector{Pair{Any, Any}})
+ function rename_uses!(ir :: IRCode, ci :: CodeInfo, idx :: Int, stmt, renames :: Vector{Pair{Any, Any}})
- function renumber_cfg_stmts!(cfg::CFG, blockchangemap::Vector{Int})
+ function renumber_cfg_stmts!(cfg :: CFG, blockchangemap :: Vector{Int})
- function renumber_ir_elements!(body::Vector{Any}, cfg::Union{CFG,Nothing}, ssachangemap::Vector{Int})
+ function renumber_ir_elements!(body :: Vector{Any}, cfg :: Union{CFG, Nothing}, ssachangemap :: Vector{Int})
- function renumber_ir_elements!(body::Vector{Any}, ssachangemap::Vector{Int}, labelchangemap::Vector{Int})
+ function renumber_ir_elements!(body :: Vector{Any}, ssachangemap :: Vector{Int}, labelchangemap :: Vector{Int})
- function renumber_ssa!(@nospecialize(stmt), ssanums::Vector{SSAValue}, new_ssa::Bool=false)
+ function renumber_ssa!(stmt, ssanums :: Vector{SSAValue}, new_ssa :: Bool = false)
- function renumber_ssa(stmt::SSAValue, ssanums::Vector{SSAValue}, new_ssa::Bool=false)
+ function renumber_ssa(stmt :: SSAValue, ssanums :: Vector{SSAValue}, new_ssa :: Bool = false)
- function renumber_ssa2!(@nospecialize(stmt), ssanums::Vector{Any}, used_ssas::Vector{Int}, new_new_used_ssas::Vector{Int}, late_fixup::Vector{Int}, result_idx::Int, do_rename_ssa::Bool, mark_refined!::Union{Refiner, Nothing})
+ function renumber_ssa2!(stmt, ssanums :: Vector{Any}, used_ssas :: Vector{Int}, new_new_used_ssas :: Vector{Int}, late_fixup :: Vector{Int}, result_idx :: Int, do_rename_ssa :: Bool, mark_refined! :: Union{Refiner, Nothing})
- function repackage28445()
+ function repackage28445
- function repeat(A::AbstractArray, counts...)
+ function repeat(A :: AbstractArray, counts...)
- function repeat(A::AbstractArray; inner = nothing, outer = nothing)
+ function repeat(A :: AbstractArray, inner = nothing, outer = nothing)
- function repeat(arr; inner=nothing, outer=nothing)
+ function repeat(arr, inner = nothing, outer = nothing)
- function repeat(c::AbstractChar, r::Integer)
+ function repeat(c :: AbstractChar, r :: Integer)
- function repeat(c::AnnotatedChar, r::Integer)
+ function repeat(c :: AnnotatedChar, r :: Integer)
- function repeat(s::Union{String, SubString{String}}, r::Integer)
+ function repeat(s :: Union{String, SubString{String}}, r :: Integer)
- function repeat(str::AnnotatedString, r::Integer)
+ function repeat(str :: AnnotatedString, r :: Integer)
- function repeat_inner(arr, inner)
+ function repeat_inner(arr, inner)
- function repeat_outer(a::AbstractMatrix, (m,n)::NTuple{2, Any})
+ function repeat_outer(a :: AbstractMatrix, (m,n) :: NTuple{DependentType@3b07d329, Any})
- function repeat_outer(a::AbstractVector, (m,)::Tuple{Any})
+ function repeat_outer(a :: AbstractVector, (m,) :: Tuple{Any})
- function repeat_outer(arr::AbstractArray{<:Any,N}, dims::NTuple{N,Any}) where {N}
+ function repeat_outer(arr :: AbstractArray{??? <: Any, N}, dims :: NTuple{N, Any}) where N
- function repl(io::IO, s::Symbol; brief::Bool=true, mod::Module=Main, internal_accesses::Union{Nothing, Set{Pair{Module,Symbol}}}=nothing)
+ function repl(io :: IO, s :: Symbol, brief :: Bool = true, mod :: Module = Main, internal_accesses :: Union{Nothing, Set{Pair{Module, Symbol}}} = nothing)
- function repl_backend_loop(backend::REPLBackend, get_module::Function)
+ function repl_backend_loop(backend :: REPLBackend, get_module :: Function)
- function repl_cmd(cmd, out)
+ function repl_cmd(cmd, out)
- function repl_color(key, default)
+ function repl_color(key, default)
- function repl_corrections(io::IO, s, mod::Module)
+ function repl_corrections(io :: IO, s, mod :: Module)
- function repl_display_error(errio::IO, @nospecialize errval)
+ function repl_display_error(errio :: IO, errval)
- function repl_eval_counter(hp)
+ function repl_eval_counter(hp)
- function repl_eval_ex(@nospecialize(ex), context_module::Module; limit_aggressive_inference::Bool=false)
+ function repl_eval_ex(ex, context_module :: Module, limit_aggressive_inference :: Bool = false)
- function repl_latex(io::IO, s0::String)
+ function repl_latex(io :: IO, s0 :: String)
- function repl_main(_)
+ function repl_main(_)
- function repl_search(io::IO, s::Union{Symbol,String}, mod::Module)
+ function repl_search(io :: IO, s :: Union{Symbol, String}, mod :: Module)
- function replace(A, old_new::Pair...; count::Union{Integer,Nothing}=nothing)
+ function replace(A, old_new :: Pair..., count :: Union{Integer, Nothing} = nothing)
- function replace_code_newstyle!(ci::CodeInfo, ir::IRCode)
+ function replace_code_newstyle!(ci :: CodeInfo, ir :: IRCode)
- function replace_colon(A::AbstractArray, I)
+ function replace_colon(A :: AbstractArray, I)
- function replace_depot_path(path::AbstractString)
+ function replace_depot_path(path :: AbstractString)
- function replace_in_print_matrix(S::SubArray{<:Any,1,<:AbstractVector}, i::Integer, j::Integer, s::AbstractString)
+ function replace_in_print_matrix(S :: SubArray{??? <: Any, DependentType@41629346, ??? <: AbstractVector}, i :: Integer, j :: Integer, s :: AbstractString)
- function replace_in_print_matrix(S::SubArray{<:Any,2,<:AbstractMatrix}, i::Integer, j::Integer, s::AbstractString)
+ function replace_in_print_matrix(S :: SubArray{??? <: Any, DependentType@404b9385, ??? <: AbstractMatrix}, i :: Integer, j :: Integer, s :: AbstractString)
- function replace_line(s::PrefixSearchState, l::Union{String,SubString{String}})
+ function replace_line(s :: PrefixSearchState, l :: Union{String, SubString{String}})
- function replace_line(s::PromptState, l::IOBuffer)
+ function replace_line(s :: PromptState, l :: IOBuffer)
- function replace_line(s::PromptState, l::Union{String,SubString{String}}, keep_undo::Bool=false)
+ function replace_line(s :: PromptState, l :: Union{String, SubString{String}}, keep_undo :: Bool = false)
- function replace_linenums!(ex::Expr, ln::LineNumberNode)
+ function replace_linenums!(ex :: Expr, ln :: LineNumberNode)
- function replace_pairs!(res, A, count::Int, old_new::Tuple{Vararg{Pair}})
+ function replace_pairs!(res, A, count :: Int, old_new :: Tuple{Vararg{Pair}})
- function replace_ref_begin_end_!(ex, withex)
+ function replace_ref_begin_end_!(ex, withex)
- function replace_sourceloc!(sourceloc, @nospecialize(ex))
+ function replace_sourceloc!(sourceloc, ex)
- function replace_with_centered_mark(s::AbstractString;c::AbstractChar = '⋅')
+ function replace_with_centered_mark(s :: AbstractString, c :: AbstractChar = '⋅')
- function replaceproperty!(x, f::Symbol, expected, desired, success_order::Symbol=:not_atomic, fail_order::Symbol=success_order)
+ function replaceproperty!(x, f :: Symbol, expected, desired, success_order :: Symbol = :not_atomic, fail_order :: Symbol = success_order)
- function report_bug(kind)
+ function report_bug(kind)
- function repository(idx::GitIndex)
+ function repository(idx :: GitIndex)
- function reproducible_rand(r, i)
+ function reproducible_rand(r, i)
- function request(term::REPL.Terminals.TTYTerminal, m::AbstractMenu; cursor::Union{Int, Base.RefValue{Int}}=1, suppress_output=false)
+ function request(term :: REPL.Terminals.TTYTerminal, m :: AbstractMenu, cursor :: Union{Int, Base.RefValue{Int}} = 1, suppress_output = false)
- function request(term::REPL.Terminals.TTYTerminal, msg::AbstractString, m::AbstractMenu; kwargs...)
+ function request(term :: REPL.Terminals.TTYTerminal, msg :: AbstractString, m :: AbstractMenu, kwargs...)
- function require(into::Module, mod::Symbol)
+ function require(into :: Module, mod :: Symbol)
- function reserve1(r::MersenneTwister, ::Type{T}) where T<:BitInteger
+ function reserve1(r :: MersenneTwister, ??? :: Type{T}) where T <: BitInteger
- function reset!(p::CredentialPayload, config::GitConfig=p.config)
+ function reset!(p :: CredentialPayload, config :: GitConfig = p.config)
- function reset!(repo::GitRepo, committish::AbstractString, pathspecs::AbstractString...)
+ function reset!(repo :: GitRepo, committish :: AbstractString, pathspecs :: AbstractString...)
- function reset!(repo::GitRepo, obj::Union{GitObject, Nothing}, pathspecs::AbstractString...)
+ function reset!(repo :: GitRepo, obj :: Union{GitObject, Nothing}, pathspecs :: AbstractString...)
- function reset!(s::Stateful{T,VS}, itr::T=s.itr) where {T,VS}
+ function reset!(s :: Stateful{T, VS}, itr :: T = s.itr) where T, VS
- function reset(e::Event)
+ function reset(e :: Event)
- function reset(io::T) where T<:IO
+ function reset(io :: T) where T <: IO
- function reset(repl::LineEditREPL)
+ function reset(repl :: LineEditREPL)
- function reset_caches!(r::MersenneTwister)
+ function reset_caches!(r :: MersenneTwister)
- function reset_key_repeats(f::Function, s::MIState)
+ function reset_key_repeats(f :: Function, s :: MIState)
- function reset_state(s::AbstractSerializer)
+ function reset_state(s :: AbstractSerializer)
- function reset_state(s::MIState)
+ function reset_state(s :: MIState)
- function reset_state(s::PrefixSearchState)
+ function reset_state(s :: PrefixSearchState)
- function reset_state(s::PromptState)
+ function reset_state(s :: PromptState)
- function reset_state(s::SearchState)
+ function reset_state(s :: SearchState)
- function reset_timings()
+ function reset_timings
- function reseteof(x::TTY)
+ function reseteof(x :: TTY)
- function reshape(B::BitArray{N}, dims::NTuple{N,Int}) where N
+ function reshape(B :: BitArray{N}, dims :: NTuple{N, Int}) where N
- function reshape(a::SharedArray{T}, dims::NTuple{N,Int}) where {T,N}
+ function reshape(a :: SharedArray{T}, dims :: NTuple{N, Int}) where T, N
- function reshape(parent::AbstractArray, ndims::Val{N}) where N
+ function reshape(parent :: AbstractArray, ndims :: Val{N}) where N
- function resize!(a::Vector, nl::Integer)
+ function resize!(a :: Vector, nl :: Integer)
- function resize!(compact::IncrementalCompact, nnewnodes::Int)
+ function resize!(compact :: IncrementalCompact, nnewnodes :: Int)
- function resize!(stmts::InstructionStream, len)
+ function resize!(stmts :: InstructionStream, len)
- function resize_nthreads!(A::AbstractVector, copyvalue=A[1])
+ function resize_nthreads!(A :: AbstractVector, copyvalue = A[1])
- function resolve(arr, inner, outer)
+ function resolve(arr, inner, outer)
- function resolve(arr, inner, outer::Nothing)
+ function resolve(arr, inner, outer :: Nothing)
- function resolve(arr, inner::Nothing, outer)
+ function resolve(arr, inner :: Nothing, outer)
- function resolve(arr, inner::Nothing, outer::Nothing)
+ function resolve(arr, inner :: Nothing, outer :: Nothing)
- function resolve(arr::AbstractArray{<:Any, N}, inner::NTuple{N, Any}, outer::NTuple{N,Any}) where {N}
+ function resolve(arr :: AbstractArray{??? <: Any, N}, inner :: NTuple{N, Any}, outer :: NTuple{N, Any}) where N
- function resolve(new, oldstream, mode)
+ function resolve(new, oldstream, mode)
- function resolve(new::Nothing, oldstream, mode)
+ function resolve(new :: Nothing, oldstream, mode)
- function resolve(path::AbstractString, oldstream,mode)
+ function resolve(path :: AbstractString, oldstream, mode)
- function resolve_call_cycle!(interp::AbstractInterpreter, mi::MethodInstance, parent::AbsIntState)
+ function resolve_call_cycle!(interp :: AbstractInterpreter, mi :: MethodInstance, parent :: AbsIntState)
- function resolve_depot(includes::Union{AbstractVector,AbstractSet})
+ function resolve_depot(includes :: Union{AbstractVector, AbstractSet})
- function resolve_ref_immediately(s::AbstractSerializer, @nospecialize(x))
+ function resolve_ref_immediately(s :: AbstractSerializer, x)
- function resolve_toplevel_symbols!(src::Core.CodeInfo, mod::Module)
+ function resolve_toplevel_symbols!(src :: Core.CodeInfo, mod :: Module)
- function resolvebinding(ex::Expr)
+ function resolvebinding(ex :: Expr)
- function resolvebinding(ex::GlobalRef)
+ function resolvebinding(ex :: GlobalRef)
- function respond(f, repl, main; pass_empty::Bool = false, suppress_on_semicolon::Bool = true)
+ function respond(f, repl, main, pass_empty :: Bool = false, suppress_on_semicolon :: Bool = true)
- function rest(a::AbstractArray{T}, state...) where {T}
+ function rest(a :: AbstractArray{T}, state...) where T
- function restart_copyto_nonleaf!(newdest, dest, bc, val, I, iter, state, count)
+ function restart_copyto_nonleaf!(newdest, dest, bc, val, I, iter, state, count)
- function restore(s::State, repo::GitRepo)
+ function restore(s :: State, repo :: GitRepo)
- function restore_depot_path(path::AbstractString, depot::AbstractString)
+ function restore_depot_path(path :: AbstractString, depot :: AbstractString)
- function result_join(::S, ::T, ::U, ::V) where {S,T,U,V}
+ function result_join(??? :: S, ??? :: T, ??? :: U, ??? :: V) where S, T, U, V
- function result_style(s1::S, s2::S) where S<:BroadcastStyle
+ function result_style(s1 :: S, s2 :: S) where S <: BroadcastStyle
- function retfinally()
+ function retfinally
- function rethrow_escape!()
+ function rethrow_escape!
- function retrieve(; kwargs...)
+ function retrieve(kwargs...)
- function retrieve_code_info(linfo::MethodInstance, world::UInt)
+ function retrieve_code_info(linfo :: MethodInstance, world :: UInt)
- function retrieve_ir_for_inlining(::MethodInstance, ir::IRCode, preserve_local_sources::Bool=true)
+ function retrieve_ir_for_inlining(??? :: MethodInstance, ir :: IRCode, preserve_local_sources :: Bool = true)
- function retrieve_ir_for_inlining(mi::MethodInstance, src::CodeInfo, preserve_local_sources::Bool=true)
+ function retrieve_ir_for_inlining(mi :: MethodInstance, src :: CodeInfo, preserve_local_sources :: Bool = true)
- function retrieve_ir_for_inlining(mi::MethodInstance, src::String, ::Bool=true)
+ function retrieve_ir_for_inlining(mi :: MethodInstance, src :: String, ??? :: Bool = true)
- function retry(f;  delays=ExponentialBackOff(), check=nothing)
+ function retry(f, delays = ExponentialBackOff(), check = nothing)
- function retry_load_extensions()
+ function retry_load_extensions
- function return_callback(s)
+ function return_callback(s)
- function return_the_big_tuple(err::Bool)
+ function return_the_big_tuple(err :: Bool)
- function return_type(@nospecialize(f), t::DataType)
+ function return_type(f, t :: DataType)
- function return_type(@nospecialize(f), t::DataType, world::UInt)
+ function return_type(f, t :: DataType, world :: UInt)
- function return_type(t::DataType)
+ function return_type(t :: DataType)
- function return_type(t::DataType, world::UInt)
+ function return_type(t :: DataType, world :: UInt)
- function return_type_tfunc(interp::AbstractInterpreter, argtypes::Vector{Any}, si::StmtInfo, sv::AbsIntState)
+ function return_type_tfunc(interp :: AbstractInterpreter, argtypes :: Vector{Any}, si :: StmtInfo, sv :: AbsIntState)
- function return_type_unused(x)
+ function return_type_unused(x)
- function returntype(x::Int)::Int
+ function returntype(x :: Int)
- function revcount(repo::GitRepo, commit1::AbstractString, commit2::AbstractString)
+ function revcount(repo :: GitRepo, commit1 :: AbstractString, commit2 :: AbstractString)
- function reverse!(v::AbstractVector, start::Integer, stop::Integer=lastindex(v))
+ function reverse!(v :: AbstractVector, start :: Integer, stop :: Integer = lastindex(v))
- function reverse(A::AbstractVector, start::Integer, stop::Integer=lastindex(A))
+ function reverse(A :: AbstractVector, start :: Integer, stop :: Integer = lastindex(A))
- function reverse(s::AnnotatedString)
+ function reverse(s :: AnnotatedString)
- function reverse(s::Union{String,SubString{String}})::String
+ function reverse(s :: Union{String, SubString{String}})
- function reverse(z::Zip)
+ function reverse(z :: Zip)
- function reverseind(a::AbstractVector, i::Integer)
+ function reverseind(a :: AbstractVector, i :: Integer)
- function revise_trackall()
+ function revise_trackall
- function rewrap_unionall(@nospecialize(t), @nospecialize(u))
+ function rewrap_unionall(t, u)
- function rewrap_unionall(t::Core.TypeofVararg, @nospecialize(u))
+ function rewrap_unionall(t :: Core.TypeofVararg, u)
- function rm(path::AbstractString; force::Bool=false, recursive::Bool=false)
+ function rm(path :: AbstractString, force :: Bool = false, recursive :: Bool = false)
- function rmul!(A::AbstractMatrix, R::Rotation)
+ function rmul!(A :: AbstractMatrix, R :: Rotation)
- function rmul!(A::AbstractMatrix, adjR::AdjointRotation{<:Any,<:Rotation})
+ function rmul!(A :: AbstractMatrix, adjR :: AdjointRotation{??? <: Any, ??? <: Rotation})
- function rmul!(A::AbstractVecOrMat, Q::QRPackedQ)
+ function rmul!(A :: AbstractVecOrMat, Q :: QRPackedQ)
- function rmul!(A::AbstractVecOrMat, adjQ::AdjointQ{<:Any,<:QRPackedQ})
+ function rmul!(A :: AbstractVecOrMat, adjQ :: AdjointQ{??? <: Any, ??? <: QRPackedQ})
- function rmul!(R::Rotation, G::Givens)
+ function rmul!(R :: Rotation, G :: Givens)
- function rmul!(X::AbstractArray, s::Number)
+ function rmul!(X :: AbstractArray, s :: Number)
- function rmul_triu!(M::AbstractMatrix, x, k::Integer=0)
+ function rmul_triu!(M :: AbstractMatrix, x, k :: Integer = 0)
- function robust_cdiv2(a::Float64, b::Float64, c::Float64, d::Float64, r::Float64, t::Float64)
+ function robust_cdiv2(a :: Float64, b :: Float64, c :: Float64, d :: Float64, r :: Float64, t :: Float64)
- function robust_cinv(c::Float64, d::Float64)
+ function robust_cinv(c :: Float64, d :: Float64)
- function root_module(where::Module, name::Symbol)
+ function root_module(where :: Module, name :: Symbol)
- function root_provenance(m::Method, i::Int)
+ function root_provenance(m :: Method, i :: Int)
- function root_union!(s::IntDisjointSet{T}, x::T, y::T) where {T<:Integer}
+ function root_union!(s :: IntDisjointSet{T}, x :: T, y :: T) where T <: Integer
- function rot180(A::AbstractMatrix)
+ function rot180(A :: AbstractMatrix)
- function rotate!(x::AbstractVector, y::AbstractVector, c, s)
+ function rotate!(x :: AbstractVector, y :: AbstractVector, c, s)
- function rotl90(A::AbstractMatrix)
+ function rotl90(A :: AbstractMatrix)
- function rotl90(A::AbstractMatrix, k::Integer)
+ function rotl90(A :: AbstractMatrix, k :: Integer)
- function rotr90(A::AbstractMatrix)
+ function rotr90(A :: AbstractMatrix)
- function round(::Type{BigInt}, x::BigFloat, r::Union{RoundingMode, MPFRRoundingMode})
+ function round(??? :: Type{BigInt}, x :: BigFloat, r :: Union{RoundingMode, MPFRRoundingMode})
- function round(::Type{BigInt}, x::Union{Float16,Float32,Float64}, r::RoundingMode{:ToZero})
+ function round(??? :: Type{BigInt}, x :: Union{Float16, Float32, Float64}, r :: RoundingMode{:, ToZero})
- function round(::Type{T}, x::BigFloat, r::Union{RoundingMode, MPFRRoundingMode}) where T<:Union{Signed, Unsigned}
+ function round(??? :: Type{T}, x :: BigFloat, r :: Union{RoundingMode, MPFRRoundingMode}) where T <: Union{Signed, Unsigned}
- function round(::Type{T}, x::Rational{Bool}, ::RoundingMode=RoundNearest) where T
+ function round(??? :: Type{T}, x :: Rational{Bool}, ??? :: RoundingMode = RoundNearest) where T
- function round(::Type{T}, x::Rational{Tr}, r::RoundingMode=RoundNearest) where {T,Tr}
+ function round(??? :: Type{T}, x :: Rational{Tr}, r :: RoundingMode = RoundNearest) where T, Tr
- function round(x::AbstractFloat, ::RoundingMode{:NearestTiesAway})
+ function round(x :: AbstractFloat, ??? :: RoundingMode{:, NearestTiesAway})
- function round(x::T, ::RoundingMode{:NearestTiesUp}) where {T <: AbstractFloat}
+ function round(x :: T, ??? :: RoundingMode{:, NearestTiesUp}) where T <: AbstractFloat
- function round(z::Complex, rr::RoundingMode=RoundNearest, ri::RoundingMode=rr; kwargs...)
+ function round(z :: Complex, rr :: RoundingMode = RoundNearest, ri :: RoundingMode = rr, kwargs...)
- function rounds_away_from_zero(m::MPFRRoundingMode, sign_bit::Bool)
+ function rounds_away_from_zero(m :: MPFRRoundingMode, sign_bit :: Bool)
- function roundshift(x, n)
+ function roundshift(x, n)
- function roundtrip(data)
+ function roundtrip(data)
- function rowlength!(row, len)
+ function rowlength!(row, len)
- function rpm_provides(r::T) where T
+ function rpm_provides(r :: T) where T
- function rst(io::IO, code::Code)
+ function rst(io :: IO, code :: Code)
- function rst(io::IO, content::Vector)
+ function rst(io :: IO, content :: Vector)
- function rst(io::IO, f::Footnote)
+ function rst(io :: IO, f :: Footnote)
- function rst(io::IO, header::Header{l}) where l
+ function rst(io :: IO, header :: Header{l}) where l
- function rst(io::IO, l::LaTeX)
+ function rst(io :: IO, l :: LaTeX)
- function rst(io::IO, list::List)
+ function rst(io :: IO, list :: List)
- function rst(io::IO, md::Admonition)
+ function rst(io :: IO, md :: Admonition)
- function rst(io::IO, md::HorizontalRule)
+ function rst(io :: IO, md :: HorizontalRule)
- function rst(io::IO, md::Table)
+ function rst(io :: IO, md :: Table)
- function rst(io::IO, p::Paragraph)
+ function rst(io :: IO, p :: Paragraph)
- function rst(io::IO, q::BlockQuote)
+ function rst(io :: IO, q :: BlockQuote)
- function rstinline(io::IO, md...)
+ function rstinline(io :: IO, md...)
- function rstinline(io::IO, md::Link)
+ function rstinline(io :: IO, md :: Link)
- function rstrip(f, s::AbstractString)
+ function rstrip(f, s :: AbstractString)
- function rstrip_shell(s::AbstractString)
+ function rstrip_shell(s :: AbstractString)
- function rtoldefault(x::Union{T,Type{T}}, y::Union{S,Type{S}}, atol::Real) where {T<:Number,S<:Number}
+ function rtoldefault(x :: Union{T, Type{T}}, y :: Union{S, Type{S}}, atol :: Real) where T <: Number, S <: Number
- function rtruncto(str::String, w::Int)
+ function rtruncto(str :: String, w :: Int)
- function run!(helper::GitCredentialHelper, operation::AbstractString, cred::GitCredential)
+ function run!(helper :: GitCredentialHelper, operation :: AbstractString, cred :: GitCredential)
- function run(cmds::AbstractCmd, args...; wait::Bool = true)
+ function run(cmds :: AbstractCmd, args..., wait :: Bool = true)
- function run(helper::GitCredentialHelper, operation::AbstractString, cred::GitCredential)
+ function run(helper :: GitCredentialHelper, operation :: AbstractString, cred :: GitCredential)
- function run(maxsize)
+ function run(maxsize)
- function run_extension_callbacks(extid::ExtensionId)
+ function run_extension_callbacks(extid :: ExtensionId)
- function run_extension_callbacks(pkgid::PkgId)
+ function run_extension_callbacks(pkgid :: PkgId)
- function run_finalizer_escape_test1(b1, b2)
+ function run_finalizer_escape_test1(b1, b2)
- function run_finalizer_escape_test2(b1, b2)
+ function run_finalizer_escape_test2(b1, b2)
- function run_frontend(repl::BasicREPL, backend::REPLBackendRef)
+ function run_frontend(repl :: BasicREPL, backend :: REPLBackendRef)
- function run_frontend(repl::LineEditREPL, backend::REPLBackendRef)
+ function run_frontend(repl :: LineEditREPL, backend :: REPLBackendRef)
- function run_frontend(repl::StreamREPL, backend::REPLBackendRef)
+ function run_frontend(repl :: StreamREPL, backend :: REPLBackendRef)
- function run_gctest(file)
+ function run_gctest(file)
- function run_interface(terminal::TextTerminal, m::ModalInterface, s::MIState=init_state(terminal, m))
+ function run_interface(terminal :: TextTerminal, m :: ModalInterface, s :: MIState = init_state(terminal,m))
- function run_main_repl(interactive::Bool, quiet::Bool, banner::Symbol, history_file::Bool, color_set::Bool)
+ function run_main_repl(interactive :: Bool, quiet :: Bool, banner :: Symbol, history_file :: Bool, color_set :: Bool)
- function run_map_equivalence_tests(mapf)
+ function run_map_equivalence_tests(mapf)
- function run_module_init(mod::Module, i::Int=1)
+ function run_module_init(mod :: Module, i :: Int = 1)
- function run_mtest(name, testf)
+ function run_mtest(name, testf)
- function run_package_callbacks(modkey::PkgId)
+ function run_package_callbacks(modkey :: PkgId)
- function run_repl(repl::AbstractREPL, @nospecialize(consumer = x -> nothing); backend_on_current_task::Bool = true, backend = REPLBackend())
+ function run_repl(repl :: AbstractREPL, consumer = x->nothing, backend_on_current_task :: Bool = true, backend = REPLBackend())
- function run_test(d,buf)
+ function run_test(d, buf)
- function run_test_server(srv, text)
+ function run_test_server(srv, text)
- function run_with_affinity(cpus)
+ function run_with_affinity(cpus)
- function runsubarraytests(@nospecialize(A), I...)
+ function runsubarraytests(A, I...)
- function runsubarraytests(A::Array, I...)
+ function runsubarraytests(A :: Array, I...)
- function runtests(name, path, isolate=true; seed=nothing)
+ function runtests(name, path, isolate = true, seed = nothing)
- function runviews(SB::AbstractArray, indexN, indexNN, indexNNN)
+ function runviews(SB :: AbstractArray, indexN, indexNN, indexNNN)
- function runviews(SB::AbstractArray{T, 3} where T, indexN, indexNN, indexNNN)
+ function runviews(SB :: AbstractArray{T, DependentType@6d311334} where T, indexN, indexNN, indexNNN)
- function runviews(SB::AbstractArray{T,1}, indexN, indexNN, indexNNN) where T
+ function runviews(SB :: AbstractArray{T, DependentType@682a0b20}, indexN, indexNN, indexNNN) where T
- function runviews(SB::AbstractArray{T,2}, indexN, indexNN, indexNNN) where T
+ function runviews(SB :: AbstractArray{T, DependentType@3d075dc0}, indexN, indexNN, indexNNN) where T
- function safe_mapslices(op, A, region)
+ function safe_mapslices(op, A, region)
- function same_path(x::AbstractString, y::AbstractString)
+ function same_path(x :: AbstractString, y :: AbstractString)
- function samefile(a::StatStruct, b::StatStruct)
+ function samefile(a :: StatStruct, b :: StatStruct)
- function sametype_error(input)
+ function sametype_error(input)
- function sample(S, n::Real)
+ function sample(S, n :: Real)
- function sandwiched_backtrace()
+ function sandwiched_backtrace
- function sb_accuracy(x,expected)
+ function sb_accuracy(x, expected)
- function scaleargs_cdiv(a::Float64, b::Float64, c::Float64, d::Float64, ab::Float64, cd::Float64)
+ function scaleargs_cdiv(a :: Float64, b :: Float64, c :: Float64, d :: Float64, ab :: Float64, cd :: Float64)
- function scaleinv(x::T) where T<:IEEEFloat
+ function scaleinv(x :: T) where T <: IEEEFloat
- function scaling_cdiv(a::Float64, b::Float64, c::Float64, d::Float64, ab::Float64, cd::Float64)
+ function scaling_cdiv(a :: Float64, b :: Float64, c :: Float64, d :: Float64, ab :: Float64, cd :: Float64)
- function scan!(callback, scanner::BBScanner, forwards_only::Bool)
+ function scan!(callback, scanner :: BBScanner, forwards_only :: Bool)
- function scan_entry!(result::Vector{SlotInfo}, idx::Int, @nospecialize(stmt))
+ function scan_entry!(result :: Vector{SlotInfo}, idx :: Int, stmt)
- function scan_inconsistency!(inst::Instruction, idx::Int, sv::PostOptAnalysisState)
+ function scan_inconsistency!(inst :: Instruction, idx :: Int, sv :: PostOptAnalysisState)
- function scan_non_dataflow_flags!(inst::Instruction, sv::PostOptAnalysisState)
+ function scan_non_dataflow_flags!(inst :: Instruction, sv :: PostOptAnalysisState)
- function scan_slot_def_use(nargs::Int, ci::CodeInfo, code::Vector{Any})
+ function scan_slot_def_use(nargs :: Int, ci :: CodeInfo, code :: Vector{Any})
- function schedule(t::Task, @nospecialize(arg); error=false)
+ function schedule(t :: Task, arg, error = false)
- function schur!(A::StridedMatrix{T}, B::StridedMatrix{T}) where {T<:BlasFloat}
+ function schur!(A :: StridedMatrix{T}, B :: StridedMatrix{T}) where T <: BlasFloat
- function schur(A::AbstractMatrix{TA}, B::AbstractMatrix{TB}) where {TA,TB}
+ function schur(A :: AbstractMatrix{TA}, B :: AbstractMatrix{TB}) where TA, TB
- function schur(A::Bidiagonal{T}) where {T}
+ function schur(A :: Bidiagonal{T}) where T
- function schur(A::RealHermSymComplexHerm)
+ function schur(A :: RealHermSymComplexHerm)
- function schur(A::Union{UnitLowerTriangular{T},LowerTriangular{T}}) where {T}
+ function schur(A :: Union{UnitLowerTriangular{T}, LowerTriangular{T}}) where T
- function schur(A::Union{UnitUpperTriangular{T},UpperTriangular{T}}) where {T}
+ function schur(A :: Union{UnitUpperTriangular{T}, UpperTriangular{T}}) where T
- function schurpow(A::AbstractMatrix, p)
+ function schurpow(A :: AbstractMatrix, p)
- function scrub_backtrace(bt, file_ts, file_t)
+ function scrub_backtrace(bt, file_ts, file_t)
- function scrub_exc_stack(stack, file_ts, file_t)
+ function scrub_exc_stack(stack, file_ts, file_t)
- function scrub_repl_backtrace(bt)
+ function scrub_repl_backtrace(bt)
- function searchsorted(v::AbstractVector, x, ilo::T, ihi::T, o::Ordering)::UnitRange{keytype(v)} where T<:Integer
+ function searchsorted(v :: AbstractVector, x, ilo :: T, ihi :: T, o :: Ordering) where T <: Integer
- function searchsortedfirst(a::AbstractRange{<:Integer}, x::Real, o::FastRangeOrderings)::keytype(a)
+ function searchsortedfirst(a :: AbstractRange{??? <: Integer}, x :: Real, o :: FastRangeOrderings)
- function searchsortedfirst(a::AbstractRange{<:Real}, x::Real, o::FastRangeOrderings)::keytype(a)
+ function searchsortedfirst(a :: AbstractRange{??? <: Real}, x :: Real, o :: FastRangeOrderings)
- function searchsortedfirst(v::AbstractVector, x, lo::T, hi::T, o::Ordering)::keytype(v) where T<:Integer
+ function searchsortedfirst(v :: AbstractVector, x, lo :: T, hi :: T, o :: Ordering) where T <: Integer
- function searchsortedlast(a::AbstractRange{<:Integer}, x::Real, o::FastRangeOrderings)::keytype(a)
+ function searchsortedlast(a :: AbstractRange{??? <: Integer}, x :: Real, o :: FastRangeOrderings)
- function searchsortedlast(a::AbstractRange{<:Real}, x::Real, o::FastRangeOrderings)::keytype(a)
+ function searchsortedlast(a :: AbstractRange{??? <: Real}, x :: Real, o :: FastRangeOrderings)
- function searchsortedlast(v::AbstractVector, x, lo::T, hi::T, o::Ordering)::keytype(v) where T<:Integer
+ function searchsortedlast(v :: AbstractVector, x, lo :: T, hi :: T, o :: Ordering) where T <: Integer
- function seed!(rng::Union{TaskLocalRNG, Xoshiro}, ::Nothing)
+ function seed!(rng :: Union{TaskLocalRNG, Xoshiro}, ??? :: Nothing)
- function seed!(seed=nothing)
+ function seed!(seed = nothing)
- function seek(f::File, n::Integer)
+ function seek(f :: File, n :: Integer)
- function seek(io::GenericIOBuffer, n::Integer)
+ function seek(io :: GenericIOBuffer, n :: Integer)
- function seek(s::IOStream, n::Integer)
+ function seek(s :: IOStream, n :: Integer)
- function seekend(f::File)
+ function seekend(f :: File)
- function seekend(io::GenericIOBuffer)
+ function seekend(io :: GenericIOBuffer)
- function seekend(s::IOStream)
+ function seekend(s :: IOStream)
- function segfault6793(;gamma=1)
+ function segfault6793(gamma = 1)
- function segfaultfunction_20847(A::Vector{NTuple{N, T}}) where {N, T}
+ function segfaultfunction_20847(A :: Vector{NTuple{N, T}}) where N, T
- function select_platform(download_info::Dict, platform::AbstractPlatform = HostPlatform())
+ function select_platform(download_info :: Dict, platform :: AbstractPlatform = HostPlatform())
- function send(sock::UDPSocket, ipaddr::IPAddr, port::Integer, msg)
+ function send(sock :: UDPSocket, ipaddr :: IPAddr, port :: Integer, msg)
- function send_to_end!(f::F, v::AbstractVector; lo=firstindex(v), hi=lastindex(v)) where F <: Function
+ function send_to_end!(f :: F, v :: AbstractVector, lo = firstindex(v), hi = lastindex(v)) where F <: Function
- function sendfile(dst::File, src::File, src_offset::Int64, bytes::Int)
+ function sendfile(dst :: File, src :: File, src_offset :: Int64, bytes :: Int)
- function sendfile(src::AbstractString, dst::AbstractString)
+ function sendfile(src :: AbstractString, dst :: AbstractString)
- function sendrepl2(cmd)
+ function sendrepl2(cmd)
- function sendrepl2(cmd, txt)
+ function sendrepl2(cmd, txt)
- function serialize(s::AbstractSerializer, S::SharedArray)
+ function serialize(s :: AbstractSerializer, S :: SharedArray)
- function serialize(s::AbstractSerializer, a::Array)
+ function serialize(s :: AbstractSerializer, a :: Array)
- function serialize(s::AbstractSerializer, a::SubArray{T,N,A}) where {T,N,A<:Array}
+ function serialize(s :: AbstractSerializer, a :: SubArray{T, N, A}) where T, N, A <: Array
- function serialize(s::AbstractSerializer, cond::Base.GenericCondition)
+ function serialize(s :: AbstractSerializer, cond :: Base.GenericCondition)
- function serialize(s::AbstractSerializer, d::Dict)
+ function serialize(s :: AbstractSerializer, d :: Dict)
- function serialize(s::AbstractSerializer, d::IdDict)
+ function serialize(s :: AbstractSerializer, d :: IdDict)
- function serialize(s::AbstractSerializer, ex::Expr)
+ function serialize(s :: AbstractSerializer, ex :: Expr)
- function serialize(s::AbstractSerializer, frame::Base.StackTraces.StackFrame)
+ function serialize(s :: AbstractSerializer, frame :: Base.StackTraces.StackFrame)
- function serialize(s::AbstractSerializer, g::GlobalRef)
+ function serialize(s :: AbstractSerializer, g :: GlobalRef)
- function serialize(s::AbstractSerializer, linfo::Core.MethodInstance)
+ function serialize(s :: AbstractSerializer, linfo :: Core.MethodInstance)
- function serialize(s::AbstractSerializer, lock::Base.AbstractLock)
+ function serialize(s :: AbstractSerializer, lock :: Base.AbstractLock)
- function serialize(s::AbstractSerializer, m::Memory)
+ function serialize(s :: AbstractSerializer, m :: Memory)
- function serialize(s::AbstractSerializer, m::Module)
+ function serialize(s :: AbstractSerializer, m :: Module)
- function serialize(s::AbstractSerializer, meth::Method)
+ function serialize(s :: AbstractSerializer, meth :: Method)
- function serialize(s::AbstractSerializer, n::BigInt)
+ function serialize(s :: AbstractSerializer, n :: BigInt)
- function serialize(s::AbstractSerializer, n::Int32)
+ function serialize(s :: AbstractSerializer, n :: Int32)
- function serialize(s::AbstractSerializer, n::Int64)
+ function serialize(s :: AbstractSerializer, n :: Int64)
- function serialize(s::AbstractSerializer, r::Regex)
+ function serialize(s :: AbstractSerializer, r :: Regex)
- function serialize(s::AbstractSerializer, ss::String)
+ function serialize(s :: AbstractSerializer, ss :: String)
- function serialize(s::AbstractSerializer, ss::SubString{String})
+ function serialize(s :: AbstractSerializer, ss :: SubString{String})
- function serialize(s::AbstractSerializer, t::Core.TypeName)
+ function serialize(s :: AbstractSerializer, t :: Core.TypeName)
- function serialize(s::AbstractSerializer, t::DataType)
+ function serialize(s :: AbstractSerializer, t :: DataType)
- function serialize(s::AbstractSerializer, t::Task)
+ function serialize(s :: AbstractSerializer, t :: Task)
- function serialize(s::AbstractSerializer, t::Tuple)
+ function serialize(s :: AbstractSerializer, t :: Tuple)
- function serialize(s::AbstractSerializer, u::UnionAll)
+ function serialize(s :: AbstractSerializer, u :: UnionAll)
- function serialize(s::AbstractSerializer, v::SimpleVector)
+ function serialize(s :: AbstractSerializer, v :: SimpleVector)
- function serialize(s::AbstractSerializer, x::Core.AddrSpace)
+ function serialize(s :: AbstractSerializer, x :: Core.AddrSpace)
- function serialize(s::AbstractSerializer, x::GenericMemoryRef)
+ function serialize(s :: AbstractSerializer, x :: GenericMemoryRef)
- function serialize(s::AbstractSerializer, x::Symbol)
+ function serialize(s :: AbstractSerializer, x :: Symbol)
- function serialize(s::IO, x)
+ function serialize(s :: IO, x)
- function serialize_any(s::AbstractSerializer, @nospecialize(x))
+ function serialize_any(s :: AbstractSerializer, x)
- function serialize_array_data(s::IO, a)
+ function serialize_array_data(s :: IO, a)
- function serialize_cycle(s::AbstractSerializer, @nospecialize(x))
+ function serialize_cycle(s :: AbstractSerializer, x)
- function serialize_cycle_header(s::AbstractSerializer, @nospecialize(x))
+ function serialize_cycle_header(s :: AbstractSerializer, x)
- function serialize_dict_data(s::AbstractSerializer, d::AbstractDict)
+ function serialize_dict_data(s :: AbstractSerializer, d :: AbstractDict)
- function serialize_mod_names(s::AbstractSerializer, m::Module)
+ function serialize_mod_names(s :: AbstractSerializer, m :: Module)
- function serialize_type(s::AbstractSerializer, @nospecialize(t::DataType), ref::Bool = false)
+ function serialize_type(s :: AbstractSerializer, t :: DataType, ref :: Bool = false)
- function serialize_type_data(s, @nospecialize(t::DataType))
+ function serialize_type_data(s, t :: DataType)
- function serialize_typename(s::AbstractSerializer, t::Core.TypeName)
+ function serialize_typename(s :: AbstractSerializer, t :: Core.TypeName)
- function sertag(@nospecialize(v))
+ function sertag(v)
- function set!(c::GitConfig, name::AbstractString, value::AbstractString)
+ function set!(c :: GitConfig, name :: AbstractString, value :: AbstractString)
- function set!(c::GitConfig, name::AbstractString, value::Bool)
+ function set!(c :: GitConfig, name :: AbstractString, value :: Bool)
- function set!(c::GitConfig, name::AbstractString, value::Int32)
+ function set!(c :: GitConfig, name :: AbstractString, value :: Int32)
- function set!(c::GitConfig, name::AbstractString, value::Int64)
+ function set!(c :: GitConfig, name :: AbstractString, value :: Int64)
- function set!(trie::HAMT, bi::BitmapIndex)
+ function set!(trie :: HAMT, bi :: BitmapIndex)
- function set!(z::Rational{BigInt}, x::Rational{BigInt})
+ function set!(z :: Rational{BigInt}, x :: Rational{BigInt})
- function set_action!(s::MIState, command::Symbol)
+ function set_action!(s :: MIState, command :: Symbol)
- function set_active_project(projfile::Union{AbstractString,Nothing})
+ function set_active_project(projfile :: Union{AbstractString, Nothing})
- function set_aux_root(n :: Int, x :: String)
+ function set_aux_root(n :: Int, x :: String)
- function set_compare_strategy!(p::Platform, key::String, f::Function)
+ function set_compare_strategy!(p :: Platform, key :: String, f :: Function)
- function set_curr_ssaflag!(sv::IRInterpretationState, flag::UInt32, mask::UInt32=typemax(UInt32))
+ function set_curr_ssaflag!(sv :: IRInterpretationState, flag :: UInt32, mask :: UInt32 = typemax(UInt32))
- function set_curr_ssaflag!(sv::InferenceState, flag::UInt32, mask::UInt32=typemax(UInt32))
+ function set_curr_ssaflag!(sv :: InferenceState, flag :: UInt32, mask :: UInt32 = typemax(UInt32))
- function set_global_dir(dir)
+ function set_global_dir(dir)
- function set_num_threads(::Nothing)
+ function set_num_threads(??? :: Nothing)
- function set_output_prefix(repl::LineEditREPL, n::Ref{Int})
+ function set_output_prefix(repl :: LineEditREPL, n :: Ref{Int})
- function set_pkgorigin_version_path(pkg::PkgId, path::Union{String,Nothing})
+ function set_pkgorigin_version_path(pkg :: PkgId, path :: Union{String, Nothing})
- function set_process_title(title::AbstractString)
+ function set_process_title(title :: AbstractString)
- function set_prompt(repl::LineEditREPL, n::Ref{Int})
+ function set_prompt(repl :: LineEditREPL, n :: Ref{Int})
- function set_remote_fetch_url(path::AbstractString, remote_name::AbstractString, url::AbstractString)
+ function set_remote_fetch_url(path :: AbstractString, remote_name :: AbstractString, url :: AbstractString)
- function set_remote_fetch_url(repo::GitRepo, remote_name::AbstractString, url::AbstractString)
+ function set_remote_fetch_url(repo :: GitRepo, remote_name :: AbstractString, url :: AbstractString)
- function set_remote_push_url(path::AbstractString, remote_name::AbstractString, url::AbstractString)
+ function set_remote_push_url(path :: AbstractString, remote_name :: AbstractString, url :: AbstractString)
- function set_remote_push_url(repo::GitRepo, remote_name::AbstractString, url::AbstractString)
+ function set_remote_push_url(repo :: GitRepo, remote_name :: AbstractString, url :: AbstractString)
- function set_remote_url(path::AbstractString, remote_name::AbstractString, url::AbstractString)
+ function set_remote_url(path :: AbstractString, remote_name :: AbstractString, url :: AbstractString)
- function set_remote_url(repo::GitRepo, remote_name::AbstractString, url::AbstractString)
+ function set_remote_url(repo :: GitRepo, remote_name :: AbstractString, url :: AbstractString)
- function set_ssl_cert_locations(cert_loc)
+ function set_ssl_cert_locations(cert_loc)
- function set_z!(z::Rational{BigInt}, x::BigInt)
+ function set_z!(z :: Rational{BigInt}, x :: BigInt)
- function setdiff!(s::AbstractSet, itr)
+ function setdiff!(s :: AbstractSet, itr)
- function setdiff!(s::AbstractSet, itrs...)
+ function setdiff!(s :: AbstractSet, itrs...)
- function setdiff!(s::Set, t::Set)
+ function setdiff!(s :: Set, t :: Set)
- function setextheader(stream::IO, md::MD)
+ function setextheader(stream :: IO, md :: MD)
- function setindex!(A::AbstractArray, v, I...)
+ function setindex!(A :: AbstractArray, v, I...)
- function setindex!(A::Array, X::AbstractArray, I::AbstractVector{Int})
+ function setindex!(A :: Array, X :: AbstractArray, I :: AbstractVector{Int})
- function setindex!(A::Array{Any}, @nospecialize(x), i::Int)
+ function setindex!(A :: Array{Any}, x, i :: Int)
- function setindex!(A::Array{T}, X::Array{T}, I::AbstractUnitRange{Int}) where T
+ function setindex!(A :: Array{T}, X :: Array{T}, I :: AbstractUnitRange{Int}) where T
- function setindex!(A::Array{T}, X::Array{T}, c::Colon) where T
+ function setindex!(A :: Array{T}, X :: Array{T}, c :: Colon) where T
- function setindex!(A::Array{T}, x, i1::Int, i2::Int, I::Int...) where {T}
+ function setindex!(A :: Array{T}, x, i1 :: Int, i2 :: Int, I :: Int...) where T
- function setindex!(A::Array{T}, x, i::Int) where {T}
+ function setindex!(A :: Array{T}, x, i :: Int) where T
- function setindex!(A::Hermitian, v, i::Integer, j::Integer)
+ function setindex!(A :: Hermitian, v, i :: Integer, j :: Integer)
- function setindex!(A::LowerTriangular, x, i::Integer, j::Integer)
+ function setindex!(A :: LowerTriangular, x, i :: Integer, j :: Integer)
- function setindex!(A::Memory{T}, X::Memory{T}, I::AbstractUnitRange{Int}) where T
+ function setindex!(A :: Memory{T}, X :: Memory{T}, I :: AbstractUnitRange{Int}) where T
- function setindex!(A::Memory{T}, X::Memory{T}, c::Colon) where T
+ function setindex!(A :: Memory{T}, X :: Memory{T}, c :: Colon) where T
- function setindex!(A::Memory{T}, x, i1::Int) where {T}
+ function setindex!(A :: Memory{T}, x, i1 :: Int) where T
- function setindex!(A::Memory{T}, x, i1::Int, i2::Int, I::Int...) where {T}
+ function setindex!(A :: Memory{T}, x, i1 :: Int, i2 :: Int, I :: Int...) where T
- function setindex!(A::Symmetric, v, i::Integer, j::Integer)
+ function setindex!(A :: Symmetric, v, i :: Integer, j :: Integer)
- function setindex!(A::UnitLowerTriangular, x, i::Integer, j::Integer)
+ function setindex!(A :: UnitLowerTriangular, x, i :: Integer, j :: Integer)
- function setindex!(A::UnitUpperTriangular, x, i::Integer, j::Integer)
+ function setindex!(A :: UnitUpperTriangular, x, i :: Integer, j :: Integer)
- function setindex!(A::UpperHessenberg, x, i::Integer, j::Integer)
+ function setindex!(A :: UpperHessenberg, x, i :: Integer, j :: Integer)
- function setindex!(A::UpperTriangular, x, i::Integer, j::Integer)
+ function setindex!(A :: UpperTriangular, x, i :: Integer, j :: Integer)
- function setindex!(D::Diagonal, v, i::Int, j::Int)
+ function setindex!(D :: Diagonal, v, i :: Int, j :: Int)
- function setindex!(V::FastContiguousSubArray, x, i::Int)
+ function setindex!(V :: FastContiguousSubArray, x, i :: Int)
- function setindex!(V::FastContiguousSubArray{<:Any, 1}, x, i::Int)
+ function setindex!(V :: FastContiguousSubArray{??? <: Any, DependentType@214c265e}, x, i :: Int)
- function setindex!(V::FastSubArray, x, i::Int)
+ function setindex!(V :: FastSubArray, x, i :: Int)
- function setindex!(V::FastSubArray{<:Any, 1}, x, i::Int)
+ function setindex!(V :: FastSubArray{??? <: Any, DependentType@448139f0}, x, i :: Int)
- function setindex!(V::SubArray{T,N}, x, I::Vararg{Int,N}) where {T,N}
+ function setindex!(V :: SubArray{T, N}, x, I :: Vararg{Int, N}) where T, N
- function setindex!(cache::InternalCodeCache, ci::CodeInstance, mi::MethodInstance)
+ function setindex!(cache :: InternalCodeCache, ci :: CodeInstance, mi :: MethodInstance)
- function setindex!(compact::IncrementalCompact, @nospecialize(v), idx::Int)
+ function setindex!(compact :: IncrementalCompact, v, idx :: Int)
- function setindex!(compact::IncrementalCompact, @nospecialize(v), idx::OldSSAValue)
+ function setindex!(compact :: IncrementalCompact, v, idx :: OldSSAValue)
- function setindex!(compact::IncrementalCompact, @nospecialize(v), idx::SSAValue)
+ function setindex!(compact :: IncrementalCompact, v, idx :: SSAValue)
- function setindex!(d::IdDict{K,V}, @nospecialize(val), @nospecialize(key)) where {K, V}
+ function setindex!(d :: IdDict{K, V}, val, key) where K, V
- function setindex!(estate::EscapeState, v::EscapeInfo, @nospecialize(x))
+ function setindex!(estate :: EscapeState, v :: EscapeInfo, x)
- function setindex!(h::Dict{K,Any}, v, key::K) where K
+ function setindex!(h :: Dict{K, Any}, v, key :: K) where K
- function setindex!(h::Dict{K,V}, v0, key0) where V where K
+ function setindex!(h :: Dict{K, V}, v0, key0) where V where K
- function setindex!(h::Dict{K,V}, v0, key::K) where V where K
+ function setindex!(h :: Dict{K, V}, v0, key :: K) where V where K
- function setindex!(is::InstructionStream, newval::Instruction, idx::Int)
+ function setindex!(is :: InstructionStream, newval :: Instruction, idx :: Int)
- function setindex!(is::InstructionStream, newval::Union{AnySSAValue, Nothing}, idx::Int)
+ function setindex!(is :: InstructionStream, newval :: Union{AnySSAValue, Nothing}, idx :: Int)
- function setindex!(node::Instruction, newval::Instruction)
+ function setindex!(node :: Instruction, newval :: Instruction)
- function setindex!(wkh::WeakKeyDict{K}, v, key) where K
+ function setindex!(wkh :: WeakKeyDict{K}, v, key) where K
- function setindex!(wvc::WorldView{InternalCodeCache}, ci::CodeInstance, mi::MethodInstance)
+ function setindex!(wvc :: WorldView{InternalCodeCache}, ci :: CodeInstance, mi :: MethodInstance)
- function setindex!(x::IRCode, repl::Union{Instruction, Nothing, AnySSAValue}, s::SSAValue)
+ function setindex!(x :: IRCode, repl :: Union{Instruction, Nothing, AnySSAValue}, s :: SSAValue)
- function setindex(nt::NamedTuple, v, idx::Symbol)
+ function setindex(nt :: NamedTuple, v, idx :: Symbol)
- function setindex(x::Tuple, v, i::Integer)
+ function setindex(x :: Tuple, v, i :: Integer)
- function setindex_shape_check(X::AbstractArray, I::Integer...)
+ function setindex_shape_check(X :: AbstractArray, I :: Integer...)
- function setindex_shape_check(X::AbstractArray{<:Any,2}, i::Integer, j::Integer)
+ function setindex_shape_check(X :: AbstractArray{??? <: Any, DependentType@7cca494b}, i :: Integer, j :: Integer)
- function setindex_widen_up_to(dest::AbstractArray{T}, el, i) where T
+ function setindex_widen_up_to(dest :: AbstractArray{T}, el, i) where T
- function setmark(s::MIState, guess_region_active::Bool=true)
+ function setmark(s :: MIState, guess_region_active :: Bool = true)
- function setopt(sock::UDPSocket; multicast_loop=nothing, multicast_ttl=nothing, enable_broadcast=nothing, ttl=nothing)
+ function setopt(sock :: UDPSocket, multicast_loop = nothing, multicast_ttl = nothing, enable_broadcast = nothing, ttl = nothing)
- function setprecision(::Type{BigFloat}, precision::Integer; base::Integer=2)
+ function setprecision(??? :: Type{BigFloat}, precision :: Integer, base :: Integer = 2)
- function setprecision(f::Function, ::Type{T}, prec::Integer; kws...) where T
+ function setprecision(f :: Function, ??? :: Type{T}, prec :: Integer, kws...) where T
- function setproperty!(ci::CodeInfo, s::Symbol, v)
+ function setproperty!(ci :: CodeInfo, s :: Symbol, v)
- function setproperty!(x, f::Symbol, v)
+ function setproperty!(x, f :: Symbol, v)
- function setproperty!(x, f::Symbol, v, order::Symbol)
+ function setproperty!(x, f :: Symbol, v, order :: Symbol)
- function setproperty!(x::Module, f::Symbol, v, order::Symbol=:monotonic)
+ function setproperty!(x :: Module, f :: Symbol, v, order :: Symbol = :monotonic)
- function setrounding(f::Function, ::Type{T}, rounding::RoundingMode) where T
+ function setrounding(f :: Function, ??? :: Type{T}, rounding :: RoundingMode) where T
- function setrounding_raw(f::Function, ::Type{T}, rounding) where T
+ function setrounding_raw(f :: Function, ??? :: Type{T}, rounding) where T
- function settings(s::RawFD, shared::Bool)
+ function settings(s :: RawFD, shared :: Bool)
- function setup_chnl_and_tasks(exec_func, ntasks, batch_size=nothing)
+ function setup_chnl_and_tasks(exec_func, ntasks, batch_size = nothing)
- function setup_clone_repo(cache_repo::AbstractString, path::AbstractString; name="AAAA", email="BBBB@BBBB.COM")
+ function setup_clone_repo(cache_repo :: AbstractString, path :: AbstractString, name = "AAAA", email = "BBBB@BBBB.COM")
- function setup_dirs(tmpdir)
+ function setup_dirs(tmpdir)
- function setup_files(tmpdir)
+ function setup_files(tmpdir)
- function setup_prefix_keymap(hp::HistoryProvider, parent_prompt::Prompt)
+ function setup_prefix_keymap(hp :: HistoryProvider, parent_prompt :: Prompt)
- function setup_search_keymap(hp)
+ function setup_search_keymap(hp)
- function setup_stdio(stdio::FileRedirect, child_readable::Bool)
+ function setup_stdio(stdio :: FileRedirect, child_readable :: Bool)
- function setup_stdio(stdio::IO, child_readable::Bool)
+ function setup_stdio(stdio :: IO, child_readable :: Bool)
- function setup_stdio(stdio::IOStream, child_readable::Bool)
+ function setup_stdio(stdio :: IOStream, child_readable :: Bool)
- function setup_stdio(stdio::Pipe, child_readable::Bool)
+ function setup_stdio(stdio :: Pipe, child_readable :: Bool)
- function setup_stdio(stdio::PipeEndpoint, child_readable::Bool)
+ function setup_stdio(stdio :: PipeEndpoint, child_readable :: Bool)
- function setup_stdios(f, stdios::SpawnIOs)
+ function setup_stdios(f, stdios :: SpawnIOs)
- function shared_pids(pids)
+ function shared_pids(pids)
- function shell_completions(string, pos)
+ function shell_completions(string, pos)
- function shell_escape(str)
+ function shell_escape(str)
- function shell_escape_csh(io::IO, args::AbstractString...)
+ function shell_escape_csh(io :: IO, args :: AbstractString...)
- function shell_escape_wincmd(io::IO, s::AbstractString)
+ function shell_escape_wincmd(io :: IO, s :: AbstractString)
- function shell_split(s::AbstractString)
+ function shell_split(s :: AbstractString)
- function shift_tab_completion(s::MIState)
+ function shift_tab_completion(s :: MIState)
- function shm_mmap_array(T, dims, shm_seg_name, mode)
+ function shm_mmap_array(T, dims, shm_seg_name, mode)
- function shm_open(shm_seg_name, oflags, permissions)
+ function shm_open(shm_seg_name, oflags, permissions)
- function shmem_fill(v, dims; kwargs...)
+ function shmem_fill(v, dims, kwargs...)
- function shmem_rand(TR::Union{DataType, UnitRange}, dims; kwargs...)
+ function shmem_rand(TR :: Union{DataType, UnitRange}, dims, kwargs...)
- function shmem_randn(dims; kwargs...)
+ function shmem_randn(dims, kwargs...)
- function short_path(spath::Symbol, filenamecache::Dict{Symbol, String})
+ function short_path(spath :: Symbol, filenamecache :: Dict{Symbol, String})
- function shortname(ref::GitReference)
+ function shortname(ref :: GitReference)
- function should_infer_for_effects(sv::InferenceState)
+ function should_infer_for_effects(sv :: InferenceState)
- function should_infer_this_call(interp::AbstractInterpreter, sv::InferenceState)
+ function should_infer_this_call(interp :: AbstractInterpreter, sv :: InferenceState)
- function should_insert_coverage(mod::Module, src::CodeInfo)
+ function should_insert_coverage(mod :: Module, src :: CodeInfo)
- function should_print_ssa_type(@nospecialize node)
+ function should_print_ssa_type(node)
- function should_send_whole_type(s, t::DataType)
+ function should_send_whole_type(s, t :: DataType)
- function should_use_main_entrypoint()
+ function should_use_main_entrypoint
- function show(io::IO, ::EnvDict)
+ function show(io :: IO, ??? :: EnvDict)
- function show(io::IO, ::MIME"text/html", m::Method)
+ function show(io :: IO, ??? :: MIME"text/html", m :: Method)
- function show(io::IO, ::MIME"text/html", md::MD)
+ function show(io :: IO, ??? :: MIME"text/html", md :: MD)
- function show(io::IO, ::MIME"text/plain", @nospecialize(x::Type))
+ function show(io :: IO, ??? :: MIME"text/plain", x :: Type)
- function show(io::IO, ::MIME"text/plain", J::UniformScaling)
+ function show(io :: IO, ??? :: MIME"text/plain", J :: UniformScaling)
- function show(io::IO, ::MIME"text/plain", X::AbstractArray)
+ function show(io :: IO, ??? :: MIME"text/plain", X :: AbstractArray)
- function show(io::IO, ::MIME"text/plain", c::Channel)
+ function show(io :: IO, ??? :: MIME"text/plain", c :: Channel)
- function show(io::IO, ::MIME"text/plain", c::T) where {T<:AbstractChar}
+ function show(io :: IO, ??? :: MIME"text/plain", c :: T) where T <: AbstractChar
- function show(io::IO, ::MIME"text/plain", f::Function)
+ function show(io :: IO, ??? :: MIME"text/plain", f :: Function)
- function show(io::IO, ::MIME"text/plain", iter::Union{KeySet,ValueIterator})
+ function show(io :: IO, ??? :: MIME"text/plain", iter :: Union{KeySet, ValueIterator})
- function show(io::IO, ::MIME"text/plain", oc::Core.OpaqueClosure{A, R}) where {A, R}
+ function show(io :: IO, ??? :: MIME"text/plain", oc :: Core.OpaqueClosure{A, R}) where A, R
- function show(io::IO, ::MIME"text/plain", opt::JLOptions)
+ function show(io :: IO, ??? :: MIME"text/plain", opt :: JLOptions)
- function show(io::IO, ::MIME"text/plain", r::LinRange)
+ function show(io :: IO, ??? :: MIME"text/plain", r :: LinRange)
- function show(io::IO, ::MIME"text/plain", stack::ExceptionStack)
+ function show(io :: IO, ??? :: MIME"text/plain", stack :: ExceptionStack)
- function show(io::IO, ::MIME"text/plain", t::AbstractDict{K,V}) where {K,V}
+ function show(io :: IO, ??? :: MIME"text/plain", t :: AbstractDict{K, V}) where K, V
- function show(io::IO, ::MIME"text/plain", t::AbstractSet{T}) where T
+ function show(io :: IO, ??? :: MIME"text/plain", t :: AbstractSet{T}) where T
- function show(io::IO, ::MIME"text/plain", t::Task)
+ function show(io :: IO, ??? :: MIME"text/plain", t :: Task)
- function show(io::IO, ::MIME"text/plain", ti::TermInfo)
+ function show(io :: IO, ??? :: MIME"text/plain", ti :: TermInfo)
- function show(io::IO, ::MIME"text/plain", u::UndefInitializer)
+ function show(io :: IO, ??? :: MIME"text/plain", u :: UndefInitializer)
- function show(io::IO, ::MIME"text/plain", x::Irrational{sym}) where {sym}
+ function show(io :: IO, ??? :: MIME"text/plain", x :: Irrational{sym}) where sym
- function show(io::IO, ::MIME{Symbol("text/plain")}, Q::AbstractQ)
+ function show(io :: IO, ??? :: MIME{Symbol, ("text/plain", )}, Q :: AbstractQ)
- function show(io::IO, M::Bidiagonal)
+ function show(io :: IO, M :: Bidiagonal)
- function show(io::IO, S::SharedArray)
+ function show(io :: IO, S :: SharedArray)
- function show(io::IO, X::AbstractArray)
+ function show(io :: IO, X :: AbstractArray)
- function show(io::IO, addr::InetAddr)
+ function show(io :: IO, addr :: InetAddr)
- function show(io::IO, b::BigFloat)
+ function show(io :: IO, b :: BigFloat)
- function show(io::IO, c::AbstractChar)
+ function show(io :: IO, c :: AbstractChar)
- function show(io::IO, c::ComposedFunction)
+ function show(io :: IO, c :: ComposedFunction)
- function show(io::IO, c::ComposedFunction{typeof(!)})
+ function show(io :: IO, c :: ComposedFunction{typeof(!)})
- function show(io::IO, cf::CacheFlags)
+ function show(io :: IO, cf :: CacheFlags)
- function show(io::IO, cmd::Cmd)
+ function show(io :: IO, cmd :: Cmd)
- function show(io::IO, cmds::AndCmds)
+ function show(io :: IO, cmds :: AndCmds)
- function show(io::IO, cmds::Union{OrCmds,ErrOrCmds})
+ function show(io :: IO, cmds :: Union{OrCmds, ErrOrCmds})
- function show(io::IO, cr::CmdRedirect)
+ function show(io :: IO, cr :: CmdRedirect)
- function show(io::IO, e::Iterators.Enumerate)
+ function show(io :: IO, e :: Iterators.Enumerate)
- function show(io::IO, err::DNSError)
+ function show(io :: IO, err :: DNSError)
- function show(io::IO, ex::PrecompilableError)
+ function show(io :: IO, ex :: PrecompilableError)
- function show(io::IO, f::Core.IntrinsicFunction)
+ function show(io :: IO, f :: Core.IntrinsicFunction)
- function show(io::IO, frame::StackFrame)
+ function show(io :: IO, frame :: StackFrame)
- function show(io::IO, inferred::Core.Compiler.InferenceResult)
+ function show(io :: IO, inferred :: Core.Compiler.InferenceResult)
- function show(io::IO, ip::InterpreterIP)
+ function show(io :: IO, ip :: InterpreterIP)
- function show(io::IO, it::ImageTarget)
+ function show(io :: IO, it :: ImageTarget)
- function show(io::IO, iter::CartesianIndices)
+ function show(io :: IO, iter :: CartesianIndices)
- function show(io::IO, level::LogLevel)
+ function show(io :: IO, level :: LogLevel)
- function show(io::IO, m::Module)
+ function show(io :: IO, m :: Module)
- function show(io::IO, m::RegexMatch)
+ function show(io :: IO, m :: RegexMatch)
- function show(io::IO, mi_info::Core.Compiler.Timings.InferenceFrameInfo)
+ function show(io :: IO, mi_info :: Core.Compiler.Timings.InferenceFrameInfo)
- function show(io::IO, mime::MIME"text/html", ms::MethodList)
+ function show(io :: IO, mime :: MIME"text/html", ms :: MethodList)
- function show(io::IO, mime::MIME"text/html", mt::AbstractVector{Method})
+ function show(io :: IO, mime :: MIME"text/html", mt :: AbstractVector{Method})
- function show(io::IO, mime::MIME"text/plain", F::Hessenberg)
+ function show(io :: IO, mime :: MIME"text/plain", F :: Hessenberg)
- function show(io::IO, mime::MIME"text/plain", S::SharedArray)
+ function show(io :: IO, mime :: MIME"text/plain", S :: SharedArray)
- function show(io::IO, mime::MIME"text/plain", mt::AbstractVector{Method})
+ function show(io :: IO, mime :: MIME"text/plain", mt :: AbstractVector{Method})
- function show(io::IO, mime::MIME{Symbol("text/plain")}, C::Cholesky)
+ function show(io :: IO, mime :: MIME{Symbol, ("text/plain", )}, C :: Cholesky)
- function show(io::IO, mime::MIME{Symbol("text/plain")}, C::CholeskyPivoted)
+ function show(io :: IO, mime :: MIME{Symbol, ("text/plain", )}, C :: CholeskyPivoted)
- function show(io::IO, mime::MIME{Symbol("text/plain")}, F::GeneralizedSVD{<:Any,<:AbstractArray})
+ function show(io :: IO, mime :: MIME{Symbol, ("text/plain", )}, F :: GeneralizedSVD{??? <: Any, ??? <: AbstractArray})
- function show(io::IO, mime::MIME{Symbol("text/plain")}, F::GeneralizedSchur)
+ function show(io :: IO, mime :: MIME{Symbol, ("text/plain", )}, F :: GeneralizedSchur)
- function show(io::IO, mime::MIME{Symbol("text/plain")}, F::LDLt)
+ function show(io :: IO, mime :: MIME{Symbol, ("text/plain", )}, F :: LDLt)
- function show(io::IO, mime::MIME{Symbol("text/plain")}, F::LQ)
+ function show(io :: IO, mime :: MIME{Symbol, ("text/plain", )}, F :: LQ)
- function show(io::IO, mime::MIME{Symbol("text/plain")}, F::LU)
+ function show(io :: IO, mime :: MIME{Symbol, ("text/plain", )}, F :: LU)
- function show(io::IO, mime::MIME{Symbol("text/plain")}, F::SVD{<:Any,<:Any,<:AbstractArray,<:AbstractVector})
+ function show(io :: IO, mime :: MIME{Symbol, ("text/plain", )}, F :: SVD{??? <: Any, ??? <: Any, ??? <: AbstractArray, ??? <: AbstractVector})
- function show(io::IO, mime::MIME{Symbol("text/plain")}, F::Schur)
+ function show(io :: IO, mime :: MIME{Symbol, ("text/plain", )}, F :: Schur)
- function show(io::IO, mime::MIME{Symbol("text/plain")}, F::Union{Eigen,GeneralizedEigen})
+ function show(io :: IO, mime :: MIME{Symbol, ("text/plain", )}, F :: Union{Eigen, GeneralizedEigen})
- function show(io::IO, mime::MIME{Symbol("text/plain")}, F::Union{QR, QRCompactWY, QRPivoted})
+ function show(io :: IO, mime :: MIME{Symbol, ("text/plain", )}, F :: Union{QR, QRCompactWY, QRPivoted})
- function show(io::IO, oc::Core.OpaqueClosure)
+ function show(io :: IO, oc :: Core.OpaqueClosure)
- function show(io::IO, opt::JLOptions)
+ function show(io :: IO, opt :: JLOptions)
- function show(io::IO, p::Pair)
+ function show(io :: IO, p :: Pair)
- function show(io::IO, r::LinRange{T}) where {T}
+ function show(io :: IO, r :: LinRange{T}) where T
- function show(io::IO, r::StepRangeLen)
+ function show(io :: IO, r :: StepRangeLen)
- function show(io::IO, r::StepRangeLen{<:CartesianIndex})
+ function show(io :: IO, r :: StepRangeLen{??? <: CartesianIndex})
- function show(io::IO, re::Regex)
+ function show(io :: IO, re :: Regex)
- function show(io::IO, rng::MersenneTwister)
+ function show(io :: IO, rng :: MersenneTwister)
- function show(io::IO, s::BitSet)
+ function show(io :: IO, s :: BitSet)
- function show(io::IO, s::MIState)
+ function show(io :: IO, s :: MIState)
- function show(io::IO, s::PrefixSearchState)
+ function show(io :: IO, s :: PrefixSearchState)
- function show(io::IO, s::Set)
+ function show(io :: IO, s :: Set)
- function show(io::IO, s::SkipMissing)
+ function show(io :: IO, s :: SkipMissing)
- function show(io::IO, s::SubstitutionString)
+ function show(io :: IO, s :: SubstitutionString)
- function show(io::IO, src::CodeInfo; debuginfo::Symbol=:source)
+ function show(io :: IO, src :: CodeInfo, debuginfo :: Symbol = :source)
- function show(io::IO, t::AbstractDict{K,V}) where V where K
+ function show(io :: IO, t :: AbstractDict{K, V}) where V where K
- function show(io::IO, t::NamedTuple)
+ function show(io :: IO, t :: NamedTuple)
- function show(io::IO, t::Task)
+ function show(io :: IO, t :: Task)
- function show(io::IO, tinf::Core.Compiler.Timings.Timing)
+ function show(io :: IO, tinf :: Core.Compiler.Timings.Timing)
- function show(io::IO, tn::Core.TypeName)
+ function show(io :: IO, tn :: Core.TypeName)
- function show(io::IO, tv::TypeVar)
+ function show(io :: IO, tv :: TypeVar)
- function show(io::IO, vm::Core.TypeofVararg)
+ function show(io :: IO, vm :: Core.TypeofVararg)
- function show(io::IO, x::Rational)
+ function show(io :: IO, x :: Rational)
- function show(io::IO, x::Some)
+ function show(io :: IO, x :: Some)
- function show(io::IO, z::Complex)
+ function show(io :: IO, z :: Complex)
- function show_at_namedtuple(io::IO, syms::Tuple, types::DataType)
+ function show_at_namedtuple(io :: IO, syms :: Tuple, types :: DataType)
- function show_backtrace(io::IO, t::Vector)
+ function show_backtrace(io :: IO, t :: Vector)
- function show_block(io::IO, head, arg, block, i::Int, quote_level::Int)
+ function show_block(io :: IO, head, arg, block, i :: Int, quote_level :: Int)
- function show_block(io::IO, head, args::Vector, body, indent::Int, quote_level::Int)
+ function show_block(io :: IO, head, args :: Vector, body, indent :: Int, quote_level :: Int)
- function show_bound(io::IO, @nospecialize(b))
+ function show_bound(io :: IO, b)
- function show_call(io::IO, head, func, func_args, indent, quote_level, kw::Bool)
+ function show_call(io :: IO, head, func, func_args, indent, quote_level, kw :: Bool)
- function show_can_elide(p::TypeVar, wheres::Vector, elide::Int, env::SimpleVector, skip::Int)
+ function show_can_elide(p :: TypeVar, wheres :: Vector, elide :: Int, env :: SimpleVector, skip :: Int)
- function show_circular(io::IOContext, @nospecialize(x))
+ function show_circular(io :: IOContext, x)
- function show_completions(s::PromptState, completions::Vector{String})
+ function show_completions(s :: PromptState, completions :: Vector{String})
- function show_convert_error(io::IO, ex::MethodError, arg_types_param)
+ function show_convert_error(io :: IO, ex :: MethodError, arg_types_param)
- function show_datatype(io::IO, x::DataType, wheres::Vector{TypeVar}=TypeVar[])
+ function show_datatype(io :: IO, x :: DataType, wheres :: Vector{TypeVar} = TypeVar[])
- function show_delim_array(io::IO, itr, op, delim, cl, delim_one, i1=1, n=typemax(Int))
+ function show_delim_array(io :: IO, itr, op, delim, cl, delim_one, i1 = 1, n = typemax(Int))
- function show_enclosed_list(io::IO, op, items, sep, cl, indent, prec=0, quote_level=0, encl_ops=false, kw::Bool=false)
+ function show_enclosed_list(io :: IO, op, items, sep, cl, indent, prec = 0, quote_level = 0, encl_ops = false, kw :: Bool = false)
- function show_error_hints(io, ex, args...)
+ function show_error_hints(io, ex, args...)
- function show_exception_stack(io::IO, stack)
+ function show_exception_stack(io :: IO, stack)
- function show_full_backtrace(io::IO, trace::Vector; print_linebreaks::Bool)
+ function show_full_backtrace(io :: IO, trace :: Vector, print_linebreaks :: Bool)
- function show_function(io::IO, f::Function, compact::Bool, fallback::Function)
+ function show_function(io :: IO, f :: Function, compact :: Bool, fallback :: Function)
- function show_generator(io, ex::Expr, indent, quote_level)
+ function show_generator(io, ex :: Expr, indent, quote_level)
- function show_globalref(io::IO, ex::GlobalRef; allow_macroname=false)
+ function show_globalref(io :: IO, ex :: GlobalRef, allow_macroname = false)
- function show_import_path(io::IO, ex, quote_level)
+ function show_import_path(io :: IO, ex, quote_level)
- function show_invalid(io::IO, c::Char)
+ function show_invalid(io :: IO, c :: Char)
- function show_ir(io::IO, compact::IncrementalCompact, config::IRShowConfig=default_config(compact.ir))
+ function show_ir(io :: IO, compact :: IncrementalCompact, config :: IRShowConfig = default_config(compact.ir))
- function show_method(io::IO, m::Method; modulecolor = :light_black, digit_align_width = 1)
+ function show_method(io :: IO, m :: Method, modulecolor = :light_black, digit_align_width = 1)
- function show_method_candidates(io::IO, ex::MethodError, @nospecialize kwargs=())
+ function show_method_candidates(io :: IO, ex :: MethodError, kwargs = ())
- function show_method_list_header(io::IO, ms::MethodList, namefmt::Function)
+ function show_method_list_header(io :: IO, ms :: MethodList, namefmt :: Function)
- function show_method_params(io::IO, tv)
+ function show_method_params(io :: IO, tv)
- function show_method_table(io::IO, ms::MethodList, max::Int=-1, header::Bool=true)
+ function show_method_table(io :: IO, ms :: MethodList, max :: Int = -1, header :: Bool = true)
- function show_mi(io::IO, l::Core.MethodInstance, from_stackframe::Bool=false)
+ function show_mi(io :: IO, l :: Core.MethodInstance, from_stackframe :: Bool = false)
- function show_pairtyped(io::IO, p::Pair{K,V}) where {K,V}
+ function show_pairtyped(io :: IO, p :: Pair{K, V}) where K, V
- function show_reduced_backtrace(io::IO, t::Vector)
+ function show_reduced_backtrace(io :: IO, t :: Vector)
- function show_sexpr(io::IO, ex::Expr, indent::Int)
+ function show_sexpr(io :: IO, ex :: Expr, indent :: Int)
- function show_sexpr(io::IO, ex::QuoteNode, indent::Int)
+ function show_sexpr(io :: IO, ex :: QuoteNode, indent :: Int)
- function show_signature_function(io::IO, @nospecialize(ft), demangle=false, fargname="", html=false, qualified=false)
+ function show_signature_function(io :: IO, ft, demangle = false, fargname = "", html = false, qualified = false)
- function show_spec_linfo(io::IO, frame::StackFrame)
+ function show_spec_linfo(io :: IO, frame :: StackFrame)
- function show_spec_sig(io::IO, m::Method, @nospecialize(sig::Type))
+ function show_spec_sig(io :: IO, m :: Method, sig :: Type)
- function show_statstruct(io::IO, st::StatStruct, oneline::Bool)
+ function show_statstruct(io :: IO, st :: StatStruct, oneline :: Bool)
- function show_supertypes(io::IO, typ::DataType)
+ function show_supertypes(io :: IO, typ :: DataType)
- function show_sym(io::IO, sym::Symbol; allow_macroname=false)
+ function show_sym(io :: IO, sym :: Symbol, allow_macroname = false)
- function show_task_exception(io::IO, t::Task; indent = true)
+ function show_task_exception(io :: IO, t :: Task, indent = true)
- function show_type_name(io::IO, tn::Core.TypeName)
+ function show_type_name(io :: IO, tn :: Core.TypeName)
- function show_typealias(io::IO, @nospecialize(x::Type))
+ function show_typealias(io :: IO, x :: Type)
- function show_typealias(io::IO, name::GlobalRef, x::Type, env::SimpleVector, wheres::Vector)
+ function show_typealias(io :: IO, name :: GlobalRef, x :: Type, env :: SimpleVector, wheres :: Vector)
- function show_typeparams(io::IO, env::SimpleVector, orig::SimpleVector, wheres::Vector)
+ function show_typeparams(io :: IO, env :: SimpleVector, orig :: SimpleVector, wheres :: Vector)
- function show_unionaliases(io::IO, x::Union)
+ function show_unionaliases(io :: IO, x :: Union)
- function show_unquoted(io::IO, ex::Expr, indent::Int, prec::Int, quote_level::Int = 0)
+ function show_unquoted(io :: IO, ex :: Expr, indent :: Int, prec :: Int, quote_level :: Int = 0)
- function show_unquoted(io::IO, ex::QuoteNode, indent::Int, prec::Int)
+ function show_unquoted(io :: IO, ex :: QuoteNode, indent :: Int, prec :: Int)
- function show_unquoted(io::IO, ex::SlotNumber, ::Int, ::Int)
+ function show_unquoted(io :: IO, ex :: SlotNumber, ??? :: Int, ??? :: Int)
- function show_unquoted(io::IO, stmt::PhiCNode, indent::Int, ::Int)
+ function show_unquoted(io :: IO, stmt :: PhiCNode, indent :: Int, ??? :: Int)
- function show_unquoted(io::IO, stmt::PiNode, indent::Int, ::Int)
+ function show_unquoted(io :: IO, stmt :: PiNode, indent :: Int, ??? :: Int)
- function show_unquoted(io::IO, stmt::ReturnNode, indent::Int, ::Int)
+ function show_unquoted(io :: IO, stmt :: ReturnNode, indent :: Int, ??? :: Int)
- function show_unquoted(io::IO, stmt::UpsilonNode, indent::Int, ::Int)
+ function show_unquoted(io :: IO, stmt :: UpsilonNode, indent :: Int, ??? :: Int)
- function show_unquoted(io::IO, val::SSAValue, ::Int, ::Int)
+ function show_unquoted(io :: IO, val :: SSAValue, ??? :: Int, ??? :: Int)
- function show_unquoted(io::IO, z::Complex, ::Int, prec::Int)
+ function show_unquoted(io :: IO, z :: Complex, ??? :: Int, prec :: Int)
- function show_unquoted_expr_fallback(io::IO, ex::Expr, indent::Int, quote_level::Int)
+ function show_unquoted_expr_fallback(io :: IO, ex :: Expr, indent :: Int, quote_level :: Int)
- function show_unquoted_gotoifnot(io::IO, stmt::GotoIfNot, indent::Int, prefix::String)
+ function show_unquoted_gotoifnot(io :: IO, stmt :: GotoIfNot, indent :: Int, prefix :: String)
- function show_unquoted_phinode(io::IO, stmt::PhiNode, indent::Int, prefix::String)
+ function show_unquoted_phinode(io :: IO, stmt :: PhiNode, indent :: Int, prefix :: String)
- function show_unquoted_quote_expr(io::IO, @nospecialize(value), indent::Int, prec::Int, quote_level::Int)
+ function show_unquoted_quote_expr(io :: IO, value, indent :: Int, prec :: Int, quote_level :: Int)
- function show_vector(io::IO, v, opn='[', cls=']')
+ function show_vector(io :: IO, v, opn = '[', cls = ']')
- function show_wheres(io::IO, wheres::Vector{TypeVar})
+ function show_wheres(io :: IO, wheres :: Vector{TypeVar})
- function show_zero_dim(io::IO, X::AbstractArray{T, 0}) where T
+ function show_zero_dim(io :: IO, X :: AbstractArray{T, DependentType@7ba4f24f}) where T
- function showarg(io::IO, @nospecialize(x), toplevel)
+ function showarg(io :: IO, x, toplevel)
- function showarg(io::IO, T::Type, toplevel)
+ function showarg(io :: IO, T :: Type, toplevel)
- function showarg(io::IO, a::Array{Union{}}, toplevel)
+ function showarg(io :: IO, a :: Array{Union}, toplevel)
- function showarg(io::IO, r::NonReshapedReinterpretArray{T}, toplevel) where {T}
+ function showarg(io :: IO, r :: NonReshapedReinterpretArray{T}, toplevel) where T
- function showarg(io::IO, r::ReshapedArray, toplevel)
+ function showarg(io :: IO, r :: ReshapedArray, toplevel)
- function showarg(io::IO, r::ReshapedReinterpretArray{T}, toplevel) where {T}
+ function showarg(io :: IO, r :: ReshapedReinterpretArray{T}, toplevel) where T
- function showarg(io::IO, v::SubArray, toplevel)
+ function showarg(io :: IO, v :: SubArray, toplevel)
- function showerror(io::IO, ce::CapturedException)
+ function showerror(io :: IO, ce :: CapturedException)
- function showerror(io::IO, err::ProcessFailedException)
+ function showerror(io :: IO, err :: ProcessFailedException)
- function showerror(io::IO, ex, bt; backtrace=true)
+ function showerror(io :: IO, ex, bt, backtrace = true)
- function showerror(io::IO, ex::BoundsError)
+ function showerror(io :: IO, ex :: BoundsError)
- function showerror(io::IO, ex::CanonicalIndexError)
+ function showerror(io :: IO, ex :: CanonicalIndexError)
- function showerror(io::IO, ex::CompositeException)
+ function showerror(io :: IO, ex :: CompositeException)
- function showerror(io::IO, ex::DomainError)
+ function showerror(io :: IO, ex :: DomainError)
- function showerror(io::IO, ex::ErrorException)
+ function showerror(io :: IO, ex :: ErrorException)
- function showerror(io::IO, ex::InexactError)
+ function showerror(io :: IO, ex :: InexactError)
- function showerror(io::IO, ex::InitError, bt; backtrace=true)
+ function showerror(io :: IO, ex :: InitError, bt, backtrace = true)
- function showerror(io::IO, ex::LoadError, bt; backtrace=true)
+ function showerror(io :: IO, ex :: LoadError, bt, backtrace = true)
- function showerror(io::IO, ex::Meta.ParseError)
+ function showerror(io :: IO, ex :: Meta.ParseError)
- function showerror(io::IO, ex::MethodError)
+ function showerror(io :: IO, ex :: MethodError)
- function showerror(io::IO, ex::ScheduledAfterSyncException)
+ function showerror(io :: IO, ex :: ScheduledAfterSyncException)
- function showerror(io::IO, ex::SystemError)
+ function showerror(io :: IO, ex :: SystemError)
- function showerror(io::IO, ex::TaskFailedException, bt = nothing; backtrace=true)
+ function showerror(io :: IO, ex :: TaskFailedException, bt = nothing, backtrace = true)
- function showerror(io::IO, ex::TypeError)
+ function showerror(io :: IO, ex :: TypeError)
- function showerror(io::IO, ex::UndefVarError)
+ function showerror(io :: IO, ex :: UndefVarError)
- function showerror(io::IO, p::PaddingError)
+ function showerror(io :: IO, p :: PaddingError)
- function showerror_ambiguous(io::IO, meths, f, args)
+ function showerror_ambiguous(io :: IO, meths, f, args)
- function showerror_nostdio(err, msg::AbstractString)
+ function showerror_nostdio(err, msg :: AbstractString)
- function showrest(io::IO)
+ function showrest(io :: IO)
- function showvalue(io, e::Tuple{Exception,Any})
+ function showvalue(io, e :: Tuple{Exception, Any})
- function shred!(f::Function, x)
+ function shred!(f :: Function, x)
- function shred!(s::SecretBuffer)
+ function shred!(s :: SecretBuffer)
- function shuffle!(r::AbstractRNG, a::AbstractArray)
+ function shuffle!(r :: AbstractRNG, a :: AbstractArray)
- function sign(x::BigFloat)
+ function sign(x :: BigFloat)
- function sign(x::BigInt)
+ function sign(x :: BigInt)
- function signature!(tv::Vector{Any}, expr::Expr)
+ function signature!(tv :: Vector{Any}, expr :: Expr)
- function signature_type(@nospecialize(f), @nospecialize(argtypes))
+ function signature_type(f, argtypes)
- function significand(x::BigFloat)
+ function significand(x :: BigFloat)
- function significand(x::T) where T<:IEEEFloat
+ function significand(x :: T) where T <: IEEEFloat
- function simd_cartesian_range!(indices, crng)
+ function simd_cartesian_range!(indices, crng)
- function simd_iterate_elements(iter)
+ function simd_iterate_elements(iter)
- function simd_iterate_length(iter)
+ function simd_iterate_length(iter)
- function simd_loop_axpy!(a, X, Y)
+ function simd_loop_axpy!(a, X, Y)
- function simd_loop_example_from_manual(x, y, z)
+ function simd_loop_example_from_manual(x, y, z)
- function simd_loop_with_multiple_reductions(x, y, z)
+ function simd_loop_with_multiple_reductions(x, y, z)
- function simd_outer_range(iter::CartesianIndices)
+ function simd_outer_range(iter :: CartesianIndices)
- function simd_sum_over_array(a)
+ function simd_sum_over_array(a)
- function simd_sumloop(N)
+ function simd_sumloop(N)
- function simd_trip_count(iter)
+ function simd_trip_count(iter)
- function simdf(X)
+ function simdf(X)
- function simdf2(X)
+ function simdf2(X)
- function similar(A::Hermitian, ::Type{T}) where T
+ function similar(A :: Hermitian, ??? :: Type{T}) where T
- function simple()
+ function simple
- function simple(A, B)
+ function simple(A, B)
- function simple_dce!(callback::Function, compact::IncrementalCompact)
+ function simple_dce!(callback :: Function, compact :: IncrementalCompact)
- function simple_noinline(A, B)
+ function simple_noinline(A, B)
- function simulate_input(menu::TerminalMenus.AbstractMenu, keys...; kwargs...)
+ function simulate_input(menu :: TerminalMenus.AbstractMenu, keys..., kwargs...)
- function sin(A::AbstractMatrix{<:Complex})
+ function sin(A :: AbstractMatrix{??? <: Complex})
- function sin(A::AbstractMatrix{<:Real})
+ function sin(A :: AbstractMatrix{??? <: Real})
- function sin(x::T) where T<:Union{Float32, Float64}
+ function sin(x :: T) where T <: Union{Float32, Float64}
- function sin(z::Complex{T}) where T
+ function sin(z :: Complex{T}) where T
- function sincos(A::AbstractMatrix{<:Complex})
+ function sincos(A :: AbstractMatrix{??? <: Complex})
- function sincos(A::AbstractMatrix{<:Real})
+ function sincos(A :: AbstractMatrix{??? <: Real})
- function sincos(A::HermOrSym{<:Real})
+ function sincos(A :: HermOrSym{??? <: Real})
- function sincos(A::Hermitian{<:Complex})
+ function sincos(A :: Hermitian{??? <: Complex})
- function sincos(x::T) where T<:Union{Float32, Float64}
+ function sincos(x :: T) where T <: Union{Float32, Float64}
- function sincos_fast(v::BigFloat)
+ function sincos_fast(v :: BigFloat)
- function sincospi(_x::T) where T<:IEEEFloat
+ function sincospi(_x :: T) where T <: IEEEFloat
- function sincospi(z::Complex{T}) where T
+ function sincospi(z :: Complex{T}) where T
- function sind(x::Real)
+ function sind(x :: Real)
- function single_stride_dim(A::Array)
+ function single_stride_dim(A :: Array)
- function sinh(A::AbstractMatrix)
+ function sinh(A :: AbstractMatrix)
- function sinh(x::T) where T<:Union{Float32,Float64}
+ function sinh(x :: T) where T <: Union{Float32, Float64}
- function sinh(z::Complex)
+ function sinh(z :: Complex)
- function sinh_kernel(x::Float32)
+ function sinh_kernel(x :: Float32)
- function sinh_kernel(x::Float64)
+ function sinh_kernel(x :: Float64)
- function sinpi(_x::T) where T<:IEEEFloat
+ function sinpi(_x :: T) where T <: IEEEFloat
- function sinpi(z::Complex{T}) where T
+ function sinpi(z :: Complex{T}) where T
- function size(Q::AbstractQ, dim::Integer)
+ function size(Q :: AbstractQ, dim :: Integer)
- function size(a::Array, d::Int)
+ function size(a :: Array, d :: Int)
- function size(a::NonReshapedReinterpretArray{T,N,S} where {N}) where {T,S}
+ function size(a :: NonReshapedReinterpretArray{T, N, S} where N) where T, S
- function size(a::ReshapedReinterpretArray{T,N,S} where {N}) where {T,S}
+ function size(a :: ReshapedReinterpretArray{T, N, S} where N) where T, S
- function size(stack :: Stack)
+ function size(stack :: Stack)
- function sizehint!(B::BitVector, sz::Integer)
+ function sizehint!(B :: BitVector, sz :: Integer)
- function sizehint!(a::Vector, sz::Integer; shrink::Bool = true)
+ function sizehint!(a :: Vector, sz :: Integer, shrink :: Bool = true)
- function sizehint!(d::Dict{T}, newsz; shrink::Bool = true) where T
+ function sizehint!(d :: Dict{T}, newsz, shrink :: Bool = true) where T
- function sizehint!(d::IdDict, newsz)
+ function sizehint!(d :: IdDict, newsz)
- function sizeof_nothrow(@nospecialize(x))
+ function sizeof_nothrow(x)
- function sizeof_typeref(typeref)
+ function sizeof_typeref(typeref)
- function skip(f::File, n::Integer)
+ function skip(f :: File, n :: Integer)
- function skip(io::GenericIOBuffer, n::Integer)
+ function skip(io :: GenericIOBuffer, n :: Integer)
- function skip(s::IOStream, delta::Integer)
+ function skip(s :: IOStream, delta :: Integer)
- function skip_comment(l::Parser)::Bool
+ function skip_comment(l :: Parser)
- function skip_deleted(h::Dict, i)
+ function skip_deleted(h :: Dict, i)
- function skip_deleted_floor!(h::Dict)
+ function skip_deleted_floor!(h :: Dict)
- function skip_ws_nl(l::Parser)::Bool
+ function skip_ws_nl(l :: Parser)
- function skipblank(io::IO)
+ function skipblank(io :: IO)
- function skipchars(predicate, io::IO; linecomment=nothing)
+ function skipchars(predicate, io :: IO, linecomment = nothing)
- function skipwhitespace(io::IO; newlines = true)
+ function skipwhitespace(io :: IO, newlines = true)
- function sleep(sec::Real)
+ function sleep(sec :: Real)
- function slot2reg(ir::IRCode, ci::CodeInfo, sv::OptimizationState)
+ function slot2reg(ir :: IRCode, ci :: CodeInfo, sv :: OptimizationState)
- function slug(x::UInt32, p::Int)
+ function slug(x :: UInt32, p :: Int)
- function smerge(lattice::AbstractLattice, sa::Union{NotFound,VarState}, sb::Union{NotFound,VarState})
+ function smerge(lattice :: AbstractLattice, sa :: Union{NotFound, VarState}, sb :: Union{NotFound, VarState})
- function snapshot(repo::GitRepo)
+ function snapshot(repo :: GitRepo)
- function softscope(@nospecialize ex)
+ function softscope(ex)
- function somefunction_not_found()
+ function somefunction_not_found
- function somefunction_not_found_libc()
+ function somefunction_not_found_libc
- function sort!(v::AbstractVector, lo::Integer, hi::Integer, a::Algorithm, o::Ordering)
+ function sort!(v :: AbstractVector, lo :: Integer, hi :: Integer, a :: Algorithm, o :: Ordering)
- function sort!(v::AbstractVector, lo::Integer, hi::Integer, a::Algorithm, o::Ordering, scratch::Vector)
+ function sort!(v :: AbstractVector, lo :: Integer, hi :: Integer, a :: Algorithm, o :: Ordering, scratch :: Vector)
- function sort!(v::AbstractVector, lo::Integer, hi::Integer, a::QuickSortAlg, o::Ordering)
+ function sort!(v :: AbstractVector, lo :: Integer, hi :: Integer, a :: QuickSortAlg, o :: Ordering)
- function sort!(v::Vector; by::Function=identity, (<)::Function=<)
+ function sort!(v :: Vector, by :: Function = identity, (<) :: Function = <)
- function sort(v; kws...)
+ function sort(v, kws...)
- function sort_chunks!(Av, n, alg, order, scratch)
+ function sort_chunks!(Av, n, alg, order, scratch)
- function sort_chunks!(Av, n, alg, order, scratch::AbstractVector, fst, lst)
+ function sort_chunks!(Av, n, alg, order, scratch :: AbstractVector, fst, lst)
- function sort_chunks!(Av, n, alg, order, scratch::Nothing, fst, lst)
+ function sort_chunks!(Av, n, alg, order, scratch :: Nothing, fst, lst)
- function sortdefs(m1::Method, m2::Method)
+ function sortdefs(m1 :: Method, m2 :: Method)
- function sorteig!(λ::AbstractVector, X::AbstractMatrix, sortby::Union{Function,Nothing}=eigsortby)
+ function sorteig!(λ :: AbstractVector, X :: AbstractMatrix, sortby :: Union{Function, Nothing} = eigsortby)
- function sortperm_int_range(x::Vector{<:Integer}, rangelen, minval)
+ function sortperm_int_range(x :: Vector{??? <: Integer}, rangelen, minval)
- function sortslices(A::AbstractArray; dims::Union{Integer, Tuple{Vararg{Integer}}}, kws...)
+ function sortslices(A :: AbstractArray, dims :: Union{Integer, Tuple{Vararg{Integer}}}, kws...)
- function source_dir()
+ function source_dir
- function source_path(default::Union{AbstractString,Nothing}="")
+ function source_path(default :: Union{AbstractString, Nothing} = "")
- function sourceinfo_slotnames(slotnames::Vector{Symbol})
+ function sourceinfo_slotnames(slotnames :: Vector{Symbol})
- function sp_innersig(x::T) where {T}
+ function sp_innersig(x :: T) where T
- function sp_type_rewrap(@nospecialize(T), linfo::MethodInstance, isreturn::Bool)
+ function sp_type_rewrap(T, linfo :: MethodInstance, isreturn :: Bool)
- function spawnmany(n)
+ function spawnmany(n)
- function specialize_method(match::MethodMatch; kwargs...)
+ function specialize_method(match :: MethodMatch, kwargs...)
- function splace(in::String, p = 0.3)
+ function splace(in :: String, p = 0.3)
- function splat_lotta_unions()
+ function splat_lotta_unions
- function splice!(B::BitVector, i::Integer)
+ function splice!(B :: BitVector, i :: Integer)
- function splice!(B::BitVector, r::Union{AbstractUnitRange{Int}, Integer}, ins)
+ function splice!(B :: BitVector, r :: Union{AbstractUnitRange{Int}, Integer}, ins)
- function splice!(B::BitVector, r::Union{AbstractUnitRange{Int}, Integer}, ins::AbstractArray = _default_bit_splice)
+ function splice!(B :: BitVector, r :: Union{AbstractUnitRange{Int}, Integer}, ins :: AbstractArray = _default_bit_splice)
- function splice!(a::Vector, i::Integer, ins=_default_splice)
+ function splice!(a :: Vector, i :: Integer, ins = _default_splice)
- function splice!(a::Vector, r::AbstractUnitRange{<:Integer}, ins=_default_splice)
+ function splice!(a :: Vector, r :: AbstractUnitRange{??? <: Integer}, ins = _default_splice)
- function split(R::CartesianIndices, V::Val)
+ function split(R :: CartesianIndices, V :: Val)
- function split(maybe)
+ function split(maybe)
- function split_artifact_slash(name::String)
+ function split_artifact_slash(name :: String)
- function split_cfg_entry(ce::ConfigEntry)
+ function split_cfg_entry(ce :: ConfigEntry)
- function split_rest(itr, n::Int, state...)
+ function split_rest(itr, n :: Int, state...)
- function splitdir(path::String)
+ function splitdir(path :: String)
- function splitdrive(path::String)
+ function splitdrive(path :: String)
- function splitenv(e::String)
+ function splitenv(e :: String)
- function splitexpr(x::Expr)
+ function splitexpr(x :: Expr)
- function splitext(path::String)
+ function splitext(path :: String)
- function splitpath(p::String)
+ function splitpath(p :: String)
- function splitprec(::Type{F}, i::Integer) where {F<:AbstractFloat}
+ function splitprec(??? :: Type{F}, i :: Integer) where F <: AbstractFloat
- function sprint(f::Function, args...; context=nothing, sizehint::Integer=0)
+ function sprint(f :: Function, args..., context = nothing, sizehint :: Integer = 0)
- function sptypes_from_meth_instance(linfo::MethodInstance)
+ function sptypes_from_meth_instance(linfo :: MethodInstance)
- function sqrmod!(f::GF2X, m::GF2X)::GF2X
+ function sqrmod!(f :: GF2X, m :: GF2X)
- function sqrt(A::AbstractMatrix{T}) where {T<:Union{Real,Complex}}
+ function sqrt(A :: AbstractMatrix{T}) where T <: Union{Real, Complex}
- function sqrt(A::UnitUpperTriangular{T}) where T
+ function sqrt(A :: UnitUpperTriangular{T}) where T
- function sqrt(x::BigFloat)
+ function sqrt(x :: BigFloat)
- function sqrt(z::Complex)
+ function sqrt(z :: Complex)
- function sqrt_diag!(A0::UpperTriangular, A::UpperTriangular, s)
+ function sqrt_diag!(A0 :: UpperTriangular, A :: UpperTriangular, s)
- function sqrt_quasitriu(A0; blockwidth = eltype(A0) <: Complex ? 512 : 256)
+ function sqrt_quasitriu(A0, blockwidth = eltype(A0)<:Complex?512:256)
- function srand(seed::Integer=_make_uint64_seed())
+ function srand(seed :: Integer = _make_uint64_seed())
- function srctext_files(f::IO, srctextpos::Int64, includes::Vector{CacheHeaderIncludes})
+ function srctext_files(f :: IO, srctextpos :: Int64, includes :: Vector{CacheHeaderIncludes})
- function sroa_mutables!(ir::IRCode, defuses::IdDict{Int, Tuple{SPCSet, SSADefUse}}, used_ssas::Vector{Int}, lazydomtree::LazyDomtree, inlining::Union{Nothing, InliningState})
+ function sroa_mutables!(ir :: IRCode, defuses :: IdDict{Int, Tuple{SPCSet, SSADefUse}}, used_ssas :: Vector{Int}, lazydomtree :: LazyDomtree, inlining :: Union{Nothing, InliningState})
- function sroa_pass!(ir::IRCode, inlining::Union{Nothing,InliningState}=nothing)
+ function sroa_pass!(ir :: IRCode, inlining :: Union{Nothing, InliningState} = nothing)
- function sroaunswitchunionstruct1(c, x1, x2)
+ function sroaunswitchunionstruct1(c, x1, x2)
- function sroaunswitchunionstruct2(c, x1, x2)
+ function sroaunswitchunionstruct2(c, x1, x2)
- function sroaunswitchuniontuple(c, x1, x2)
+ function sroaunswitchuniontuple(c, x1, x2)
- function ssa_def_slot(@nospecialize(arg), sv::InferenceState)
+ function ssa_def_slot(arg, sv :: InferenceState)
- function ssa_inlining_pass!(ir::IRCode, state::InliningState, propagate_inbounds::Bool)
+ function ssa_inlining_pass!(ir :: IRCode, state :: InliningState, propagate_inbounds :: Bool)
- function ssamap(f, @nospecialize(stmt))
+ function ssamap(f, stmt)
- function ssqs(x::T, y::T) where T<:Real
+ function ssqs(x :: T, y :: T) where T <: Real
- function stage(ie::IndexEntry)
+ function stage(ie :: IndexEntry)
- function stale_pidfile(path::String, stale_age::Real, refresh::Real)
+ function stale_pidfile(path :: String, stale_age :: Real, refresh :: Real)
- function start(; sample_rate::Real)
+ function start(sample_rate :: Real)
- function start_loading(modkey::PkgId)
+ function start_loading(modkey :: PkgId)
- function start_reading(stream::LibuvStream)
+ function start_reading(stream :: LibuvStream)
- function start_repl_backend(backend::REPLBackend,  @nospecialize(consumer = x -> nothing); get_module::Function = ()->Main)
+ function start_repl_backend(backend :: REPLBackend, consumer = x->nothing, get_module :: Function = ()->Main)
- function start_timer()
+ function start_timer
- function start_watching(t::FileMonitor)
+ function start_watching(t :: FileMonitor)
- function start_watching(t::PollingFileWatcher)
+ function start_watching(t :: PollingFileWatcher)
- function start_watching(t::_FDWatcher)
+ function start_watching(t :: _FDWatcher)
- function start_worker_task!(worker_tasks, exec_func, chnl, batch_size=nothing)
+ function start_worker_task!(worker_tasks, exec_func, chnl, batch_size = nothing)
- function startswith(a::AbstractString, b::AbstractString)
+ function startswith(a :: AbstractString, b :: AbstractString)
- function startswith(s::AbstractString, r::Regex)
+ function startswith(s :: AbstractString, r :: Regex)
- function startswith(s::SubString{String}, r::Regex)
+ function startswith(s :: SubString{String}, r :: Regex)
- function startswith(stream::IO, c::AbstractChar; eat = true)
+ function startswith(stream :: IO, c :: AbstractChar, eat = true)
- function startswith(stream::IO, r::Regex; eat = true, padding = false)
+ function startswith(stream :: IO, r :: Regex, eat = true, padding = false)
- function startswith(stream::IO, s::AbstractString; eat = true, padding = false, newlines = true)
+ function startswith(stream :: IO, s :: AbstractString, eat = true, padding = false, newlines = true)
- function startswith(stream::IO, ss::Vector{<:AbstractString}; kws...)
+ function startswith(stream :: IO, ss :: Vector{??? <: AbstractString}, kws...)
- function startup(l::Parser)
+ function startup(l :: Parser)
- function statement_costs!(cost::Vector{Int}, body::Vector{Any}, src::Union{CodeInfo, IRCode}, sptypes::Vector{VarState}, params::OptimizationParams)
+ function statement_costs!(cost :: Vector{Int}, body :: Vector{Any}, src :: Union{CodeInfo, IRCode}, sptypes :: Vector{VarState}, params :: OptimizationParams)
- function statement_indices_to_labels(stmt, cfg::CFG)
+ function statement_indices_to_labels(stmt, cfg :: CFG)
- function statementidx_lineinfo_printer(f, code::CodeInfo)
+ function statementidx_lineinfo_printer(f, code :: CodeInfo)
- function statementidx_lineinfo_printer(f, code::IRCode)
+ function statementidx_lineinfo_printer(f, code :: IRCode)
- function static_shown(x)
+ function static_shown(x)
- function status(repo::GitRepo, path::String)
+ function status(repo :: GitRepo, path :: String)
- function step(acc, x)
+ function step(acc, x)
- function steprange_last(start, step, stop)::typeof(stop)
+ function steprange_last(start, step, stop)
- function steprange_last_empty(start::Integer, step, stop)::typeof(stop)
+ function steprange_last_empty(start :: Integer, step, stop)
- function stmt_effect_flags(Lₒ::AbstractLattice, @nospecialize(stmt), @nospecialize(rt), src::Union{IRCode,IncrementalCompact})
+ function stmt_effect_flags(Lₒ :: AbstractLattice, stmt, rt, src :: Union{IRCode, IncrementalCompact})
- function stmt_taints_inbounds_consistency(sv::AbsIntState)
+ function stmt_taints_inbounds_consistency(sv :: AbsIntState)
- function stmts_awaiting_insertion(compact::IncrementalCompact, idx::Int)
+ function stmts_awaiting_insertion(compact :: IncrementalCompact, idx :: Int)
- function stmts_used(::IO, code::CodeInfo)
+ function stmts_used(??? :: IO, code :: CodeInfo)
- function stmts_used(io::IO, code::IRCode, warn_unset_entry=true)
+ function stmts_used(io :: IO, code :: IRCode, warn_unset_entry = true)
- function stop()
+ function stop
- function stop_reading(stream::LibuvStream)
+ function stop_reading(stream :: LibuvStream)
- function stop_watching(t::FileMonitor)
+ function stop_watching(t :: FileMonitor)
- function stop_watching(t::PollingFileWatcher)
+ function stop_watching(t :: PollingFileWatcher)
- function store_backedges(caller::InferenceResult, edges::Vector{Any})
+ function store_backedges(caller :: InferenceResult, edges :: Vector{Any})
- function store_backedges(caller::MethodInstance, edges::Vector{Any})
+ function store_backedges(caller :: MethodInstance, edges :: Vector{Any})
- function stoverwrite!(state::VarTable, newstate::VarTable)
+ function stoverwrite!(state :: VarTable, newstate :: VarTable)
- function stoverwrite1!(state::VarTable, change::StateUpdate)
+ function stoverwrite1!(state :: VarTable, change :: StateUpdate)
- function strcat(x::String, y::String)
+ function strcat(x :: String, y :: String)
- function strftime(fmt::AbstractString, tm::TmStruct)
+ function strftime(fmt :: AbstractString, tm :: TmStruct)
- function stride(A::AbstractArray, k::Integer)
+ function stride(A :: AbstractArray, k :: Integer)
- function strides(a::ReinterpretArray{T,<:Any,S,<:AbstractArray{S},IsReshaped}) where {T,S,IsReshaped}
+ function strides(a :: ReinterpretArray{T, ??? <: Any, S, ??? <: AbstractArray{S}, IsReshaped}) where T, S, IsReshaped
- function strides(a::ReshapedArray)
+ function strides(a :: ReshapedArray)
- function string(n::BigInt; base::Integer = 10, pad::Integer = 1)
+ function string(n :: BigInt, base :: Integer = 10, pad :: Integer = 1)
- function string(n::Integer; base::Integer = 10, pad::Integer = 1)
+ function string(n :: Integer, base :: Integer = 10, pad :: Integer = 1)
- function string(u::UUID)
+ function string(u :: UUID)
- function string_concatenation_hint_handler(io, ex, arg_types, kwargs)
+ function string_concatenation_hint_handler(io, ex, arg_types, kwargs)
- function string_distance(a::AbstractString, lena::Integer, b::AbstractString, lenb::Integer)
+ function string_distance(a :: AbstractString, lena :: Integer, b :: AbstractString, lenb :: Integer)
- function string_mpfr(x::BigFloat, fmt::String)
+ function string_mpfr(x :: BigFloat, fmt :: String)
- function string_with_env(env, xs...)
+ function string_with_env(env, xs...)
- function strip_gensym(sym)
+ function strip_gensym(sym)
- function strip_meta(data)
+ function strip_meta(data)
- function strip_trailing_junk!(ci::CodeInfo, cfg::CFG, code::Vector{Any}, info::Vector{CallInfo})
+ function strip_trailing_junk!(ci :: CodeInfo, cfg :: CFG, code :: Vector{Any}, info :: Vector{CallInfo})
- function striptrimdocs(expr)
+ function striptrimdocs(expr)
- function strptime(fmt::AbstractString, timestr::AbstractString)
+ function strptime(fmt :: AbstractString, timestr :: AbstractString)
- function structdiff(a::NamedTuple{an}, b::Union{NamedTuple{bn}, Type{NamedTuple{bn}}}) where {an, bn}
+ function structdiff(a :: NamedTuple{an}, b :: Union{NamedTuple{bn}, Type{NamedTuple{bn}}}) where an, bn
- function structured_broadcast_alloc(bc, ::Type{Bidiagonal}, ::Type{ElType}, n) where {ElType}
+ function structured_broadcast_alloc(bc, ??? :: Type{Bidiagonal}, ??? :: Type{ElType}, n) where ElType
- function stupdate!(lattice::AbstractLattice, state::VarTable, changes::StateUpdate)
+ function stupdate!(lattice :: AbstractLattice, state :: VarTable, changes :: StateUpdate)
- function stupdate!(lattice::AbstractLattice, state::VarTable, changes::VarTable)
+ function stupdate!(lattice :: AbstractLattice, state :: VarTable, changes :: VarTable)
- function sub!(z::Rational{BigInt}, x::Rational{BigInt}, y::Rational{BigInt})
+ function sub!(z :: Rational{BigInt}, x :: Rational{BigInt}, y :: Rational{BigInt})
- function sub2ind_gen(dims::NTuple{N,Int}, I::Integer...) where N
+ function sub2ind_gen(dims :: NTuple{N, Int}, I :: Integer...) where N
- function sub2ind_gen_fallback(dims::NTuple{N,Int}, I) where N
+ function sub2ind_gen_fallback(dims :: NTuple{N, Int}, I) where N
- function sub2ind_gen_impl(dims::Type{NTuple{N,Int}}, I...) where N
+ function sub2ind_gen_impl(dims :: Type{NTuple{N, Int}}, I...) where N
- function sub_flag(newinst::NewInstruction, newflag::UInt32)
+ function sub_flag(newinst :: NewInstruction, newflag :: UInt32)
- function sub_with_overflow(x::T, y::T) where T<:BrokenSignedInt
+ function sub_with_overflow(x :: T, y :: T) where T <: BrokenSignedInt
- function sub_with_overflow(x::T, y::T) where T<:BrokenUnsignedInt
+ function sub_with_overflow(x :: T, y :: T) where T <: BrokenUnsignedInt
- function subst_trivial_bounds(@nospecialize(atype))
+ function subst_trivial_bounds(atype)
- function substring_copy_bynumber(match_data, number, buf, buf_size)
+ function substring_copy_bynumber(match_data, number, buf, buf_size)
- function substring_length_bynumber(match_data, number)
+ function substring_length_bynumber(match_data, number)
- function substring_number_from_name(re, name)
+ function substring_number_from_name(re, name)
- function subtract_singletontype(::Type{T}, x::Pair{K}) where {T, K}
+ function subtract_singletontype(??? :: Type{T}, x :: Pair{K}) where T, K
- function success(x::Process)
+ function success(x :: Process)
- function sum(arr::AbstractArray{BigFloat})
+ function sum(arr :: AbstractArray{BigFloat})
- function sum(r::AbstractRange{<:Real})
+ function sum(r :: AbstractRange{??? <: Real})
- function sum(r::StepRangeLen)
+ function sum(r :: StepRangeLen)
- function sum(r::StepRangeLen{<:Any,<:TwicePrecision,<:TwicePrecision})
+ function sum(r :: StepRangeLen{??? <: Any, ??? <: TwicePrecision, ??? <: TwicePrecision})
- function sum27403(X::AbstractArray)
+ function sum27403(X :: AbstractArray)
- function sumloop(N)
+ function sumloop(N)
- function summarize(binding::Binding, sig)
+ function summarize(binding :: Binding, sig)
- function summarize(io::IO, @nospecialize(T), binding::Binding)
+ function summarize(io :: IO, T, binding :: Binding)
- function summarize(io::IO, TT::Type, binding::Binding)
+ function summarize(io :: IO, TT :: Type, binding :: Binding)
- function summarize(io::IO, m::Module, binding::Binding; nlines::Int = 200)
+ function summarize(io :: IO, m :: Module, binding :: Binding, nlines :: Int = 200)
- function summarize(io::IO, λ::Function, binding::Binding)
+ function summarize(io :: IO, λ :: Function, binding :: Binding)
- function summary(io::IO, iter::T) where {T<:Union{KeySet,ValueIterator}}
+ function summary(io :: IO, iter :: T) where T <: Union{KeySet, ValueIterator}
- function summary(io::IO, s::AbstractString)
+ function summary(io :: IO, s :: AbstractString)
- function summary(io::IO, t::AbstractDict)
+ function summary(io :: IO, t :: AbstractDict)
- function summary(io::IO, t::AbstractSet)
+ function summary(io :: IO, t :: AbstractSet)
- function summary(x)
+ function summary(x)
- function sumrecur(a, x)
+ function sumrecur(a, x)
- function supertypes(T::Type)
+ function supertypes(T :: Type)
- function svd!(A::StridedMatrix{T}, B::StridedMatrix{T}) where T<:BlasFloat
+ function svd!(A :: StridedMatrix{T}, B :: StridedMatrix{T}) where T <: BlasFloat
- function svd!(A::StridedMatrix{T}; full::Bool = false, alg::Algorithm = default_svd_alg(A)) where {T<:BlasFloat}
+ function svd!(A :: StridedMatrix{T}, full :: Bool = false, alg :: Algorithm = default_svd_alg(A)) where T <: BlasFloat
- function svd!(A::StridedVector{T}; full::Bool = false, alg::Algorithm = default_svd_alg(A)) where {T<:BlasFloat}
+ function svd!(A :: StridedVector{T}, full :: Bool = false, alg :: Algorithm = default_svd_alg(A)) where T <: BlasFloat
- function svd!(M::Bidiagonal{<:BlasReal}; full::Bool = false)
+ function svd!(M :: Bidiagonal{??? <: BlasReal}, full :: Bool = false)
- function svd(A::AbstractMatrix{TA}, B::AbstractMatrix{TB}) where {TA,TB}
+ function svd(A :: AbstractMatrix{TA}, B :: AbstractMatrix{TB}) where TA, TB
- function svd(A::AbstractVecOrMat{T}; full::Bool = false, alg::Algorithm = default_svd_alg(A)) where {T <: Union{Float16,Complex{Float16}}}
+ function svd(A :: AbstractVecOrMat{T}, full :: Bool = false, alg :: Algorithm = default_svd_alg(A)) where T <: Union{Float16, Complex{Float16}}
- function svd(A::AbstractVecOrMat{T}; full::Bool = false, alg::Algorithm = default_svd_alg(A)) where {T}
+ function svd(A :: AbstractVecOrMat{T}, full :: Bool = false, alg :: Algorithm = default_svd_alg(A)) where T
- function svd(A::Adjoint; full::Bool = false, alg::Algorithm = default_svd_alg(A))
+ function svd(A :: Adjoint, full :: Bool = false, alg :: Algorithm = default_svd_alg(A))
- function svd(A::RealHermSymComplexHerm; full::Bool=false)
+ function svd(A :: RealHermSymComplexHerm, full :: Bool = false)
- function svd(A::Transpose; full::Bool = false, alg::Algorithm = default_svd_alg(A))
+ function svd(A :: Transpose, full :: Bool = false, alg :: Algorithm = default_svd_alg(A))
- function svd(D::Diagonal{T}) where {T<:Number}
+ function svd(D :: Diagonal{T}) where T <: Number
- function svd(M::Bidiagonal; kw...)
+ function svd(M :: Bidiagonal, kw...)
- function svd(x::Integer; full::Bool = false, alg::Algorithm = default_svd_alg(x))
+ function svd(x :: Integer, full :: Bool = false, alg :: Algorithm = default_svd_alg(x))
- function svd(x::Number; full::Bool = false, alg::Algorithm = default_svd_alg(x))
+ function svd(x :: Number, full :: Bool = false, alg :: Algorithm = default_svd_alg(x))
- function svdvals!(A::RealHermSymComplexHerm)
+ function svdvals!(A :: RealHermSymComplexHerm)
- function svdvals!(A::StridedMatrix{T}, B::StridedMatrix{T}) where T<:BlasFloat
+ function svdvals!(A :: StridedMatrix{T}, B :: StridedMatrix{T}) where T <: BlasFloat
- function svdvals!(A::SymTridiagonal)
+ function svdvals!(A :: SymTridiagonal)
- function svdvals(A::AbstractMatrix{TA}, B::AbstractMatrix{TB}) where {TA,TB}
+ function svdvals(A :: AbstractMatrix{TA}, B :: AbstractMatrix{TB}) where TA, TB
- function swapcols!(a::AbstractMatrix, i, j)
+ function swapcols!(a :: AbstractMatrix, i, j)
- function swapproperty!(x, f::Symbol, v, order::Symbol=:not_atomic)
+ function swapproperty!(x, f :: Symbol, v, order :: Symbol = :not_atomic)
- function swaprows!(a::AbstractMatrix, i, j)
+ function swaprows!(a :: AbstractMatrix, i, j)
- function switchtupleunion(@nospecialize(ty))
+ function switchtupleunion(ty)
- function sylvester(A::AbstractMatrix, B::AbstractMatrix, C::AbstractMatrix)
+ function sylvester(A :: AbstractMatrix, B :: AbstractMatrix, C :: AbstractMatrix)
- function sylvester(A::AbstractMatrix{T}, B::AbstractMatrix{T}, C::AbstractMatrix{T}) where {T<:BlasFloat}
+ function sylvester(A :: AbstractMatrix{T}, B :: AbstractMatrix{T}, C :: AbstractMatrix{T}) where T <: BlasFloat
- function sym_in(x::Symbol, itr::Tuple{Vararg{Symbol}})
+ function sym_in(x :: Symbol, itr :: Tuple{Vararg{Symbol}})
- function sym_to_string(sym)
+ function sym_to_string(sym)
- function sym_uplo(uplo::Char)
+ function sym_uplo(uplo :: Char)
- function symbol_latex(s::String)
+ function symbol_latex(s :: String)
- function symcmp36230(vec)
+ function symcmp36230(vec)
- function symcounts()
+ function symcounts
- function symdiff!(s::AbstractSet, itr::AbstractSet)
+ function symdiff!(s :: AbstractSet, itr :: AbstractSet)
- function symdiff!(s::AbstractSet, itrs...)
+ function symdiff!(s :: AbstractSet, itrs...)
- function symdiff!(s::BitSet, ns)
+ function symdiff!(s :: BitSet, ns)
- function symdiff!(s::BitSet, ns::AbstractSet)
+ function symdiff!(s :: BitSet, ns :: AbstractSet)
- function symmetric_type(::Type{T}) where {S, T<:AbstractMatrix{S}}
+ function symmetric_type(??? :: Type{T}) where S, T <: AbstractMatrix{S}
- function symmetric_type(::Type{T}) where {S<:AbstractMatrix, T<:AbstractMatrix{S}}
+ function symmetric_type(??? :: Type{T}) where S <: AbstractMatrix, T <: AbstractMatrix{S}
- function symmetric_type(::Type{T}) where {S<:Number, T<:AbstractMatrix{S}}
+ function symmetric_type(??? :: Type{T}) where S <: Number, T <: AbstractMatrix{S}
- function sympow(A::Symmetric, p::Integer)
+ function sympow(A :: Symmetric, p :: Integer)
- function sync!(m::Array, flags::Integer=MS_SYNC)
+ function sync!(m :: Array, flags :: Integer = MS_SYNC)
- function sync_end(c::Channel{Any})
+ function sync_end(c :: Channel{Any})
- function sync_end_race()
+ function sync_end_race
- function sync_rational!(xq::_MPQ)
+ function sync_rational!(xq :: _MPQ)
- function syr2k(uplo::AbstractChar, trans::AbstractChar, alpha::Number, A::AbstractVecOrMat, B::AbstractVecOrMat)
+ function syr2k(uplo :: AbstractChar, trans :: AbstractChar, alpha :: Number, A :: AbstractVecOrMat, B :: AbstractVecOrMat)
- function syrk(uplo::AbstractChar, trans::AbstractChar, alpha::Number, A::AbstractVecOrMat)
+ function syrk(uplo :: AbstractChar, trans :: AbstractChar, alpha :: Number, A :: AbstractVecOrMat)
- function sys_arch_category()
+ function sys_arch_category
- function systemsleep(s::Real)
+ function systemsleep(s :: Real)
- function t0_15600(flag)
+ function t0_15600(flag)
- function t1_15600(flag)
+ function t1_15600(flag)
- function tab_should_complete(s::MIState)
+ function tab_should_complete(s :: MIState)
- function tag_delete(repo::GitRepo, tag::AbstractString)
+ function tag_delete(repo :: GitRepo, tag :: AbstractString)
- function tag_list(repo::GitRepo)
+ function tag_list(repo :: GitRepo)
- function tail_is_nonzero(x::RawBigInt, len::Int, ::Val{:bits})
+ function tail_is_nonzero(x :: RawBigInt, len :: Int, ??? :: Val{:, bits})
- function tail_is_nonzero(x::RawBigInt, len::Int, ::Val{:words})
+ function tail_is_nonzero(x :: RawBigInt, len :: Int, ??? :: Val{:, words})
- function tail_is_nonzero(x::RawBigInt, len::Int, i::Int, ::Val{:word})
+ function tail_is_nonzero(x :: RawBigInt, len :: Int, i :: Int, ??? :: Val{:, word})
- function tailjoin(A::SimpleVector, i::Int)
+ function tailjoin(A :: SimpleVector, i :: Int)
- function take!(io::GenericIOBuffer)
+ function take!(io :: GenericIOBuffer)
- function take!(io::IOBuffer)
+ function take!(io :: IOBuffer)
- function take_buffered(c::Channel)
+ function take_buffered(c :: Channel)
- function take_chunks(l::Parser, unescape::Bool)::String
+ function take_chunks(l :: Parser, unescape :: Bool)
- function take_heap_snapshot(all_one::Bool=false; dir::Union{Nothing,S}=nothing) where {S <: AbstractString}
+ function take_heap_snapshot(all_one :: Bool = false, dir :: Union{Nothing, S} = nothing) where S <: AbstractString
- function take_heap_snapshot(filepath::String, all_one::Bool=false)
+ function take_heap_snapshot(filepath :: String, all_one :: Bool = false)
- function take_heap_snapshot(io::IOStream, all_one::Bool=false)
+ function take_heap_snapshot(io :: IOStream, all_one :: Bool = false)
- function take_string_or_substring(l, contains_underscore)::SubString
+ function take_string_or_substring(l, contains_underscore)
- function take_unbuffered(c::Channel{T}) where T
+ function take_unbuffered(c :: Channel{T}) where T
- function tan(A::AbstractMatrix)
+ function tan(A :: AbstractMatrix)
- function tan(x::T) where T<:Union{Float32, Float64}
+ function tan(x :: T) where T <: Union{Float32, Float64}
- function tan(z::Complex)
+ function tan(z :: Complex)
- function tanh(A::AbstractMatrix)
+ function tanh(A :: AbstractMatrix)
- function tanh(x::T) where T<:Union{Float32, Float64}
+ function tanh(x :: T) where T <: Union{Float32, Float64}
- function tanh(z::Complex{T}) where T
+ function tanh(z :: Complex{T}) where T
- function tanpi(_x::T) where T<:IEEEFloat
+ function tanpi(_x :: T) where T <: IEEEFloat
- function target!(ref::GitReference, new_oid::GitHash; msg::AbstractString="")
+ function target!(ref :: GitReference, new_oid :: GitHash, msg :: AbstractString = "")
- function target(tag::GitTag)
+ function target(tag :: GitTag)
- function task_done_hook(t::Task)
+ function task_done_hook(t :: Task)
- function task_local_storage(body::Function, key, val)
+ function task_local_storage(body :: Function, key, val)
- function tcgetattr(fd::RawFD, termios)
+ function tcgetattr(fd :: RawFD, termios)
- function tcsetattr(fd::RawFD, termios, mode::TCSETATTR_FLAGS = TCSADRAIN)
+ function tcsetattr(fd :: RawFD, termios, mode :: TCSETATTR_FLAGS = TCSADRAIN)
- function tdiv_qr!(x::BigInt, y::BigInt, a::BigInt, b::BigInt)
+ function tdiv_qr!(x :: BigInt, y :: BigInt, a :: BigInt, b :: BigInt)
- function temp_cleanup_later(path::AbstractString; asap::Bool=false)
+ function temp_cleanup_later(path :: AbstractString, asap :: Bool = false)
- function temp_cleanup_purge(; force::Bool=false)
+ function temp_cleanup_purge(force :: Bool = false)
- function tempdir()
+ function tempdir
- function tempname(parent::AbstractString=tempdir(); max_tries::Int = 100, cleanup::Bool=true)
+ function tempname(parent :: AbstractString = tempdir(), max_tries :: Int = 100, cleanup :: Bool = true)
- function term(io::IO, br::HorizontalRule, columns)
+ function term(io :: IO, br :: HorizontalRule, columns)
- function term(io::IO, content::Vector, cols)
+ function term(io :: IO, content :: Vector, cols)
- function term(io::IO, f::Footnote, columns)
+ function term(io :: IO, f :: Footnote, columns)
- function term(io::IO, md::Admonition, columns)
+ function term(io :: IO, md :: Admonition, columns)
- function term(io::IO, md::BlockQuote, columns)
+ function term(io :: IO, md :: BlockQuote, columns)
- function term(io::IO, md::Code, columns)
+ function term(io :: IO, md :: Code, columns)
- function term(io::IO, md::Header{l}, columns) where l
+ function term(io :: IO, md :: Header{l}, columns) where l
- function term(io::IO, md::List, columns)
+ function term(io :: IO, md :: List, columns)
- function term(io::IO, md::Paragraph, columns)
+ function term(io :: IO, md :: Paragraph, columns)
- function term(io::IO, md::Table, columns)
+ function term(io :: IO, md :: Table, columns)
- function term(io::IO, tex::LaTeX, columns)
+ function term(io :: IO, tex :: LaTeX, columns)
- function terminline(io::IO, code::Code)
+ function terminline(io :: IO, code :: Code)
- function terminline(io::IO, content::Vector)
+ function terminline(io :: IO, content :: Vector)
- function terminline(io::IO, md::AbstractString)
+ function terminline(io :: IO, md :: AbstractString)
- function terminline(io::IO, md::Bold)
+ function terminline(io :: IO, md :: Bold)
- function terminline(io::IO, md::Image)
+ function terminline(io :: IO, md :: Image)
- function terminline(io::IO, md::Italic)
+ function terminline(io :: IO, md :: Italic)
- function terminline(io::IO, md::LineBreak)
+ function terminline(io :: IO, md :: LineBreak)
- function terminline(io::IO, md::Link)
+ function terminline(io :: IO, md :: Link)
- function terminline(io::IO, tex::LaTeX)
+ function terminline(io :: IO, tex :: LaTeX)
- function termlength(str)
+ function termlength(str)
- function test()
+ function test
- function test(N)
+ function test(N)
- function test(x)
+ function test(x)
- function test(x, a)
+ function test(x, a)
- function test1(xs)
+ function test1(xs)
- function test12806()
+ function test12806
- function test18399(C)
+ function test18399(C)
- function test19864()
+ function test19864
- function test2(xs)
+ function test2(xs)
- function test27566(a,b)
+ function test27566(a, b)
- function test27710()
+ function test27710
- function test2_12992()
+ function test2_12992
- function test39508()
+ function test39508
- function test4974(;kwargs...)
+ function test4974(kwargs...)
- function test5884()
+ function test5884
- function test5924()
+ function test5924
- function test6068()
+ function test6068
- function test7302()
+ function test7302
- function test7307(a, ret)
+ function test7307(a, ret)
- function test8277(a)
+ function test8277(a)
- function testModPi()
+ function testModPi
- function test_1()
+ function test_1
- function test_12992()
+ function test_12992
- function test_13315(::Type{TestAbstractArray})
+ function test_13315(??? :: Type{TestAbstractArray})
- function test_13559()
+ function test_13559
- function test_15703()
+ function test_15703
- function test_2()
+ function test_2
- function test_22566()
+ function test_22566
- function test_26037()
+ function test_26037
- function test_29253(K)
+ function test_29253(K)
- function test_3()
+ function test_3
- function test_4()
+ function test_4
- function test_40164()
+ function test_40164
- function test_5()
+ function test_5
- function test_6()
+ function test_6
- function test_7()
+ function test_7
- function test_LibcFILE(FILEp)
+ function test_LibcFILE(FILEp)
- function test_Type()
+ function test_Type
- function test_UInt_indexing(::Type{TestAbstractArray})
+ function test_UInt_indexing(??? :: Type{TestAbstractArray})
- function test_abstract_diagonal_dispatch(xs)
+ function test_abstract_diagonal_dispatch(xs)
- function test_allocs()
+ function test_allocs
- function test_approx_eq_vecs(a::StridedVecOrMat{S}, b::StridedVecOrMat{T}, error=nothing) where {S<:Real,T<:Real}
+ function test_approx_eq_vecs(a :: StridedVecOrMat{S}, b :: StridedVecOrMat{T}, error = nothing) where S <: Real, T <: Real
- function test_ast_reflection(freflect, f, types)
+ function test_ast_reflection(freflect, f, types)
- function test_atomic()
+ function test_atomic
- function test_atomic_bools()
+ function test_atomic_bools
- function test_atomic_cas!(var::Atomic{T}, range::StepRange{Int,Int}) where T
+ function test_atomic_cas!(var :: Atomic{T}, range :: StepRange{Int, Int}) where T
- function test_atomic_float(varadd::Atomic{T}, varmax::Atomic{T}, varmin::Atomic{T}, i::Int) where T
+ function test_atomic_float(varadd :: Atomic{T}, varmax :: Atomic{T}, varmin :: Atomic{T}, i :: Int) where T
- function test_atomic_read(commbuf::CommBuf, n::Int)
+ function test_atomic_read(commbuf :: CommBuf, n :: Int)
- function test_atomic_write(commbuf::CommBuf, n::Int)
+ function test_atomic_write(commbuf :: CommBuf, n :: Int)
- function test_atomic_xchg!(var::Atomic{T}, i::Int, accum::Atomic{Int}) where T
+ function test_atomic_xchg!(var :: Atomic{T}, i :: Int, accum :: Atomic{Int}) where T
- function test_bidirectional(exp)
+ function test_bidirectional(exp)
- function test_bin_reflection(freflect, f, types)
+ function test_bin_reflection(freflect, f, types)
- function test_bits_tuples()
+ function test_bits_tuples
- function test_bounds(@nospecialize(A))
+ function test_bounds(A)
- function test_callsite(bt, file_ts, file_t)
+ function test_callsite(bt, file_ts, file_t)
- function test_cartesian(@nospecialize(A), @nospecialize(B))
+ function test_cartesian(A, B)
- function test_cat(::Type{TestAbstractArray})
+ function test_cat(??? :: Type{TestAbstractArray})
- function test_checksquare()
+ function test_checksquare
- function test_code_reflection(freflect, f, types, tester)
+ function test_code_reflection(freflect, f, types, tester)
- function test_code_reflections(tester, freflect)
+ function test_code_reflections(tester, freflect)
- function test_connect_disconnect(exp)
+ function test_connect_disconnect(exp)
- function test_const_return(@nospecialize(f), @nospecialize(t), @nospecialize(val))
+ function test_const_return(f, t, val)
- function test_copy_alias(::Type{T}) where T
+ function test_copy_alias(??? :: Type{T}) where T
- function test_crc32c(crc32c)
+ function test_crc32c(crc32c)
- function test_diagonal()
+ function test_diagonal
- function test_dict_completion(dict_name)
+ function test_dict_completion(dict_name)
- function test_dirmonitor_wait(tval)
+ function test_dirmonitor_wait(tval)
- function test_dirmonitor_wait2(tval)
+ function test_dirmonitor_wait2(tval)
- function test_div_pinv_consistency(a, b)
+ function test_div_pinv_consistency(a, b)
- function test_equivalence(n::Int)
+ function test_equivalence(n :: Int)
- function test_exc_stack_catch_return()
+ function test_exc_stack_catch_return
- function test_exc_stack_deep(n)
+ function test_exc_stack_deep(n)
- function test_exc_stack_tailpos()
+ function test_exc_stack_tailpos
- function test_exceptions(mod, visited=Set{Module}())
+ function test_exceptions(mod, visited = Set{Module}())
- function test_exit_bottom(s)
+ function test_exit_bottom(s)
- function test_expr!(m, ex, kws...)
+ function test_expr!(m, ex, kws...)
- function test_feature(features::Vector{UInt8}, feat::FeatureName)
+ function test_feature(features :: Vector{UInt8}, feat :: FeatureName)
- function test_fence()
+ function test_fence
- function test_fence(p::Peterson, id::Int, n::Int)
+ function test_fence(p :: Peterson, id :: Int, n :: Int)
- function test_field_operators(r)
+ function test_field_operators(r)
- function test_field_orderings(r, x, y)
+ function test_field_orderings(r, x, y)
- function test_field_undef(TT)
+ function test_field_undef(TT)
- function test_file_poll(channel, interval, timeout_s)
+ function test_file_poll(channel, interval, timeout_s)
- function test_get(::Type{TestAbstractArray})
+ function test_get(??? :: Type{TestAbstractArray})
- function test_getindex_internals(::Type{TestAbstractArray})
+ function test_getindex_internals(??? :: Type{TestAbstractArray})
- function test_getindex_internals(::Type{T}, shape, ::Type{TestAbstractArray}) where T
+ function test_getindex_internals(??? :: Type{T}, shape, ??? :: Type{TestAbstractArray}) where T
- function test_harness(@nospecialize(fn))
+ function test_harness(fn)
- function test_hash_equality(x, y)
+ function test_hash_equality(x, y)
- function test_in_bounds(::Type{TestAbstractArray})
+ function test_in_bounds(??? :: Type{TestAbstractArray})
- function test_ind2sub(::Type{TestAbstractArray})
+ function test_ind2sub(??? :: Type{TestAbstractArray})
- function test_inferred_static(arrow::Pair, all_ssa)
+ function test_inferred_static(arrow :: Pair, all_ssa)
- function test_inferred_static(expr::Expr)
+ function test_inferred_static(expr :: Expr)
- function test_init_afile()
+ function test_init_afile
- function test_inlined_symbols(func, argtypes)
+ function test_inlined_symbols(func, argtypes)
- function test_intersection()
+ function test_intersection
- function test_intersection_properties()
+ function test_intersection_properties
- function test_ir_reflection(freflect, f, types)
+ function test_ir_reflection(freflect, f, types)
- function test_jl_dump_compiles()
+ function test_jl_dump_compiles
- function test_jl_dump_compiles_toplevel_thunks()
+ function test_jl_dump_compiles_toplevel_thunks
- function test_jl_dump_llvm_opt()
+ function test_jl_dump_llvm_opt
- function test_large_string20360(slot)
+ function test_large_string20360(slot)
- function test_ldiv_pinv_consistency(a, b)
+ function test_ldiv_pinv_consistency(a, b)
- function test_limit_aggressive_inference_getprop()
+ function test_limit_aggressive_inference_getprop
- function test_linear(@nospecialize(A), @nospecialize(B))
+ function test_linear(A, B)
- function test_list_wrap(str, lenmin, lenmax)
+ function test_list_wrap(str, lenmin, lenmax)
- function test_load_and_lookup_18020(n)
+ function test_load_and_lookup_18020(n)
- function test_loads_no_call(ir, load_types)
+ function test_loads_no_call(ir, load_types)
- function test_location(bt, file_ts, file_t)
+ function test_location(bt, file_ts, file_t)
- function test_metadata_matches(@nospecialize(f), @nospecialize(tt))
+ function test_metadata_matches(f, tt)
- function test_monitor_wait(tval)
+ function test_monitor_wait(tval)
- function test_monitor_wait_poll()
+ function test_monitor_wait_poll
- function test_mt(f, str)
+ function test_mt(f, str)
- function test_mul(C, A, B)
+ function test_mul(C, A, B)
- function test_nested_loops()
+ function test_nested_loops
- function test_no_apply(expr::Expr)
+ function test_no_apply(expr :: Expr)
- function test_no_apply(ref::GlobalRef)
+ function test_no_apply(ref :: GlobalRef)
- function test_old()
+ function test_old
- function test_one_oneunit_triangular(a)
+ function test_one_oneunit_triangular(a)
- function test_outer(a)
+ function test_outer(a)
- function test_overlong(c::Char, n::Integer, rep::String)
+ function test_overlong(c :: Char, n :: Integer, rep :: String)
- function test_path(test)
+ function test_path(test)
- function test_pinv(a,tol1,tol2)
+ function test_pinv(a, tol1, tol2)
- function test_primitives(::Type{T}, shape, ::Type{TestAbstractArray}) where T
+ function test_primitives(??? :: Type{T}, shape, ??? :: Type{TestAbstractArray}) where T
- function test_properties()
+ function test_properties
- function test_properties(value)
+ function test_properties(value)
- function test_properties2(value)
+ function test_properties2(value)
- function test_range_identity(r::AbstractRange{T}, mr) where T
+ function test_range_identity(r :: AbstractRange{T}, mr) where T
- function test_range_index(r, s)
+ function test_range_index(r, s)
- function test_range_sum_diff(r1, r2, r_sum, r_diff)
+ function test_range_sum_diff(r1, r2, r_sum, r_diff)
- function test_rdiv_pinv_consistency(a, b)
+ function test_rdiv_pinv_consistency(a, b)
- function test_read_nbyte()
+ function test_read_nbyte
- function test_repr(x::String, remove_linenums::Bool = false)
+ function test_repr(x :: String, remove_linenums :: Bool = false)
- function test_scalar_indexing(::Type{T}, shape, ::Type{TestAbstractArray}) where T
+ function test_scalar_indexing(??? :: Type{T}, shape, ??? :: Type{TestAbstractArray}) where T
- function test_send(exp)
+ function test_send(exp)
- function test_setindex!_internals(::Type{TestAbstractArray})
+ function test_setindex!_internals(??? :: Type{TestAbstractArray})
- function test_setindex!_internals(::Type{T}, shape, ::Type{TestAbstractArray}) where T
+ function test_setindex!_internals(??? :: Type{T}, shape, ??? :: Type{TestAbstractArray}) where T
- function test_similar_codeinfo(a, b)
+ function test_similar_codeinfo(a, b)
- function test_sse(a1::V4xF32, a2::V4xF32, a3::V4xF32, a4::V4xF32)
+ function test_sse(a1 :: V4xF32, a2 :: V4xF32, a3 :: V4xF32, a4 :: V4xF32)
- function test_sse(a1::V4xI32, a2::V4xI32, a3::V4xI32, a4::V4xI32)
+ function test_sse(a1 :: V4xI32, a2 :: V4xI32, a3 :: V4xI32, a4 :: V4xI32)
- function test_stat_error(stat::Function, pth)
+ function test_stat_error(stat :: Function, pth)
- function test_struct1(::Type{Struct}) where {Struct}
+ function test_struct1(??? :: Type{Struct}) where Struct
- function test_struct10(::Type{Struct}) where {Struct}
+ function test_struct10(??? :: Type{Struct}) where Struct
- function test_struct11(::Type{Struct}) where {Struct}
+ function test_struct11(??? :: Type{Struct}) where Struct
- function test_struct12(::Type{Struct}) where {Struct}
+ function test_struct12(??? :: Type{Struct}) where Struct
- function test_struct13(::Type{Struct}) where {Struct}
+ function test_struct13(??? :: Type{Struct}) where Struct
- function test_struct14(::Type{Struct}) where {Struct}
+ function test_struct14(??? :: Type{Struct}) where Struct
- function test_struct15(::Type{Struct}) where {Struct}
+ function test_struct15(??? :: Type{Struct}) where Struct
- function test_struct16(::Type{Struct}, quoteplz = false) where {Struct}
+ function test_struct16(??? :: Type{Struct}, quoteplz = false) where Struct
- function test_struct17(::Type{Struct}) where {Struct}
+ function test_struct17(??? :: Type{Struct}) where Struct
- function test_struct18(::Type{Struct}) where {Struct}
+ function test_struct18(??? :: Type{Struct}) where Struct
- function test_struct4(::Type{Struct}) where {Struct}
+ function test_struct4(??? :: Type{Struct}) where Struct
- function test_struct5(::Type{Struct}) where {Struct}
+ function test_struct5(??? :: Type{Struct}) where Struct
- function test_struct6(::Type{Struct}) where {Struct}
+ function test_struct6(??? :: Type{Struct}) where Struct
- function test_struct7(::Type{Struct}) where {Struct}
+ function test_struct7(??? :: Type{Struct}) where Struct
- function test_struct8(::Type{Struct}) where {Struct}
+ function test_struct8(??? :: Type{Struct}) where Struct
- function test_struct9(::Type{Struct}) where {Struct}
+ function test_struct9(??? :: Type{Struct}) where Struct
- function test_struct_big(::Type{Struct}) where {Struct}
+ function test_struct_big(??? :: Type{Struct}) where Struct
- function test_success(proc::Process)
+ function test_success(proc :: Process)
- function test_this_prefs(this_prefs)
+ function test_this_prefs(this_prefs)
- function test_thread_range()
+ function test_thread_range
- function test_thread_too_few_iters()
+ function test_thread_too_few_iters
- function test_threaded_atomic_minmax(m::T,n::T) where T
+ function test_threaded_atomic_minmax(m :: T, n :: T) where T
- function test_threaded_loop_and_atomic_add()
+ function test_threaded_loop_and_atomic_add
- function test_throw_commoning(x)
+ function test_throw_commoning(x)
- function test_timeout(tval)
+ function test_timeout(tval)
- function test_touch(slval)
+ function test_touch(slval)
- function test_typed_ir_printing(@nospecialize(f), @nospecialize(types), must_used_vars)
+ function test_typed_ir_printing(f, types, must_used_vars)
- function test_undef_var_9898(a)
+ function test_undef_var_9898(a)
- function test_uniform(xs::AbstractArray{T}) where {T<:AbstractFloat}
+ function test_uniform(xs :: AbstractArray{T}) where T <: AbstractFloat
- function test_uniform(xs::AbstractArray{T}) where {T<:Integer}
+ function test_uniform(xs :: AbstractArray{T}) where T <: Integer
- function test_useref(stmt, v, op)
+ function test_useref(stmt, v, op)
- function test_userefs(body)
+ function test_userefs(body)
- function test_vector_indexing(::Type{T}, shape, ::Type{TestAbstractArray}) where T
+ function test_vector_indexing(??? :: Type{T}, shape, ??? :: Type{TestAbstractArray}) where T
- function test_watch_file_change(tval)
+ function test_watch_file_change(tval)
- function test_watch_file_timeout(tval)
+ function test_watch_file_timeout(tval)
- function test_worldage_error(f)
+ function test_worldage_error(f)
- function test_wr()
+ function test_wr
- function test_zeros(arr, T, s)
+ function test_zeros(arr, T, s)
- function testclosure(f, a::T, permanent::Bool=false, tt::Type{S}=Any) where {T, S}
+ function testclosure(f, a :: T, permanent :: Bool = false, tt :: Type{S} = Any) where T, S
- function testcpt(sz)
+ function testcpt(sz)
- function tester20360()
+ function tester20360
- function testmap_equivalence(mapf, f, c...)
+ function testmap_equivalence(mapf, f, c...)
- function testmi(numrange, denrange)
+ function testmi(numrange, denrange)
- function testset_beginend_call(args, tests, source)
+ function testset_beginend_call(args, tests, source)
- function testset_context(args, ex, source)
+ function testset_context(args, ex, source)
- function testset_forloop(args, testloop, source)
+ function testset_forloop(args, testloop, source)
- function testval(s, v)
+ function testval(s, v)
- function tex(stream::IO, md::MD)
+ function tex(stream :: IO, md :: MD)
- function textwidth(c::AbstractChar)
+ function textwidth(c :: AbstractChar)
- function thing(a::AbstractArray, b::Int)
+ function thing(a :: AbstractArray, b :: Int)
- function thing(a::Array, b::Real)
+ function thing(a :: Array, b :: Real)
- function thisind(s::AbstractString, i::Int)
+ function thisind(s :: AbstractString, i :: Int)
- function thrash(handle::Ptr{Cvoid})
+ function thrash(handle :: Ptr{Cvoid})
- function threadcall_threads()
+ function threadcall_threads
- function threaded_add_locked(::Type{LockT}, x, n) where LockT
+ function threaded_add_locked(??? :: Type{LockT}, x, n) where LockT
- function threaded_gc_locked(::Type{LockT}) where LockT
+ function threaded_gc_locked(??? :: Type{LockT}) where LockT
- function threaded_loop(a, r, x)
+ function threaded_loop(a, r, x)
- function threading_run(fun, static)
+ function threading_run(fun, static)
- function threadpool(tid = threadid())
+ function threadpool(tid = threadid())
- function threadpoolsize(pool::Symbol = :default)
+ function threadpoolsize(pool :: Symbol = :default)
- function threadpooltids(pool::Symbol)
+ function threadpooltids(pool :: Symbol)
- function throw_complex_domainerror(f::Symbol, x)
+ function throw_complex_domainerror(f :: Symbol, x)
- function throw_complex_domainerror_neg1(f::Symbol, x)
+ function throw_complex_domainerror_neg1(f :: Symbol, x)
- function throw_eachindex_mismatch_indices(::IndexCartesian, inds...)
+ function throw_eachindex_mismatch_indices(??? :: IndexCartesian, inds...)
- function throw_eachindex_mismatch_indices(::IndexLinear, inds...)
+ function throw_eachindex_mismatch_indices(??? :: IndexLinear, inds...)
- function throw_exp_domainerror(x)
+ function throw_exp_domainerror(x)
- function throw_field_access(t, i, n_fields)
+ function throw_field_access(t, i, n_fields)
- function throw_inconsistent()
+ function throw_inconsistent
- function throw_negative_refcount_error(x::Int)
+ function throw_negative_refcount_error(x :: Int)
- function throw_setindex_mismatch(X, I)
+ function throw_setindex_mismatch(X, I)
- function throwbits(S::Type, T::Type, U::Type)
+ function throwbits(S :: Type, T :: Type, U :: Type)
- function throws_matching_exception(f::Function, acceptable_exceptions::AbstractVector)
+ function throws_matching_exception(f :: Function, acceptable_exceptions :: AbstractVector)
- function throws_matching_uv_error(f::Function, pfx::AbstractString, codes::AbstractVector{<:Integer})
+ function throws_matching_uv_error(f :: Function, pfx :: AbstractString, codes :: AbstractVector{??? <: Integer})
- function throwsingleton(S::Type, T::Type)
+ function throwsingleton(S :: Type, T :: Type)
- function throwsize0(S::Type, T::Type, msg)
+ function throwsize0(S :: Type, T :: Type, msg)
- function throwto(t::Task, @nospecialize exc)
+ function throwto(t :: Task, exc)
- function tighttypes!(adf)
+ function tighttypes!(adf)
- function time_inference(f)
+ function time_inference(f)
- function time_macro_scope()
+ function time_macro_scope
- function time_print(io::IO, elapsedtime, bytes=0, gctime=0, allocs=0, compile_time=0, recompile_time=0, newline=false; msg::Union{String,Nothing}=nothing)
+ function time_print(io :: IO, elapsedtime, bytes = 0, gctime = 0, allocs = 0, compile_time = 0, recompile_time = 0, newline = false, msg :: Union{String, Nothing} = nothing)
- function timedwait(testcb, timeout::Real; pollint::Real=0.1)
+ function timedwait(testcb, timeout :: Real, pollint :: Real = 0.1)
- function timesofar(str)
+ function timesofar(str)
- function timev_macro_scope()
+ function timev_macro_scope
- function timev_print(elapsedtime, diff::GC_Diff, compile_times; msg::Union{String,Nothing}=nothing)
+ function timev_print(elapsedtime, diff :: GC_Diff, compile_times, msg :: Union{String, Nothing} = nothing)
- function titlecase(s::AbstractString; wordsep::Function = !isletter, strict::Bool=true)
+ function titlecase(s :: AbstractString, wordsep :: Function = !isletter, strict :: Bool = true)
- function tmeet(::JLTypeLattice, @nospecialize(a::Type), @nospecialize(b::Type))
+ function tmeet(??? :: JLTypeLattice, a :: Type, b :: Type)
- function tmerge_field(L::AbstractLattice, @nospecialize(a), @nospecialize(b))
+ function tmerge_field(L :: AbstractLattice, a, b)
- function to_ieee754(::Type{T}, x::BigFloat, rm) where {T<:AbstractFloat}
+ function to_ieee754(??? :: Type{T}, x :: BigFloat, rm) where T <: AbstractFloat
- function to_indices(A, inds, I::Tuple{Any, Vararg{Any}})
+ function to_indices(A, inds, I :: Tuple{Any, Vararg{Any}})
- function to_toml_value(f::MbyFunc, value)
+ function to_toml_value(f :: MbyFunc, value)
- function to_tuple_type(@nospecialize(t))
+ function to_tuple_type(t)
- function toexpr(md::List)
+ function toexpr(md :: List)
- function toexpr(md::Table)
+ function toexpr(md :: Table)
- function tofirst(dt::TimeType, dow::Int; of::Union{Type{Year}, Type{Month}}=Month)
+ function tofirst(dt :: TimeType, dow :: Int, of :: Union{Type{Year}, Type{Month}} = Month)
- function tohtml(io::IO, m::MIME"image/png", img)
+ function tohtml(io :: IO, m :: MIME"image/png", img)
- function tohtml(io::IO, m::MIME"image/svg+xml", img)
+ function tohtml(io :: IO, m :: MIME"image/svg+xml", img)
- function tohtml(io::IO, m::MIME"text/html", x)
+ function tohtml(io :: IO, m :: MIME"text/html", x)
- function tohtml(io::IO, m::MIME"text/plain", x)
+ function tohtml(io :: IO, m :: MIME"text/plain", x)
- function tolast(dt::TimeType, dow::Int; of::Union{Type{Year}, Type{Month}}=Month)
+ function tolast(dt :: TimeType, dow :: Int, of :: Union{Type{Year}, Type{Month}} = Month)
- function tonext(func::Function, dt::TimeType; step::Period=Day(1), limit::Int=10000, same::Bool=false)
+ function tonext(func :: Function, dt :: TimeType, step :: Period = Day(1), limit :: Int = 10000, same :: Bool = false)
- function top(stack :: Stack)
+ function top(stack :: Stack)
- function top_set_bit(x::BigInt)
+ function top_set_bit(x :: BigInt)
- function toprev(func::Function, dt::TimeType; step::Period=Day(-1), limit::Int=10000, same::Bool=false)
+ function toprev(func :: Function, dt :: TimeType, step :: Period = Day(-1), limit :: Int = 10000, same :: Bool = false)
- function total_memory()
+ function total_memory
- function totaldays(y, m, d)
+ function totaldays(y, m, d)
- function touch(f::File)
+ function touch(f :: File)
- function touch(path::AbstractString)
+ function touch(path :: AbstractString)
- function tr(A::AbstractMatrix)
+ function tr(A :: AbstractMatrix)
- function tr(A::Matrix{T}) where T
+ function tr(A :: Matrix{T}) where T
- function tr(J::UniformScaling{T}) where T
+ function tr(J :: UniformScaling{T}) where T
- function trace_callback(level::Cint, msg::Cstring)::Cint
+ function trace_callback(level :: Cint, msg :: Cstring)
- function trace_set(level::Union{Integer,Consts.GIT_TRACE_LEVEL}, cb=trace_cb())
+ function trace_set(level :: Union{Integer, Consts.GIT_TRACE_LEVEL}, cb = trace_cb())
- function trailing_ones(x::BigInt)
+ function trailing_ones(x :: BigInt)
- function trailing_zeros(x::BigInt)
+ function trailing_zeros(x :: BigInt)
- function trailingsize(A, n)
+ function trailingsize(A, n)
- function trailingsize(inds::Indices)
+ function trailingsize(inds :: Indices)
- function trailingsize(inds::Indices, n)
+ function trailingsize(inds :: Indices, n)
- function transact(f::Function, repo::GitRepo)
+ function transact(f :: Function, repo :: GitRepo)
- function transcode(::Type{UInt16}, src::AbstractVector{UInt8})
+ function transcode(??? :: Type{UInt16}, src :: AbstractVector{UInt8})
- function transcode(::Type{UInt8}, src::AbstractVector{UInt16})
+ function transcode(??? :: Type{UInt8}, src :: AbstractVector{UInt16})
- function transcode(::Type{UInt8}, src::Vector{<:Union{Int32,UInt32}})
+ function transcode(??? :: Type{UInt8}, src :: Vector{??? <: Union{Int32, UInt32}})
- function transfer_progress(progress::Ptr{LibGit2.TransferProgress}, payload::Dict)
+ function transfer_progress(progress :: Ptr{LibGit2.TransferProgress}, payload :: Dict)
- function transform!(ci::CodeInfo, nargs::Int, sparams::Core.SimpleVector)
+ function transform!(ci :: CodeInfo, nargs :: Int, sparams :: Core.SimpleVector)
- function transform!(f, s, i = -1)
+ function transform!(f, s, i = -1)
- function transform_expr(expr, map_slot_number, map_ssa_value, sparams::Core.SimpleVector)
+ function transform_expr(expr, map_slot_number, map_ssa_value, sparams :: Core.SimpleVector)
- function transition(f::Function, s::MIState, newmode::Union{TextInterface,Symbol})
+ function transition(f :: Function, s :: MIState, newmode :: Union{TextInterface, Symbol})
- function transition(f::Function, s::PrefixSearchState, mode::Prompt)
+ function transition(f :: Function, s :: PrefixSearchState, mode :: Prompt)
- function transpose!(B::AbstractMatrix, A::AbstractVector)
+ function transpose!(B :: AbstractMatrix, A :: AbstractVector)
- function transpose!(B::AbstractVector, A::AbstractMatrix)
+ function transpose!(B :: AbstractVector, A :: AbstractMatrix)
- function transpose!(C::BitMatrix, B::BitMatrix)
+ function transpose!(C :: BitMatrix, B :: BitMatrix)
- function transpose8x8(x::UInt64)
+ function transpose8x8(x :: UInt64)
- function transpose_f!(f, B::AbstractMatrix, A::AbstractMatrix)
+ function transpose_f!(f, B :: AbstractMatrix, A :: AbstractMatrix)
- function transposeblock!(f, B::AbstractMatrix, A::AbstractMatrix, m::Int, n::Int, offseti::Int, offsetj::Int)
+ function transposeblock!(f, B :: AbstractMatrix, A :: AbstractMatrix, m :: Int, n :: Int, offseti :: Int, offsetj :: Int)
- function tree!(root::StackFrameTree{T}, all::Vector{Alloc}, C::Bool, recur::Symbol) where {T}
+ function tree!(root :: StackFrameTree{T}, all :: Vector{Alloc}, C :: Bool, recur :: Symbol) where T
- function tree(io::IO, data::Vector{Alloc}, cols::Int, fmt::ProfileFormat)
+ function tree(io :: IO, data :: Vector{Alloc}, cols :: Int, fmt :: ProfileFormat)
- function tree_format(frames::Vector{<:StackFrameTree}, level::Int, cols::Int, maxes, filenamemap::Dict{Symbol,String}, showpointer::Bool)
+ function tree_format(frames :: Vector{??? <: StackFrameTree}, level :: Int, cols :: Int, maxes, filenamemap :: Dict{Symbol, String}, showpointer :: Bool)
- function treewalk(f, tree::GitTree, post::Bool = false)
+ function treewalk(f, tree :: GitTree, post :: Bool = false)
- function triangular_methodshow(x::T1, y::T2) where {T2<:Integer, T1<:T2}
+ function triangular_methodshow(x :: T1, y :: T2) where T2 <: Integer, T1 <: T2
- function tridiag(T::Type, m::Integer, n::Integer)
+ function tridiag(T :: Type, m :: Integer, n :: Integer)
- function trigger14878()
+ function trigger14878
- function tril!(A::UnitLowerTriangular, k::Integer=0)
+ function tril!(A :: UnitLowerTriangular, k :: Integer = 0)
- function tril!(A::UnitUpperTriangular{T}, k::Integer=0) where {T}
+ function tril!(A :: UnitUpperTriangular{T}, k :: Integer = 0) where T
- function tril!(A::UpperTriangular{T}, k::Integer=0) where {T}
+ function tril!(A :: UpperTriangular{T}, k :: Integer = 0) where T
- function tril!(D::Diagonal{T}, k::Integer=0) where T
+ function tril!(D :: Diagonal{T}, k :: Integer = 0) where T
- function tril!(M::AbstractMatrix, k::Integer)
+ function tril!(M :: AbstractMatrix, k :: Integer)
- function tril!(M::Bidiagonal{T}, k::Integer=0) where T
+ function tril!(M :: Bidiagonal{T}, k :: Integer = 0) where T
- function tril!(M::SymTridiagonal{T}, k::Integer=0) where T
+ function tril!(M :: SymTridiagonal{T}, k :: Integer = 0) where T
- function tril!(M::Tridiagonal{T}, k::Integer=0) where T
+ function tril!(M :: Tridiagonal{T}, k :: Integer = 0) where T
- function tril(A::Hermitian, k::Integer=0)
+ function tril(A :: Hermitian, k :: Integer = 0)
- function tril(A::Symmetric, k::Integer=0)
+ function tril(A :: Symmetric, k :: Integer = 0)
- function tril(B::BitMatrix, k::Integer=0)
+ function tril(B :: BitMatrix, k :: Integer = 0)
- function trim_after_eval(str::AbstractString)
+ function trim_after_eval(str :: AbstractString)
- function trimdocs(md::Markdown.MD, brief::Bool)
+ function trimdocs(md :: Markdown.MD, brief :: Bool)
- function triplet(p::AbstractPlatform)
+ function triplet(p :: AbstractPlatform)
- function triu!(A::LowerTriangular{T}, k::Integer=0) where {T}
+ function triu!(A :: LowerTriangular{T}, k :: Integer = 0) where T
- function triu!(A::UnitLowerTriangular{T}, k::Integer=0) where T
+ function triu!(A :: UnitLowerTriangular{T}, k :: Integer = 0) where T
- function triu!(A::UnitUpperTriangular, k::Integer=0)
+ function triu!(A :: UnitUpperTriangular, k :: Integer = 0)
- function triu!(D::Diagonal{T}, k::Integer=0) where T
+ function triu!(D :: Diagonal{T}, k :: Integer = 0) where T
- function triu!(M::AbstractMatrix, k::Integer)
+ function triu!(M :: AbstractMatrix, k :: Integer)
- function triu!(M::Bidiagonal{T}, k::Integer=0) where T
+ function triu!(M :: Bidiagonal{T}, k :: Integer = 0) where T
- function triu!(M::SymTridiagonal{T}, k::Integer=0) where T
+ function triu!(M :: SymTridiagonal{T}, k :: Integer = 0) where T
- function triu!(M::Tridiagonal{T}, k::Integer=0) where T
+ function triu!(M :: Tridiagonal{T}, k :: Integer = 0) where T
- function triu(A::Hermitian, k::Integer=0)
+ function triu(A :: Hermitian, k :: Integer = 0)
- function triu(A::Symmetric, k::Integer=0)
+ function triu(A :: Symmetric, k :: Integer = 0)
- function triu(B::BitMatrix, k::Integer=0)
+ function triu(B :: BitMatrix, k :: Integer = 0)
- function truncate(f::File, n::Integer)
+ function truncate(f :: File, n :: Integer)
- function truncate(io::GenericIOBuffer, n::Integer)
+ function truncate(io :: GenericIOBuffer, n :: Integer)
- function truncate(s::IOStream, n::Integer)
+ function truncate(s :: IOStream, n :: Integer)
- function truncated(::Type{R}, x::RawBigInt, len::Int) where {R<:Integer}
+ function truncated(??? :: Type{R}, x :: RawBigInt, len :: Int) where R <: Integer
- function truncbits(x::F, nb) where {F<:IEEEFloat}
+ function truncbits(x :: F, nb) where F <: IEEEFloat
- function truncmask(x::F, mask) where {F<:IEEEFloat}
+ function truncmask(x :: F, mask) where F <: IEEEFloat
- function try_catch()
+ function try_catch
- function try_compute_field(ir::Union{IncrementalCompact,IRCode}, @nospecialize(field))
+ function try_compute_field(ir :: Union{IncrementalCompact, IRCode}, field)
- function try_compute_fieldidx(@nospecialize(typ), @nospecialize(field))
+ function try_compute_fieldidx(typ, field)
- function try_compute_fieldidx_stmt(ir::Union{IncrementalCompact,IRCode}, stmt::Expr, @nospecialize(typ))
+ function try_compute_fieldidx_stmt(ir :: Union{IncrementalCompact, IRCode}, stmt :: Expr, typ)
- function try_return_date(p, year, month, day)
+ function try_return_date(p, year, month, day)
- function try_return_datetime(p, year, month, day, h, m, s, ms)
+ function try_return_datetime(p, year, month, day, h, m, s, ms)
- function try_return_time(p, h, m, s, ms)
+ function try_return_time(p, h, m, s, ms)
- function try_stacktrace()
+ function try_stacktrace
- function try_yieldto(undo)
+ function try_yieldto(undo)
- function trylisten(sock::LibuvServer; backlog::Integer=BACKLOG_DEFAULT)
+ function trylisten(sock :: LibuvServer, backlog :: Integer = BACKLOG_DEFAULT)
- function trylock(f, l::AbstractLock)
+ function trylock(f, l :: AbstractLock)
- function trylock(l::SpinLock)
+ function trylock(l :: SpinLock)
- function trymkpidlock(args...; kwargs...)
+ function trymkpidlock(args..., kwargs...)
- function tryopen_exclusive(path::String, mode::Integer = 0o444)
+ function tryopen_exclusive(path :: String, mode :: Integer = 0o444)
- function tryparse(::Type{BigFloat}, s::AbstractString; base::Integer=0, precision::Integer=DEFAULT_PRECISION[], rounding::MPFRRoundingMode=ROUNDING_MODE[])
+ function tryparse(??? :: Type{BigFloat}, s :: AbstractString, base :: Integer = 0, precision :: Integer = DEFAULT_PRECISION[], rounding :: MPFRRoundingMode = ROUNDING_MODE[])
- function tryparse(::Type{Float32}, s::String)
+ function tryparse(??? :: Type{Float32}, s :: String)
- function tryparse(::Type{Float32}, s::SubString{String})
+ function tryparse(??? :: Type{Float32}, s :: SubString{String})
- function tryparse(::Type{Float64}, s::String)
+ function tryparse(??? :: Type{Float64}, s :: String)
- function tryparse(::Type{Float64}, s::SubString{String})
+ function tryparse(??? :: Type{Float64}, s :: SubString{String})
- function tryparse(::Type{SHA1}, s::AbstractString)
+ function tryparse(??? :: Type{SHA1}, s :: AbstractString)
- function tryparse(::Type{T}, s::AbstractString; base::Union{Nothing,Integer} = nothing) where {T<:Integer}
+ function tryparse(??? :: Type{T}, s :: AbstractString, base :: Union{Nothing, Integer} = nothing) where T <: Integer
- function tryparse(::Type{VersionNumber}, v::AbstractString)
+ function tryparse(??? :: Type{VersionNumber}, v :: AbstractString)
- function tryparse(l::Parser)::Err{TOMLDict}
+ function tryparse(l :: Parser)
- function tryparse_internal(::Type{BigInt}, s::AbstractString, startpos::Int, endpos::Int, base_::Integer, raise::Bool)
+ function tryparse_internal(??? :: Type{BigInt}, s :: AbstractString, startpos :: Int, endpos :: Int, base_ :: Integer, raise :: Bool)
- function tryparse_internal(::Type{Complex{T}}, s::Union{String,SubString{String}}, i::Int, e::Int, raise::Bool) where {T<:Real}
+ function tryparse_internal(??? :: Type{Complex{T}}, s :: Union{String, SubString{String}}, i :: Int, e :: Int, raise :: Bool) where T <: Real
- function tryparse_internal(::Type{Float32}, s::String, startpos::Int, endpos::Int)
+ function tryparse_internal(??? :: Type{Float32}, s :: String, startpos :: Int, endpos :: Int)
- function tryparse_internal(::Type{Float32}, s::SubString{String}, startpos::Int, endpos::Int)
+ function tryparse_internal(??? :: Type{Float32}, s :: SubString{String}, startpos :: Int, endpos :: Int)
- function tryparse_internal(::Type{Float64}, s::String, startpos::Int, endpos::Int)
+ function tryparse_internal(??? :: Type{Float64}, s :: String, startpos :: Int, endpos :: Int)
- function tryparse_internal(::Type{Float64}, s::SubString{String}, startpos::Int, endpos::Int)
+ function tryparse_internal(??? :: Type{Float64}, s :: SubString{String}, startpos :: Int, endpos :: Int)
- function tryparse_internal(::Type{T}, s::AbstractString, raise::Bool; kwargs...) where T<:Real
+ function tryparse_internal(??? :: Type{T}, s :: AbstractString, raise :: Bool, kwargs...) where T <: Real
- function tryparse_internal(::Type{T}, s::AbstractString, startpos::Int, endpos::Int, base_::Integer, raise::Bool) where T<:Integer
+ function tryparse_internal(??? :: Type{T}, s :: AbstractString, startpos :: Int, endpos :: Int, base_ :: Integer, raise :: Bool) where T <: Integer
- function tryparse_internal(::Type{T}, s::AbstractString, startpos::Int, endpos::Int, raise::Bool) where T<:Real
+ function tryparse_internal(??? :: Type{T}, s :: AbstractString, startpos :: Int, endpos :: Int, raise :: Bool) where T <: Real
- function tryparsenext(d::DatePart{'p'}, str, i, len)
+ function tryparsenext(d :: DatePart{'p'}, str, i, len)
- function trypoptask(W::StickyWorkqueue)
+ function trypoptask(W :: StickyWorkqueue)
- function tryrmopenfile(path::String)
+ function tryrmopenfile(path :: String)
- function ttt7049(;init::Maybe7049{Union{AbstractString,Tuple{Int,Char}}} = nothing)
+ function ttt7049(init :: Maybe7049{Union{AbstractString, Tuple{Int, Char}}} = nothing)
- function ttyhascolor(term_type = get(ENV, "TERM", ""))
+ function ttyhascolor(term_type = get(ENV,"TERM",""))
- function ttyhastruecolor()
+ function ttyhastruecolor
- function tuple_sort_test(x)
+ function tuple_sort_test(x)
- function tuple_tail_elem(L::AbstractLattice, @nospecialize(init), ct::Vector{Any})
+ function tuple_tail_elem(L :: AbstractLattice, init, ct :: Vector{Any})
- function tuple_tfunc(L::AbstractLattice, argtypes::Vector{Any})
+ function tuple_tfunc(L :: AbstractLattice, argtypes :: Vector{Any})
- function tuple_type_cons(::Type{S}, ::Type{T}) where T<:Tuple where S
+ function tuple_type_cons(??? :: Type{S}, ??? :: Type{T}) where T <: Tuple where S
- function tuple_type_tail(T::Type)
+ function tuple_type_tail(T :: Type)
- function tuplemerge(a::DataType, b::DataType)
+ function tuplemerge(a :: DataType, b :: DataType)
- function tuplemerge_test(a, b, r, commutative=true)
+ function tuplemerge_test(a, b, r, commutative = true)
- function twice_sitofp(x::Int, y::Int)
+ function twice_sitofp(x :: Int, y :: Int)
- function twiceprecision(val::T, nb::Integer) where {T<:IEEEFloat}
+ function twiceprecision(val :: T, nb :: Integer) where T <: IEEEFloat
- function twiceprecision(val::TwicePrecision{T}, nb::Integer) where {T<:IEEEFloat}
+ function twiceprecision(val :: TwicePrecision{T}, nb :: Integer) where T <: IEEEFloat
- function twiceprecision_is_normalized(tw::Tw) where {Tw<:Base.TwicePrecision}
+ function twiceprecision_is_normalized(tw :: Tw) where Tw <: Base.TwicePrecision
- function two_breakpoint(a::Float64)
+ function two_breakpoint(a :: Float64)
- function two_mul(x::T, y::T) where {T<:Number}
+ function two_mul(x :: T, y :: T) where T <: Number
- function twomul(a::Float64, b::Float64)
+ function twomul(a :: Float64, b :: Float64)
- function typ_for_val(@nospecialize(x), ci::CodeInfo, ir::IRCode, idx::Int, slottypes::Vector{Any})
+ function typ_for_val(x, ci :: CodeInfo, ir :: IRCode, idx :: Int, slottypes :: Vector{Any})
- function type_annotate!(interp::AbstractInterpreter, sv::InferenceState)
+ function type_annotate!(interp :: AbstractInterpreter, sv :: InferenceState)
- function type_close_enough(@nospecialize(x), @nospecialize(t))
+ function type_close_enough(x, t)
- function type_depth_limit(str::String, n::Int; maxdepth = nothing)
+ function type_depth_limit(str :: String, n :: Int, maxdepth = nothing)
- function type_limited_string_from_context(out::IO, str::String)
+ function type_limited_string_from_context(out :: IO, str :: String)
- function type_more_complex(@nospecialize(t), @nospecialize(c), sources::SimpleVector, depth::Int, tupledepth::Int, allowed_tuplelen::Int)
+ function type_more_complex(t, c, sources :: SimpleVector, depth :: Int, tupledepth :: Int, allowed_tuplelen :: Int)
- function typeassert_instead_of_decl()
+ function typeassert_instead_of_decl
- function typed_hvcat(::Type{T}, rows::Tuple{Vararg{Int}}, as...) where T
+ function typed_hvcat(??? :: Type{T}, rows :: Tuple{Vararg{Int}}, as...) where T
- function typed_hvcat(::Type{T}, rows::Tuple{Vararg{Int}}, as::AbstractVecOrMat...) where T
+ function typed_hvcat(??? :: Type{T}, rows :: Tuple{Vararg{Int}}, as :: AbstractVecOrMat...) where T
- function typed_hvcat(::Type{T}, rows::Tuple{Vararg{Int}}, xs::Number...) where T
+ function typed_hvcat(??? :: Type{T}, rows :: Tuple{Vararg{Int}}, xs :: Number...) where T
- function typeinf(interp::AbstractInterpreter, result::InferenceResult, cache_mode::Symbol)
+ function typeinf(interp :: AbstractInterpreter, result :: InferenceResult, cache_mode :: Symbol)
- function typeinf(interp::NativeInterpreter, frame::InferenceState)
+ function typeinf(interp :: NativeInterpreter, frame :: InferenceState)
- function typeinf_code(interp::AbstractInterpreter, mi::MethodInstance, run_optimizer::Bool)
+ function typeinf_code(interp :: AbstractInterpreter, mi :: MethodInstance, run_optimizer :: Bool)
- function typeinf_edge(interp::AbstractInterpreter, method::Method, @nospecialize(atype), sparams::SimpleVector, caller::AbsIntState)
+ function typeinf_edge(interp :: AbstractInterpreter, method :: Method, atype, sparams :: SimpleVector, caller :: AbsIntState)
- function typeinf_ext(interp::AbstractInterpreter, mi::MethodInstance)
+ function typeinf_ext(interp :: AbstractInterpreter, mi :: MethodInstance)
- function typeinf_ext_toplevel(interp::AbstractInterpreter, mi::MethodInstance)
+ function typeinf_ext_toplevel(interp :: AbstractInterpreter, mi :: MethodInstance)
- function typeinf_frame(interp::AbstractInterpreter, mi::MethodInstance, run_optimizer::Bool)
+ function typeinf_frame(interp :: AbstractInterpreter, mi :: MethodInstance, run_optimizer :: Bool)
- function typeinf_local(interp::AbstractInterpreter, frame::InferenceState)
+ function typeinf_local(interp :: AbstractInterpreter, frame :: InferenceState)
- function typeinf_nocycle(interp::AbstractInterpreter, frame::InferenceState)
+ function typeinf_nocycle(interp :: AbstractInterpreter, frame :: InferenceState)
- function typeinf_type(interp::AbstractInterpreter, method::Method, @nospecialize(atype), sparams::SimpleVector)
+ function typeinf_type(interp :: AbstractInterpreter, method :: Method, atype, sparams :: SimpleVector)
- function typeinfo_implicit(@nospecialize(T))
+ function typeinfo_implicit(T)
- function typeinfo_prefix(io::IO, X)
+ function typeinfo_prefix(io :: IO, X)
- function typejoin(@nospecialize(a), @nospecialize(b))
+ function typejoin(a, b)
- function typejoin_union_tuple(T::DataType)
+ function typejoin_union_tuple(T :: DataType)
- function typemax(::Type{VersionNumber})
+ function typemax(??? :: Type{VersionNumber})
- function typename(a::Union)
+ function typename(a :: Union)
- function typename_static(@nospecialize(t))
+ function typename_static(t)
- function typeof_concrete_vararg(t::DataType)
+ function typeof_concrete_vararg(t :: DataType)
- function typesplit(@nospecialize(a), @nospecialize(b))
+ function typesplit(a, b)
- function typesubtract(@nospecialize(a), @nospecialize(b), max_union_splitting::Int)
+ function typesubtract(a, b, max_union_splitting :: Int)
- function uint_map!(v::AbstractVector, lo::Integer, hi::Integer, order::Ordering)
+ function uint_map!(v :: AbstractVector, lo :: Integer, hi :: Integer, order :: Ordering)
- function umul256(a::UInt128, bHi::UInt64, bLo::UInt64)
+ function umul256(a :: UInt128, bHi :: UInt64, bLo :: UInt64)
- function unaliascopy(V::SubArray{T,N,A,I,LD}) where {T,N,A<:Array,I<:Tuple{Vararg{Union{Real,AbstractRange,Array}}},LD}
+ function unaliascopy(V :: SubArray{T, N, A, I, LD}) where T, N, A <: Array, I <: Tuple{Vararg{Union{Real, AbstractRange, Array}}}, LD
- function unary_ops_tests(a, ca, tol; n=size(a, 1))
+ function unary_ops_tests(a, ca, tol, n = size(a,1))
- function unbiased_exponent(x::T) where {T<:IEEEFloat}
+ function unbiased_exponent(x :: T) where T <: IEEEFloat
- function unblock(@nospecialize ex)
+ function unblock(ex)
- function unconstrain_vararg_length(va::Core.TypeofVararg)
+ function unconstrain_vararg_length(va :: Core.TypeofVararg)
- function undeclared_ceil(x::Float64)
+ function undeclared_ceil(x :: Float64)
- function undef_var_in_catch()
+ function undef_var_in_catch
- function underscore_bold(stream::IO, md::MD)
+ function underscore_bold(stream :: IO, md :: MD)
- function underscore_italic(stream::IO, md::MD)
+ function underscore_italic(stream :: IO, md :: MD)
- function undot(x::Expr)
+ function undot(x :: Expr)
- function unescape(@nospecialize ex)
+ function unescape(ex)
- function unescape_string(io::IO, s::AbstractString, keep = ())
+ function unescape_string(io :: IO, s :: AbstractString, keep = ())
- function unexpected_assignment!(ir::IRCode, pc::Int)
+ function unexpected_assignment!(ir :: IRCode, pc :: Int)
- function unindent(str::AbstractString, indent::Int; tabwidth=8)
+ function unindent(str :: AbstractString, indent :: Int, tabwidth = 8)
- function union!(s::AbstractSet, sets...)
+ function union!(s :: AbstractSet, sets...)
- function union!(s::AbstractSet{T}, itr) where T
+ function union!(s :: AbstractSet{T}, itr) where T
- function union!(s::BitSet, itr)
+ function union!(s :: BitSet, itr)
- function union!(s::BitSet, r::AbstractUnitRange{<:Integer})
+ function union!(s :: BitSet, r :: AbstractUnitRange{??? <: Integer})
- function union!(s::IntDisjointSet{T}, x::T, y::T) where {T<:Integer}
+ function union!(s :: IntDisjointSet{T}, x :: T, y :: T) where T <: Integer
- function union_caller_cycle!(a::InferenceState, b::InferenceState)
+ function union_caller_cycle!(a :: InferenceState, b :: InferenceState)
- function union_causes(causesa::IdSet{InferenceState}, causesb::IdSet{InferenceState})
+ function union_causes(causesa :: IdSet{InferenceState}, causesb :: IdSet{InferenceState})
- function unionall_depth(@nospecialize ua)
+ function unionall_depth(ua)
- function unionsplitcost(L::AbstractLattice, argtypes::Union{SimpleVector,Vector{Any}})
+ function unionsplitcost(L :: AbstractLattice, argtypes :: Union{SimpleVector, Vector{Any}})
- function uniontype_layout(@nospecialize T::Type)
+ function uniontype_layout(T :: Type)
- function unique!(f, A::AbstractVector; seen::Union{Nothing,Set}=nothing)
+ function unique!(f, A :: AbstractVector, seen :: Union{Nothing, Set} = nothing)
- function unique!(itr)
+ function unique!(itr)
- function unique(f, C; seen::Union{Nothing,Set}=nothing)
+ function unique(f, C, seen :: Union{Nothing, Set} = nothing)
- function unique(itr)
+ function unique(itr)
- function unix2date(t)
+ function unix2date(t)
- function unix2datetime(x)
+ function unix2datetime(x)
- function unlink(p::AbstractString)
+ function unlink(p :: AbstractString)
- function unlock(l::SpinLock)
+ function unlock(l :: SpinLock)
- function unlockall(rl::ReentrantLock)
+ function unlockall(rl :: ReentrantLock)
- function unmark(io::IO)
+ function unmark(io :: IO)
- function unordered_test_for_extrema(a; dims_test = ((), 1, 2, (1,2), 3))
+ function unordered_test_for_extrema(a, dims_test = ((),1,2,(1,2),3))
- function unpreserve_handle(x)
+ function unpreserve_handle(x)
- function unreference_module(key::PkgId)
+ function unreference_module(key :: PkgId)
- function unremovable_if_unused1!(x)
+ function unremovable_if_unused1!(x)
- function unremovable_if_unused2!()
+ function unremovable_if_unused2!
- function unremovable_if_unused3!()
+ function unremovable_if_unused3!
- function unsafe_SecretBuffer!(p::Ptr{UInt8}, len=1)
+ function unsafe_SecretBuffer!(p :: Ptr{UInt8}, len = 1)
- function unsafe_SecretBuffer!(s::Cstring)
+ function unsafe_SecretBuffer!(s :: Cstring)
- function unsafe_bitfindnext(Bc::Vector{UInt64}, start::Int)
+ function unsafe_bitfindnext(Bc :: Vector{UInt64}, start :: Int)
- function unsafe_bitfindprev(Bc::Vector{UInt64}, start::Int)
+ function unsafe_bitfindprev(Bc :: Vector{UInt64}, start :: Int)
- function unsafe_convert(::Type{Cstring}, s::String)
+ function unsafe_convert(??? :: Type{Cstring}, s :: String)
- function unsafe_convert(::Type{Ptr{Any}}, b::RefArray{Any})::Ptr{Any}
+ function unsafe_convert(??? :: Type{Ptr{Any}}, b :: RefArray{Any})
- function unsafe_convert(::Type{Ptr{Any}}, b::RefValue{Any})::Ptr{Any}
+ function unsafe_convert(??? :: Type{Ptr{Any}}, b :: RefValue{Any})
- function unsafe_convert(::Type{Ptr{Cvoid}}, a::GenericMemoryRef{<:Any,T,Core.CPU}) where {T}
+ function unsafe_convert(??? :: Type{Ptr{Cvoid}}, a :: GenericMemoryRef{??? <: Any, T, Core.CPU}) where T
- function unsafe_convert(::Type{Ptr{R}}, s::SubString{String}) where R<:Union{Int8, UInt8}
+ function unsafe_convert(??? :: Type{Ptr{R}}, s :: SubString{String}) where R <: Union{Int8, UInt8}
- function unsafe_convert(::Type{Ptr{S}}, V::SubArray{T,N,P,<:Tuple{Vararg{Union{RangeIndex,ReshapedUnitRange}}}}) where {S,T,N,P}
+ function unsafe_convert(??? :: Type{Ptr{S}}, V :: SubArray{T, N, P, ??? <: Tuple{Vararg{Union{RangeIndex, ReshapedUnitRange}}}}) where S, T, N, P
- function unsafe_convert(P::Union{Type{Ptr{T}},Type{Ptr{Cvoid}}}, b::RefArray{T})::P where T
+ function unsafe_convert(P :: Union{Type{Ptr{T}}, Type{Ptr{Cvoid}}}, b :: RefArray{T}) where T
- function unsafe_convert(P::Union{Type{Ptr{T}},Type{Ptr{Cvoid}}}, b::RefValue{T})::P where T
+ function unsafe_convert(P :: Union{Type{Ptr{T}}, Type{Ptr{Cvoid}}}, b :: RefValue{T}) where T
- function unsafe_copyto!(dest::Array, doffs, src::Array, soffs, n)
+ function unsafe_copyto!(dest :: Array, doffs, src :: Array, soffs, n)
- function unsafe_copyto!(dest::BitArray, doffs::Integer, src::Union{BitArray,Array}, soffs::Integer, n::Integer)
+ function unsafe_copyto!(dest :: BitArray, doffs :: Integer, src :: Union{BitArray, Array}, soffs :: Integer, n :: Integer)
- function unsafe_copyto!(dest::GenericMemoryRef, src::GenericMemoryRef, n)
+ function unsafe_copyto!(dest :: GenericMemoryRef, src :: GenericMemoryRef, n)
- function unsafe_copyto!(dest::Memory, doffs, src::Memory, soffs, n)
+ function unsafe_copyto!(dest :: Memory, doffs, src :: Memory, soffs, n)
- function unsafe_copyto!(dest::MemoryRef{T}, src::MemoryRef{T}, n) where {T}
+ function unsafe_copyto!(dest :: MemoryRef{T}, src :: MemoryRef{T}, n) where T
- function unsafe_copyto!(dest::Memory{T}, doffs, src::Memory{T}, soffs, n) where{T}
+ function unsafe_copyto!(dest :: Memory{T}, doffs, src :: Memory{T}, soffs, n) where T
- function unsafe_copyto!(dest::Ptr{T}, src::Ptr{T}, n) where T
+ function unsafe_copyto!(dest :: Ptr{T}, src :: Ptr{T}, n) where T
- function unsafe_getindex(r::StepRangeLen{T,<:TwicePrecision,<:TwicePrecision}, i::Integer) where T
+ function unsafe_getindex(r :: StepRangeLen{T, ??? <: TwicePrecision, ??? <: TwicePrecision}, i :: Integer) where T
- function unsafe_getindex(r::StepRangeLen{T}, i::Integer) where T
+ function unsafe_getindex(r :: StepRangeLen{T}, i :: Integer) where T
- function unsafe_load(p::Ptr, i::Integer, order::Symbol)
+ function unsafe_load(p :: Ptr, i :: Integer, order :: Symbol)
- function unsafe_load_commands(v::Ptr{Ptr{UInt8}})
+ function unsafe_load_commands(v :: Ptr{Ptr{UInt8}})
- function unsafe_modify!(p::Ptr, op, x, order::Symbol=:not_atomic)
+ function unsafe_modify!(p :: Ptr, op, x, order :: Symbol = :not_atomic)
- function unsafe_read(f::File, p::Ptr{UInt8}, nel::UInt)
+ function unsafe_read(f :: File, p :: Ptr{UInt8}, nel :: UInt)
- function unsafe_read(from::GenericIOBuffer, p::Ptr{UInt8}, nb::UInt)
+ function unsafe_read(from :: GenericIOBuffer, p :: Ptr{UInt8}, nb :: UInt)
- function unsafe_read(s::BufferStream, a::Ptr{UInt8}, nb::UInt)
+ function unsafe_read(s :: BufferStream, a :: Ptr{UInt8}, nb :: UInt)
- function unsafe_read(s::IO, p::Ptr{UInt8}, n::UInt)
+ function unsafe_read(s :: IO, p :: Ptr{UInt8}, n :: UInt)
- function unsafe_read(s::IOStream, p::Ptr{UInt8}, nb::UInt)
+ function unsafe_read(s :: IOStream, p :: Ptr{UInt8}, nb :: UInt)
- function unsafe_read(s::LibuvStream, p::Ptr{UInt8}, nb::UInt)
+ function unsafe_read(s :: LibuvStream, p :: Ptr{UInt8}, nb :: UInt)
- function unsafe_replace!(p::Ptr{Any}, @nospecialize(expected), @nospecialize(desired), success_order::Symbol=:not_atomic, fail_order::Symbol=success_order)
+ function unsafe_replace!(p :: Ptr{Any}, expected, desired, success_order :: Symbol = :not_atomic, fail_order :: Symbol = success_order)
- function unsafe_replace!(p::Ptr{T}, expected, desired, success_order::Symbol=:not_atomic, fail_order::Symbol=success_order) where {T}
+ function unsafe_replace!(p :: Ptr{T}, expected, desired, success_order :: Symbol = :not_atomic, fail_order :: Symbol = success_order) where T
- function unsafe_setindex!(A::AbstractArray, v, I...)
+ function unsafe_setindex!(A :: AbstractArray, v, I...)
- function unsafe_store!(p::Ptr, x, i::Integer, order::Symbol)
+ function unsafe_store!(p :: Ptr, x, i :: Integer, order :: Symbol)
- function unsafe_string(cw::Cwstring)
+ function unsafe_string(cw :: Cwstring)
- function unsafe_string(p::Ptr{T}, length::Integer) where {T<:Union{UInt16,UInt32,Cwchar_t}}
+ function unsafe_string(p :: Ptr{T}, length :: Integer) where T <: Union{UInt16, UInt32, Cwchar_t}
- function unsafe_string(p::Union{Ptr{UInt8},Ptr{Int8}})
+ function unsafe_string(p :: Union{Ptr{UInt8}, Ptr{Int8}})
- function unsafe_string(p::Union{Ptr{UInt8},Ptr{Int8}}, len::Integer)
+ function unsafe_string(p :: Union{Ptr{UInt8}, Ptr{Int8}}, len :: Integer)
- function unsafe_swap!(p::Ptr{Any}, x, order::Symbol=:not_atomic)
+ function unsafe_swap!(p :: Ptr{Any}, x, order :: Symbol = :not_atomic)
- function unsafe_swap!(p::Ptr{T}, x, order::Symbol=:not_atomic) where {T}
+ function unsafe_swap!(p :: Ptr{T}, x, order :: Symbol = :not_atomic) where T
- function unsafe_trunc(::Type{Int128}, x::Float32)
+ function unsafe_trunc(??? :: Type{Int128}, x :: Float32)
- function unsafe_trunc(::Type{Int128}, x::Float64)
+ function unsafe_trunc(??? :: Type{Int128}, x :: Float64)
- function unsafe_trunc(::Type{UInt128}, x::Float32)
+ function unsafe_trunc(??? :: Type{UInt128}, x :: Float32)
- function unsafe_trunc(::Type{UInt128}, x::Float64)
+ function unsafe_trunc(??? :: Type{UInt128}, x :: Float64)
- function unsafe_view(A::AbstractArray, I::Vararg{ViewIndex,N}) where {N}
+ function unsafe_view(A :: AbstractArray, I :: Vararg{ViewIndex, N}) where N
- function unsafe_write(f::File, buf::Ptr{UInt8}, len::UInt, offset::Int64=Int64(-1))
+ function unsafe_write(f :: File, buf :: Ptr{UInt8}, len :: UInt, offset :: Int64 = Int64(-1))
- function unsafe_write(s::BufferStream, p::Ptr{UInt8}, nb::UInt)
+ function unsafe_write(s :: BufferStream, p :: Ptr{UInt8}, nb :: UInt)
- function unsafe_write(s::IO, p::Ptr{UInt8}, n::UInt)
+ function unsafe_write(s :: IO, p :: Ptr{UInt8}, n :: UInt)
- function unsafe_write(s::IOStream, p::Ptr{UInt8}, nb::UInt)
+ function unsafe_write(s :: IOStream, p :: Ptr{UInt8}, nb :: UInt)
- function unsafe_write(s::LibuvStream, p::Ptr{UInt8}, n::UInt)
+ function unsafe_write(s :: LibuvStream, p :: Ptr{UInt8}, n :: UInt)
- function unsafe_write(to::GenericIOBuffer, p::Ptr{UInt8}, nb::UInt)
+ function unsafe_write(to :: GenericIOBuffer, p :: Ptr{UInt8}, nb :: UInt)
- function unset!(trie::HAMT, bi::BitmapIndex)
+ function unset!(trie :: HAMT, bi :: BitmapIndex)
- function unused_apply_iterate()
+ function unused_apply_iterate
- function unwatch_folder(s::String)
+ function unwatch_folder(s :: String)
- function unwrap_macrocalls(ex::Expr)
+ function unwrap_macrocalls(ex :: Expr)
- function unwrap_task_failed(f::Function, t::UnwrapTaskFailedException)
+ function unwrap_task_failed(f :: Function, t :: UnwrapTaskFailedException)
- function unwrap_unionall(@nospecialize(a))
+ function unwrap_unionall(a)
- function unwraptv_lb(@nospecialize t)
+ function unwraptv_lb(t)
- function unwraptv_ub(@nospecialize t)
+ function unwraptv_ub(t)
- function unwrapva(@nospecialize(t))
+ function unwrapva(t)
- function update!(idx::GitIndex, files::AbstractString...)
+ function update!(idx :: GitIndex, files :: AbstractString...)
- function update!(repo::GitRepo, files::AbstractString...)
+ function update!(repo :: GitRepo, files :: AbstractString...)
- function update21311!(x)
+ function update21311!(x)
- function update_bbstate!(Lᵢ::AbstractLattice, frame::InferenceState, bb::Int, vartable::VarTable)
+ function update_bbstate!(Lᵢ :: AbstractLattice, frame :: InferenceState, bb :: Int, vartable :: VarTable)
- function update_display_buffer(s::SearchState, data::ModeState)
+ function update_display_buffer(s :: SearchState, data :: ModeState)
- function update_key_repeats(s::MIState, keystroke::Vector{Char})
+ function update_key_repeats(s :: MIState, keystroke :: Vector{Char})
- function update_level!(nodes::Vector{DomTreeNode}, node::BBNumber, level::Int)
+ function update_level!(nodes :: Vector{DomTreeNode}, node :: BBNumber, level :: Int)
- function update_phi!(irsv::IRInterpretationState, from::Int, to::Int)
+ function update_phi!(irsv :: IRInterpretationState, from :: Int, to :: Int)
- function update_valid_age!(sv::AbsIntState, valid_worlds::WorldRange)
+ function update_valid_age!(sv :: AbsIntState, valid_worlds :: WorldRange)
- function updated_methodloc(m::Method)::Tuple{String, Int32}
+ function updated_methodloc(m :: Method)
- function uppercasefirst(s::AbstractString)
+ function uppercasefirst(s :: AbstractString)
- function upstream(ref::GitReference)
+ function upstream(ref :: GitReference)
- function uptime()
+ function uptime
- function url(m::Method)
+ function url(m :: Method)
- function url(rmt::GitRemote)
+ function url(rmt :: GitRemote)
- function use_http_path(cfg::GitConfig, cred::GitCredential)
+ function use_http_path(cfg :: GitConfig, cred :: GitCredential)
- function use_tuple28445(c)
+ function use_tuple28445(c)
- function useless_finalizer()
+ function useless_finalizer
- function user_abort()
+ function user_abort
- function userefs(@nospecialize(x))
+ function userefs(x)
- function username()
+ function username
- function uses_frontend_opaque(x)
+ function uses_frontend_opaque(x)
- function utf8proc_decompose(str, options, buffer, nwords, chartransform::T) where T
+ function utf8proc_decompose(str, options, buffer, nwords, chartransform :: T) where T
- function utf8proc_decompose(str, options, buffer, nwords, chartransform::typeof(identity))
+ function utf8proc_decompose(str, options, buffer, nwords, chartransform :: typeof(identity))
- function utf8proc_map(str::Union{String,SubString{String}}, options::Integer, chartransform=identity)
+ function utf8proc_map(str :: Union{String, SubString{String}}, options :: Integer, chartransform = identity)
- function uuid1(rng::AbstractRNG=Random.RandomDevice())
+ function uuid1(rng :: AbstractRNG = Random.RandomDevice())
- function uuid4(rng::AbstractRNG=Random.RandomDevice())
+ function uuid4(rng :: AbstractRNG = Random.RandomDevice())
- function uuid5(namespace::UUID, key::String)
+ function uuid5(namespace :: UUID, key :: String)
- function uuid5(ns::UUID, name::String)
+ function uuid5(ns :: UUID, name :: String)
- function uv_alloc_buf(handle::Ptr{Cvoid}, size::Csize_t, buf::Ptr{Cvoid})
+ function uv_alloc_buf(handle :: Ptr{Cvoid}, size :: Csize_t, buf :: Ptr{Cvoid})
- function uv_asynccb(handle::Ptr{Cvoid})
+ function uv_asynccb(handle :: Ptr{Cvoid})
- function uv_connectcb(conn::Ptr{Cvoid}, status::Cint)
+ function uv_connectcb(conn :: Ptr{Cvoid}, status :: Cint)
- function uv_connectioncb(stream::Ptr{Cvoid}, status::Cint)
+ function uv_connectioncb(stream :: Ptr{Cvoid}, status :: Cint)
- function uv_fseventscb_file(handle::Ptr{Cvoid}, filename::Ptr, events::Int32, status::Int32)
+ function uv_fseventscb_file(handle :: Ptr{Cvoid}, filename :: Ptr, events :: Int32, status :: Int32)
- function uv_fseventscb_folder(handle::Ptr{Cvoid}, filename::Ptr, events::Int32, status::Int32)
+ function uv_fseventscb_folder(handle :: Ptr{Cvoid}, filename :: Ptr, events :: Int32, status :: Int32)
- function uv_fspollcb(handle::Ptr{Cvoid}, status::Int32, prev::Ptr, curr::Ptr)
+ function uv_fspollcb(handle :: Ptr{Cvoid}, status :: Int32, prev :: Ptr, curr :: Ptr)
- function uv_getaddrinfocb(req::Ptr{Cvoid}, status::Cint, addrinfo::Ptr{Cvoid})
+ function uv_getaddrinfocb(req :: Ptr{Cvoid}, status :: Cint, addrinfo :: Ptr{Cvoid})
- function uv_getnameinfocb(req::Ptr{Cvoid}, status::Cint, hostname::Cstring, service::Cstring)
+ function uv_getnameinfocb(req :: Ptr{Cvoid}, status :: Cint, hostname :: Cstring, service :: Cstring)
- function uv_pollcb(handle::Ptr{Cvoid}, status::Int32, events::Int32)
+ function uv_pollcb(handle :: Ptr{Cvoid}, status :: Int32, events :: Int32)
- function uv_readcb(handle::Ptr{Cvoid}, nread::Cssize_t, buf::Ptr{Cvoid})
+ function uv_readcb(handle :: Ptr{Cvoid}, nread :: Cssize_t, buf :: Ptr{Cvoid})
- function uv_recvcb(handle::Ptr{Cvoid}, nread::Cssize_t, buf::Ptr{Cvoid}, addr::Ptr{Cvoid}, flags::Cuint)
+ function uv_recvcb(handle :: Ptr{Cvoid}, nread :: Cssize_t, buf :: Ptr{Cvoid}, addr :: Ptr{Cvoid}, flags :: Cuint)
- function uv_ref(h::Ptr{Cvoid})
+ function uv_ref(h :: Ptr{Cvoid})
- function uv_return_spawn(p::Ptr{Cvoid}, exit_status::Int64, termsignal::Int32)
+ function uv_return_spawn(p :: Ptr{Cvoid}, exit_status :: Int64, termsignal :: Int32)
- function uv_shutdowncb_task(req::Ptr{Cvoid}, status::Cint)
+ function uv_shutdowncb_task(req :: Ptr{Cvoid}, status :: Cint)
- function uv_sizeof_handle(handle)
+ function uv_sizeof_handle(handle)
- function uv_sizeof_req(req)
+ function uv_sizeof_req(req)
- function uv_status_string(x)
+ function uv_status_string(x)
- function uv_thread_getaffinity()
+ function uv_thread_getaffinity
- function uv_timercb(handle::Ptr{Cvoid})
+ function uv_timercb(handle :: Ptr{Cvoid})
- function uv_unref(h::Ptr{Cvoid})
+ function uv_unref(h :: Ptr{Cvoid})
- function uv_write(s::LibuvStream, p::Ptr{UInt8}, n::UInt)
+ function uv_write(s :: LibuvStream, p :: Ptr{UInt8}, n :: UInt)
- function uv_write_async(s::LibuvStream, p::Ptr{UInt8}, n::UInt)
+ function uv_write_async(s :: LibuvStream, p :: Ptr{UInt8}, n :: UInt)
- function uv_writecb_task(req::Ptr{Cvoid}, status::Cint)
+ function uv_writecb_task(req :: Ptr{Cvoid}, status :: Cint)
- function uvfinalize(proc::Process)
+ function uvfinalize(proc :: Process)
- function uvfinalize(t::Union{Timer, AsyncCondition})
+ function uvfinalize(t :: Union{Timer, AsyncCondition})
- function uvfinalize(uv::Union{FileMonitor, FolderMonitor, PollingFileWatcher})
+ function uvfinalize(uv :: Union{FileMonitor, FolderMonitor, PollingFileWatcher})
- function uvfinalize(uv::Union{LibuvStream, LibuvServer})
+ function uvfinalize(uv :: Union{LibuvStream, LibuvServer})
- function v6387(r::AbstractRange{T}) where T
+ function v6387(r :: AbstractRange{T}) where T
- function va_from_vatuple(@nospecialize(t))
+ function va_from_vatuple(t)
- function va_process_argtypes(@specialize(va_handler!), L::AbstractLattice, given_argtypes::Vector{Any}, mi::MethodInstance)
+ function va_process_argtypes(va_handler!, L :: AbstractLattice, given_argtypes :: Vector{Any}, mi :: MethodInstance)
- function val_for_def_expr(ir::IRCode, def::Int, fidx::Int)
+ function val_for_def_expr(ir :: IRCode, def :: Int, fidx :: Int)
- function valid_as_lattice(@nospecialize(x), astag::Bool=false)
+ function valid_as_lattice(x, astag :: Bool = false)
- function valid_import_path(@nospecialize(ex), allow_as = true)
+ function valid_import_path(ex, allow_as = true)
- function valid_typeof_tparam(@nospecialize(t))
+ function valid_typeof_tparam(t)
- function valid_usecase1(f, xs)
+ function valid_usecase1(f, xs)
- function validargs(::Type{Date}, y::Int64, m::Int64, d::Int64)
+ function validargs(??? :: Type{Date}, y :: Int64, m :: Int64, d :: Int64)
- function validargs(::Type{Time}, h::Int64, mi::Int64, s::Int64, ms::Int64, us::Int64, ns::Int64, ampm::AMPM=TWENTYFOURHOUR)
+ function validargs(??? :: Type{Time}, h :: Int64, mi :: Int64, s :: Int64, ms :: Int64, us :: Int64, ns :: Int64, ampm :: AMPM = TWENTYFOURHOUR)
- function validate_code!(errors::Vector{InvalidCodeError}, c::CodeInfo, is_top_level::Bool = false)
+ function validate_code!(errors :: Vector{InvalidCodeError}, c :: CodeInfo, is_top_level :: Bool = false)
- function validate_code!(errors::Vector{InvalidCodeError}, mi::Core.MethodInstance, c::Union{Nothing,CodeInfo})
+ function validate_code!(errors :: Vector{InvalidCodeError}, mi :: Core.MethodInstance, c :: Union{Nothing, CodeInfo})
- function validate_code_in_debug_mode(linfo::MethodInstance, src::CodeInfo, kind::String)
+ function validate_code_in_debug_mode(linfo :: MethodInstance, src :: CodeInfo, kind :: String)
- function validate_keymap(keymap)
+ function validate_keymap(keymap)
- function validate_sparams(sparams::SimpleVector)
+ function validate_sparams(sparams :: SimpleVector)
- function validate_tags(tags::Dict)
+ function validate_tags(tags :: Dict)
- function varargs_finalizer(args...)
+ function varargs_finalizer(args...)
- function varinfo(m::Module=Base.active_module(), pattern::Regex=r""; all::Bool = false, imported::Bool = false, recursive::Bool = false, sortby::Symbol = :name, minsize::Int=0)
+ function varinfo(m :: Module = Base.active_module(), pattern :: Regex = r"", all :: Bool = false, imported :: Bool = false, recursive :: Bool = false, sortby :: Symbol = :name, minsize :: Int = 0)
- function vcat(A::BitMatrix...)
+ function vcat(A :: BitMatrix...)
- function vcat(V::BitVector...)
+ function vcat(V :: BitVector...)
- function vcat(arrays::Vector{T}...) where T
+ function vcat(arrays :: Vector{T}...) where T
- function vcat(rs::AbstractRange{T}...) where T
+ function vcat(rs :: AbstractRange{T}...) where T
- function vect(X...)
+ function vect(X...)
- function vect(X::T...) where T
+ function vect(X :: T...) where T
- function verify_batch_size(batch_size)
+ function verify_batch_size(batch_size)
- function verify_display(ir)
+ function verify_display(ir)
- function verify_host_error(message::AbstractString)
+ function verify_host_error(message :: AbstractString)
- function verify_huge(init, a, b)
+ function verify_huge(init, a, b)
- function verify_linetable(linetable::Vector{LineInfoNode}, print::Bool=true)
+ function verify_linetable(linetable :: Vector{LineInfoNode}, print :: Bool = true)
- function verify_ntasks(iterable, ntasks)
+ function verify_ntasks(iterable, ntasks)
- function version()
+ function version
- function version_slug(uuid::UUID, sha1::SHA1, p::Int=5)
+ function version_slug(uuid :: UUID, sha1 :: SHA1, p :: Int = 5)
- function versioninfo(io::IO=stdout)
+ function versioninfo(io :: IO = stdout)
- function versioninfo(io::IO=stdout; verbose::Bool=false)
+ function versioninfo(io :: IO = stdout, verbose :: Bool = false)
- function view(A::AbstractArray{<:Any,N}, I::Vararg{Any,M}) where {N,M}
+ function view(A :: AbstractArray{??? <: Any, N}, I :: Vararg{Any, M}) where N, M
- function view(r1::AbstractRange, c::Colon)
+ function view(r1 :: AbstractRange, c :: Colon)
- function view(r1::AbstractUnitRange, r2::AbstractUnitRange{<:Integer})
+ function view(r1 :: AbstractUnitRange, r2 :: AbstractUnitRange{??? <: Integer})
- function view(r1::AbstractUnitRange, r2::StepRange{<:Integer})
+ function view(r1 :: AbstractUnitRange, r2 :: StepRange{??? <: Integer})
- function view(r1::LinRange, r2::OrdinalRange{<:Integer})
+ function view(r1 :: LinRange, r2 :: OrdinalRange{??? <: Integer})
- function view(r1::OneTo, r2::OneTo)
+ function view(r1 :: OneTo, r2 :: OneTo)
- function view(r1::StepRange, r2::AbstractRange{<:Integer})
+ function view(r1 :: StepRange, r2 :: AbstractRange{??? <: Integer})
- function view(r1::StepRangeLen, r2::OrdinalRange{<:Integer})
+ function view(r1 :: StepRangeLen, r2 :: OrdinalRange{??? <: Integer})
- function visit!(bb::Int)
+ function visit!(bb :: Int)
- function visit(f, d::Core.TypeMapEntry)
+ function visit(f, d :: Core.TypeMapEntry)
- function visit(f, mc::Core.TypeMapLevel)
+ function visit(f, mc :: Core.TypeMapLevel)
- function visit(f, mt::Core.MethodTable)
+ function visit(f, mt :: Core.MethodTable)
- function visit_bb_phis!(callback, ir::IRCode, bb::Int)
+ function visit_bb_phis!(callback, ir :: IRCode, bb :: Int)
- function wait()
+ function wait
- function wait(c::Channel)
+ function wait(c :: Channel)
- function wait(c::GenericCondition; first::Bool=false)
+ function wait(c :: GenericCondition, first :: Bool = false)
- function wait(e::Event)
+ function wait(e :: Event)
- function wait(fd::RawFD, mask::FDEvent)
+ function wait(fd :: RawFD, mask :: FDEvent)
- function wait(fdw::FDWatcher)
+ function wait(fdw :: FDWatcher)
- function wait(fdw::_FDWatcher, mask::FDEvent)
+ function wait(fdw :: _FDWatcher, mask :: FDEvent)
- function wait(fdw::_FDWatcher; readable=true, writable=true)
+ function wait(fdw :: _FDWatcher, readable = true, writable = true)
- function wait(m::FileMonitor)
+ function wait(m :: FileMonitor)
- function wait(m::FolderMonitor)
+ function wait(m :: FolderMonitor)
- function wait(pfw::PollingFileWatcher)
+ function wait(pfw :: PollingFileWatcher)
- function wait(socket::RawFD; readable=false, writable=false)
+ function wait(socket :: RawFD, readable = false, writable = false)
- function wait(socket::WindowsRawSocket, mask::FDEvent)
+ function wait(socket :: WindowsRawSocket, mask :: FDEvent)
- function wait(socket::WindowsRawSocket; readable=false, writable=false)
+ function wait(socket :: WindowsRawSocket, readable = false, writable = false)
- function wait(t::Task)
+ function wait(t :: Task)
- function wait(t::Union{Timer, AsyncCondition})
+ function wait(t :: Union{Timer, AsyncCondition})
- function wait(x::Process)
+ function wait(x :: Process)
- function wait_close(s::BufferStream)
+ function wait_close(s :: BufferStream)
- function wait_close(x::Union{LibuvStream, LibuvServer})
+ function wait_close(x :: Union{LibuvStream, LibuvServer})
- function wait_connected(x::LibuvStream)
+ function wait_connected(x :: LibuvStream)
- function wait_done(itr::AsyncCollector, state::AsyncCollectorState)
+ function wait_done(itr :: AsyncCollector, state :: AsyncCollectorState)
- function wait_locked(s, buf, nb)
+ function wait_locked(s, buf, nb)
- function wait_readnb(s::BufferStream, nb::Int)
+ function wait_readnb(s :: BufferStream, nb :: Int)
- function wait_readnb(x::LibuvStream, nb::Int)
+ function wait_readnb(x :: LibuvStream, nb :: Int)
- function waitkill(P::Union{Process,ProcessChain})
+ function waitkill(P :: Union{Process, ProcessChain})
- function walk(func, expr)
+ function walk(func, expr)
- function walk_to_def(compact::IncrementalCompact, @nospecialize(leaf))
+ function walk_to_def(compact :: IncrementalCompact, leaf)
- function walk_to_defs(compact::IncrementalCompact, @nospecialize(defssa), @nospecialize(typeconstraint), predecessors, Lₒ::AbstractLattice)
+ function walk_to_defs(compact :: IncrementalCompact, defssa, typeconstraint, predecessors, Lₒ :: AbstractLattice)
- function walkdir(root; topdown=true, follow_symlinks=false, onerror=throw)
+ function walkdir(root, topdown = true, follow_symlinks = false, onerror = throw)
- function warning_empty()
+ function warning_empty
- function warning_empty(;summary = false)
+ function warning_empty(summary = false)
- function warntype_hastag(f, types, tag)
+ function warntype_hastag(f, types, tag)
- function warntype_type_printer(io::IO; @nospecialize(type), used::Bool, show_type::Bool=true, _...)
+ function warntype_type_printer(io :: IO, type, used :: Bool, show_type :: Bool = true, _...)
- function watch_file(s::String, timeout_s::Float64=-1.0)
+ function watch_file(s :: String, timeout_s :: Float64 = -1.0)
- function watch_folder(s::String, timeout_s::Real=-1)
+ function watch_folder(s :: String, timeout_s :: Real = -1)
- function week(days)
+ function week(days)
- function wfunc(c1,c2)
+ function wfunc(c1, c2)
- function where1090(x::Array{T})::T where T<:Real
+ function where1090(x :: Array{T}) where T <: Real
- function which(@nospecialize(f), @nospecialize(t))
+ function which(f, t)
- function which(m::Module, s::Symbol)
+ function which(m :: Module, s :: Symbol)
- function which(program_name::String)
+ function which(program_name :: String)
- function widemul(u::Int64, v::Int64)
+ function widemul(u :: Int64, v :: Int64)
- function widemul(u::UInt64, v::UInt64)
+ function widemul(u :: UInt64, v :: UInt64)
- function widen_all_consts!(src::CodeInfo)
+ function widen_all_consts!(src :: CodeInfo)
- function widenlattice(L::AbstractLattice, @nospecialize(t))
+ function widenlattice(L :: AbstractLattice, t)
- function windows_version()
+ function windows_version
- function winprompt(message, caption, default_username; prompt_username = true)
+ function winprompt(message, caption, default_username, prompt_username = true)
- function winuppercase(s::AbstractString)
+ function winuppercase(s :: AbstractString)
- function with(f, pair::Pair{<:ScopedValue}, rest::Pair{<:ScopedValue}...)
+ function with(f, pair :: Pair{??? <: ScopedValue}, rest :: Pair{??? <: ScopedValue}...)
- function with(f::Function, obj)
+ function with(f :: Function, obj)
- function with_artifacts_directory(f::Function, artifacts_dir::String)
+ function with_artifacts_directory(f :: Function, artifacts_dir :: String)
- function with_fake_pty(f)
+ function with_fake_pty(f)
- function with_libgit2_temp_home(f)
+ function with_libgit2_temp_home(f)
- function with_logger(@nospecialize(f::Function), logger::AbstractLogger)
+ function with_logger(f :: Function, logger :: AbstractLogger)
- function with_normalized_name(@nospecialize(f), @nospecialize(x))
+ function with_normalized_name(f, x)
- function with_raw_tty(f::Function, input::TTY)
+ function with_raw_tty(f :: Function, input :: TTY)
- function with_repl_linfo(f, repl::LineEditREPL)
+ function with_repl_linfo(f, repl :: LineEditREPL)
- function with_self_aliased(from_bb::Int, succs::Vector{Int})
+ function with_self_aliased(from_bb :: Int, succs :: Vector{Int})
- function with_temp_cleanup(f::Function, n::Int)
+ function with_temp_cleanup(f :: Function, n :: Int)
- function with_ulimit(f::Function, stacksize::Int)
+ function with_ulimit(f :: Function, stacksize :: Int)
- function with_unmatched_typeparam()
+ function with_unmatched_typeparam
- function with_warn(f::Function, ::Type{T}, args...) where T
+ function with_warn(f :: Function, ??? :: Type{T}, args...) where T
- function withenv(f, keyvals::Pair{T}...) where T<:AbstractString
+ function withenv(f, keyvals :: Pair{T}...) where T <: AbstractString
- function withlocales(f, newlocales)
+ function withlocales(f, newlocales)
- function withstream(f, stream)
+ function withstream(f, stream)
- function withtag(f, io::IO, tag, attrs...)
+ function withtag(f, io :: IO, tag, attrs...)
- function work(size)
+ function work(size)
- function workdir(repo::GitRepo)
+ function workdir(repo :: GitRepo)
- function workqueue_for(tid::Int)
+ function workqueue_for(tid :: Int)
- function worlds(mi::Core.MethodInstance)
+ function worlds(mi :: Core.MethodInstance)
- function wrap1_wrap1_ifelse(b, x, w1)
+ function wrap1_wrap1_ifelse(b, x, w1)
- function wrap1_wrap1_wrapper(b, x, y)
+ function wrap1_wrap1_wrapper(b, x, y)
- function wrap_n_exec_twice(chnl, worker_tasks, ntasks, exec_func, c...)
+ function wrap_n_exec_twice(chnl, worker_tasks, ntasks, exec_func, c...)
- function wrapblock(f, io, env)
+ function wrapblock(f, io, env)
- function wrapinline(f, io, cmd)
+ function wrapinline(f, io, cmd)
- function wrapped_line(io::IO, s::AbstractString, width, i)
+ function wrapped_line(io :: IO, s :: AbstractString, width, i)
- function wrapped_lines(io::IO, s::AbstractString; width = 80, i = 0)
+ function wrapped_lines(io :: IO, s :: AbstractString, width = 80, i = 0)
- function write!(idx::GitIndex)
+ function write!(idx :: GitIndex)
- function write(io::IO, c::Char)
+ function write(io :: IO, c :: Char)
- function write(io::IO, s::SecretBuffer)
+ function write(io :: IO, s :: SecretBuffer)
- function write(io::IO, s::Symbol)
+ function write(io :: IO, s :: Symbol)
- function write(io::IO, x1, xs...)
+ function write(io :: IO, x1, xs...)
- function write(io::IO, x::String)
+ function write(io :: IO, x :: String)
- function write(io::SecretBuffer, b::UInt8)
+ function write(io :: SecretBuffer, b :: UInt8)
- function write(s::IO, A::AbstractArray)
+ function write(s :: IO, A :: AbstractArray)
- function write(s::IO, A::StridedArray)
+ function write(s :: IO, A :: StridedArray)
- function write(s::IO, x::Ref{T}) where {T}
+ function write(s :: IO, x :: Ref{T}) where T
- function write(s::IO, x::Union{Int16,UInt16,Int32,UInt32,Int64,UInt64,Int128,UInt128,Float16,Float32,Float64})
+ function write(s :: IO, x :: Union{Int16, UInt16, Int32, UInt32, Int64, UInt64, Int128, UInt128, Float16, Float32, Float64})
- function write(s::IO, z::Complex)
+ function write(s :: IO, z :: Complex)
- function write(s::IO, z::Rational)
+ function write(s :: IO, z :: Rational)
- function write(s::IOStream, b::UInt8)
+ function write(s :: IOStream, b :: UInt8)
- function write(s::LibuvStream, b::UInt8)
+ function write(s :: LibuvStream, b :: UInt8)
- function write(to::IO, from::GenericIOBuffer)
+ function write(to :: IO, from :: GenericIOBuffer)
- function write(to::IO, from::IO)
+ function write(to :: IO, from :: IO)
- function writeLine(buf::IOBuffer, m::AbstractMenu, idx::Int, cursor::Bool)
+ function writeLine(buf :: IOBuffer, m :: AbstractMenu, idx :: Int, cursor :: Bool)
- function writeLine(buf::IOBuffer, menu::RadioMenu{<:Dict}, idx::Int, cursor::Bool)
+ function writeLine(buf :: IOBuffer, menu :: RadioMenu{??? <: Dict}, idx :: Int, cursor :: Bool)
- function write_as_tag(s::IO, tag)
+ function write_as_tag(s :: IO, tag)
- function write_output_prefix(io::IO, p::Prompt, color::Bool)
+ function write_output_prefix(io :: IO, p :: Prompt, color :: Bool)
- function write_pidfile(io::IO, pid::Cint)
+ function write_pidfile(io :: IO, pid :: Cint)
- function write_prompt(terminal::AbstractTerminal, p::Prompt, color::Bool)
+ function write_prompt(terminal :: AbstractTerminal, p :: Prompt, color :: Bool)
- function write_prompt(terminal::Union{IO, AbstractTerminal}, s::Union{AbstractString,Function}, color::Bool)
+ function write_prompt(terminal :: Union{IO, AbstractTerminal}, s :: Union{AbstractString, Function}, color :: Bool)
- function write_tree!(idx::GitIndex)
+ function write_tree!(idx :: GitIndex)
- function writeheader(s::AbstractSerializer)
+ function writeheader(s :: AbstractSerializer)
- function writeline(buf::IO, m::AbstractMenu, idx::Int, iscursor::Bool)
+ function writeline(buf :: IO, m :: AbstractMenu, idx :: Int, iscursor :: Bool)
- function writeline(buf::IOBuffer, menu::MultiSelectMenu{MultiSelectConfig}, idx::Int, iscursor::Bool)
+ function writeline(buf :: IOBuffer, menu :: MultiSelectMenu{MultiSelectConfig}, idx :: Int, iscursor :: Bool)
- function writeline(buf::IOBuffer, menu::RadioMenu{Config}, idx::Int, iscursor::Bool)
+ function writeline(buf :: IOBuffer, menu :: RadioMenu{Config}, idx :: Int, iscursor :: Bool)
- function writeline(buf::IOBuffer, pager::Pager{Config}, idx::Int, iscursor::Bool)
+ function writeline(buf :: IOBuffer, pager :: Pager{Config}, idx :: Int, iscursor :: Bool)
- function writereadpipeline(input, exename)
+ function writereadpipeline(input, exename)
- function x3220()
+ function x3220
- function xoshiro_bulk_nosimd(rng::Union{TaskLocalRNG, Xoshiro}, dst::Ptr{UInt8}, len::Int, ::Type{Bool}, f)
+ function xoshiro_bulk_nosimd(rng :: Union{TaskLocalRNG, Xoshiro}, dst :: Ptr{UInt8}, len :: Int, ??? :: Type{Bool}, f)
- function xoshiro_bulk_simd(rng::Union{TaskLocalRNG, Xoshiro}, dst::Ptr{UInt8}, len::Int, ::Type{Bool}, ::Val{N}, f) where {N}
+ function xoshiro_bulk_simd(rng :: Union{TaskLocalRNG, Xoshiro}, dst :: Ptr{UInt8}, len :: Int, ??? :: Type{Bool}, ??? :: Val{N}, f) where N
- function xoshiro_bulk_simd(rng::Union{TaskLocalRNG, Xoshiro}, dst::Ptr{UInt8}, len::Int, ::Type{T}, ::Val{N}, f::F) where {T,N,F}
+ function xoshiro_bulk_simd(rng :: Union{TaskLocalRNG, Xoshiro}, dst :: Ptr{UInt8}, len :: Int, ??? :: Type{T}, ??? :: Val{N}, f :: F) where T, N, F
- function year(days)
+ function year(days)
- function yearmonth(days)
+ function yearmonth(days)
- function yearmonthday(days)
+ function yearmonthday(days)
- function yield()
+ function yield
- function yield(t::Task, @nospecialize(x=nothing))
+ function yield(t :: Task, x = nothing)
- function yieldto(t::Task, @nospecialize(x=nothing))
+ function yieldto(t :: Task, x = nothing)
- function zero(::Type{TwicePrecision{T}}) where {T}
+ function zero(??? :: Type{TwicePrecision{T}}) where T
- function Struct{T}(arg1) where Integer <: T <: Real
+ function Struct{T}(arg1) where Real <: Integer <: T
- function Struct{T}(arg1) where T
+ function Struct{T}(arg1) where T
- function Struct{T}(arg1) where T >: Int
+ function Struct{T}(arg1) where Int <: T
- function Struct{T}(arg1) where T<:Float64
+ function Struct{T}(arg1) where T <: Float64
- function code_ircode(@nospecialize(f), @nospecialize(types = default_tt(f)); kwargs...)
+ function code_ircode(f, types = default_tt(f), kwargs...)
- function code_typed(@nospecialize(f), @nospecialize(types=default_tt(f)); kwargs...)
+ function code_typed(f, types = default_tt(f), kwargs...)
